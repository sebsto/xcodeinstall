<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Coverage</title>
    <style>
      body {
        background: #111;
        color: #888;
        font-family: monospace;
        font-size: 15px;
      }
      nav { position: fixed; top: 0; }
      pre { margin-top: 25px; }
      .c { color: green; }
      .nc { color: red; }
    </style>
  </head>
  <body>
    <nav>
      <select id="files">
        <option value="f0">Sources/xcodeinstall/API/Authentication+Hashcash.swift (82.7%)</option><option value="f1">Sources/xcodeinstall/API/Authentication+MFA.swift (84.4%)</option><option value="f2">Sources/xcodeinstall/API/Authentication+SRP.swift (95.8%)</option><option value="f3">Sources/xcodeinstall/API/Authentication+UsernamePassword.swift (100.0%)</option><option value="f4">Sources/xcodeinstall/API/Authentication.swift (83.5%)</option><option value="f5">Sources/xcodeinstall/API/Download.swift (0.0%)</option><option value="f6">Sources/xcodeinstall/API/DownloadListData.swift (90.5%)</option><option value="f7">Sources/xcodeinstall/API/DownloadManager.swift (24.5%)</option><option value="f8">Sources/xcodeinstall/API/HTTPClient.swift (84.7%)</option><option value="f9">Sources/xcodeinstall/API/Install.swift (89.4%)</option><option value="f10">Sources/xcodeinstall/API/InstallCLTools.swift (67.4%)</option><option value="f11">Sources/xcodeinstall/API/InstallDownloadListExtension.swift (98.4%)</option><option value="f12">Sources/xcodeinstall/API/InstallPkg.swift (76.5%)</option><option value="f13">Sources/xcodeinstall/API/InstallSupportedFiles.swift (100.0%)</option><option value="f14">Sources/xcodeinstall/API/InstallXcode.swift (19.2%)</option><option value="f15">Sources/xcodeinstall/API/List.swift (0.0%)</option><option value="f16">Sources/xcodeinstall/API/URLLogger.swift (73.0%)</option><option value="f17">Sources/xcodeinstall/API/URLRequestExtension.swift (92.6%)</option><option value="f18">Sources/xcodeinstall/CLI-driver/CLIAuthenticate.swift (0.0%)</option><option value="f19">Sources/xcodeinstall/CLI-driver/CLIDownload.swift (84.2%)</option><option value="f20">Sources/xcodeinstall/CLI-driver/CLIInstall.swift (72.7%)</option><option value="f21">Sources/xcodeinstall/CLI-driver/CLIList.swift (91.4%)</option><option value="f22">Sources/xcodeinstall/CLI-driver/CLIMain.swift (100.0%)</option><option value="f23">Sources/xcodeinstall/CLI-driver/CLIProgressBar.swift (0.0%)</option><option value="f24">Sources/xcodeinstall/CLI-driver/CLIStoreSecrets.swift (66.7%)</option><option value="f25">Sources/xcodeinstall/Environment.swift (0.0%)</option><option value="f26">Sources/xcodeinstall/Secrets/SecretsHandler.swift (88.9%)</option><option value="f27">Sources/xcodeinstall/Secrets/SecretsStorageAWS+Soto.swift (46.8%)</option><option value="f28">Sources/xcodeinstall/Secrets/SecretsStorageAWS.swift (79.9%)</option><option value="f29">Sources/xcodeinstall/Secrets/SecretsStorageFile.swift (87.4%)</option><option value="f30">Sources/xcodeinstall/Utilities/Array+AsyncMap.swift (100.0%)</option><option value="f31">Sources/xcodeinstall/Utilities/FileHandler.swift (51.2%)</option><option value="f32">Sources/xcodeinstall/Utilities/HexEncoding.swift (47.5%)</option><option value="f33">Sources/xcodeinstall/Utilities/ShellOutput.swift (100.0%)</option><option value="f34">Sources/xcodeinstall/xcodeInstall/AuthenticateCommand.swift (0.0%)</option><option value="f35">Sources/xcodeinstall/xcodeInstall/DownloadCommand.swift (76.4%)</option><option value="f36">Sources/xcodeinstall/xcodeInstall/DownloadListParser.swift (93.7%)</option><option value="f37">Sources/xcodeinstall/xcodeInstall/InstallCommand.swift (67.7%)</option><option value="f38">Sources/xcodeinstall/xcodeInstall/ListCommand.swift (50.0%)</option><option value="f39">Sources/xcodeinstall/xcodeInstall/SignOutCommand.swift (0.0%)</option><option value="f40">Sources/xcodeinstall/xcodeInstall/StoreSecretsCommand.swift (87.2%)</option><option value="f41">Sources/xcodeinstall/xcodeInstall/XcodeInstallCommand.swift (100.0%)</option>
      </select>
    </nav><pre id="f0" style="display: none"><span>//
//  File.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 30/10/2024.
//

import CLIlib
import Crypto
import Foundation

extension AppleAuthenticator {
    func checkHashcash() async throws -&gt; String </span><span class="c">{

        guard let serviceKey = session.itcServiceKey?.authServiceKey else </span><span class="nc">{
            throw AuthenticationError.unableToRetrieveAppleHashcash(nil)
        }</span><span class="c">

        if </span><span class="c">session.hashcash == nil</span><span class="c"> </span><span class="nc">{
            var hashcash: String

            log.debug</span><span class="nc">(</span><span class="nc">"Requesting data to compute a hashcash"</span><span class="nc">)

            do </span><span class="nc">{
                hashcash = try await getAppleHashcash(itServiceKey: serviceKey)</span><span class="nc">
            }</span><span class="nc"> catch </span><span class="nc">{
                throw AuthenticationError.unableToRetrieveAppleHashcash(error)
            }</span><span class="nc">
            session.hashcash = hashcash
            log.debug</span><span class="nc">(</span><span class="nc">"Got an Apple hashcash : \(hashcash)"</span><span class="nc">)
        }</span><span class="c">

        // hashcash is never nil at this stage
        return session.hashcash!</span><span class="c">
    }</span><span class="">

    internal func getAppleHashcash(itServiceKey: String, date: String? = nil) async throws -&gt; String </span><span class="c">{

        /*
         ➜  ~ curl https://idmsa.apple.com/appleauth/auth/signin?widgetKey=e0b80c3bf78523bfe80974d320935bfa30add02e1bff88ec2166c6bd5a706c42
        
         ...
        
         &lt; X-Apple-HC-Bits: 10
         &lt; X-Apple-HC-Challenge: 0daf59bcaf9d721c0375756c5e404652
        
         ....
         */

        let url =
            "https://idmsa.apple.com/appleauth/auth/signin?widgetKey=\(itServiceKey)"
        let (_, response) = try await apiCall(
            url: url,
            validResponse: .value(200)
        )</span><span class="c">

        guard let hcString = response.allHeaderFields["X-Apple-HC-Bits"] as? String,
            let hcBits = Int(hcString),
            let hcChallenge = response.allHeaderFields["X-Apple-HC-Challenge"] as? String
        else </span><span class="c">{
            throw AuthenticationError.missingHTTPHeaders(
                "Unable to find 'X-Apple-HC-Bits' or 'X-Apple-HC-Challenge' to compute hashcash\n\(response.allHeaderFields)"
            )
        }</span><span class="c">

        log.debug</span><span class="nc">(</span><span class="nc">"Computing hashcash"</span><span class="c">)

        if </span><span class="c">date == nil</span><span class="c"> </span><span class="nc">{
            return Hashcash.make(bits: hcBits, challenge: hcChallenge)
        }</span><span class="c"> else </span><span class="c">{
            // just used for unit tests
            return Hashcash.make(bits: hcBits, challenge: hcChallenge, date: date)
        }</span><span class="c">
    }</span><span class="">
}

/*
 # This App Store Connect hashcash spec was generously donated by...
 #
 #                         __  _
 #    __ _  _ __   _ __   / _|(_)  __ _  _   _  _ __  ___  ___
 #   / _` || '_ \ | '_ \ | |_ | | / _` || | | || '__|/ _ \/ __|
 #  | (_| || |_) || |_) ||  _|| || (_| || |_| || |  |  __/\__ \
 #   \__,_|| .__/ | .__/ |_|  |_| \__, | \__,_||_|   \___||___/
 #         |_|    |_|             |___/
 #
 #
 # &lt;summary&gt;
 #             1:11:20230223170600:4d74fb15eb23f465f1f6fcbf534e5877::6373
 # X-APPLE-HC: 1:11:20230223170600:4d74fb15eb23f465f1f6fcbf534e5877::6373
 #             ^  ^      ^                       ^                     ^
 #             |  |      |                       |                     +-- Counter
 #             |  |      |                       +-- Resource
 #             |  |      +-- Date YYMMDD[hhmm[ss]]
 #             |  +-- Bits (number of leading zeros)
 #             +-- Version
 #
 # We can't use an off-the-shelf Hashcash because Apple's implementation is not quite the same as the spec/convention.
 #  1. The spec calls for a nonce called "Rand" to be inserted between the Ext and Counter. They don't do that at all.
 #  2. The Counter conventionally encoded as base-64 but Apple just uses the decimal number's string representation.
 #
 # Iterate from Counter=0 to Counter=N finding an N that makes the SHA1(X-APPLE-HC) lead with Bits leading zero bits
 #
 #
 # We get the "Resource" from the X-Apple-HC-Challenge header and Bits from X-Apple-HC-Bits
 #
 # &lt;/summary&gt;
 */

struct Hashcash {
    static func make(bits: Int, challenge: String, date d: String? = nil) -&gt; String </span><span class="c">{
        let version = 1

        let date: String
        if </span><span class="c">d != nil</span><span class="c"> </span><span class="c">{
            // we received a date, use it (for testing)
            date = d!
        }</span><span class="c"> else </span><span class="c">{
            let df = DateFormatter()
            df.dateFormat = "yyyyMMddHHmmss"
            date = df.string(from: Date())
        }</span><span class="c">

        var counter = 0

        while </span><span class="c">true</span><span class="c"> </span><span class="c">{
            let hc = [
                String(version),
                String(bits),
                date,
                challenge,
                ":\(counter)",
            ].joined(separator: ":")

            if let data = hc.data(using: .utf8) </span><span class="c">{
                let hash = Insecure.SHA1.hash(data: data)
                let hashBits = hash.map </span><span class="c">{ String($0, radix: 2).padding(toLength: 8, withPad: "0") }</span><span class="c">.joined()

                if </span><span class="c">hashBits.prefix(bits).allSatisfy(</span><span class="c">{ $0 == "0" }</span><span class="c">) </span><span class="c">{
                    return hc
                }</span><span class="c">
            }</span><span class="c">

            counter += 1
        }</span><span class="c">
    }</span><span class="">
}

extension String {
    func padding(toLength length: Int, withPad character: Character) -&gt; String </span><span class="c">{
        let paddingCount = length - self.count
        guard paddingCount &gt; 0 else </span><span class="c">{ return self }</span><span class="c">
        return String(repeating: character, count: paddingCount) + self</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f1" style="display: none"><span>//
//  AuthenticationMFA.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 22/07/2022.
//

import CLIlib
import Foundation

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

// swiftlint:disable all
/*
 {
 "trustedPhoneNumbers" : [ {
 "numberWithDialCode" : "+33 •• •• •• •• 88",
 "pushMode" : "sms",
 "obfuscatedNumber" : "•• •• •• •• 88",
 "lastTwoDigits" : "88",
 "id" : 2
 } ],
 "securityCode" : {
 "length" : 6,
 "tooManyCodesSent" : false,
 "tooManyCodesValidated" : false,
 "securityCodeLocked" : false,
 "securityCodeCooldown" : false
 },
 "authenticationType" : "hsa2",
 "recoveryUrl" : "https://iforgot.apple.com/phone/add?prs_account_nm=sebsto%40mac.com&amp;autoSubmitAccount=true&amp;appId=142",
 "cantUsePhoneNumberUrl" : "https://iforgot.apple.com/iforgot/phone/add?context=cantuse&amp;prs_account_nm=sebsto%40mac.com&amp;autoSubmitAccount=true&amp;appId=142",
 "recoveryWebUrl" : "https://iforgot.apple.com/password/verify/appleid?prs_account_nm=sebsto%40mac.com&amp;autoSubmitAccount=true&amp;appId=142",
 "repairPhoneNumberUrl" : "https://gsa.apple.com/appleid/account/manage/repair/verify/phone",
 "repairPhoneNumberWebUrl" : "https://appleid.apple.com/widget/account/repair?#!repair",
 "aboutTwoFactorAuthenticationUrl" : "https://support.apple.com/kb/HT204921",
 "twoFactorVerificationSupportUrl" : "https://support.apple.com/HT208072",
 "hasRecoveryKey" : true,
 "supportsRecoveryKey" : false,
 "autoVerified" : false,
 "showAutoVerificationUI" : false,
 "supportsCustodianRecovery" : false,
 "hideSendSMSCodeOption" : false,
 "supervisedChangePasswordFlow" : false,
 "supportsRecovery" : true,
 "trustedPhoneNumber" : {
 "numberWithDialCode" : "+33 •• •• •• •• 88",
 "pushMode" : "sms",
 "obfuscatedNumber" : "•• •• •• •• 88",
 "lastTwoDigits" : "88",
 "id" : 2
 },
 "hsa2Account" : true,
 "restrictedAccount" : false,
 "managedAccount" : false
 }
 */
// swiftlint:enable all

struct MFAType: Codable {

    struct PhoneNumber: Codable {
        let numberWithDialCode: String?
        let pushMode: String?
        let obfuscatedNumber: String?
        let lastTwoDigits: String?
        let id: Int?
    }

    struct SecurityCode: Codable {
        let length: Int?
        let tooManyCodesSent: Bool?
        let tooManyCodesValidated: Bool?
        let securityCodeLocked: Bool?
        let securityCodeCooldown: Bool?
    }

    enum AuthenticationType: String, Codable {
        case hsa
        case hsa2
    }

    let trustedPhoneNumbers: [PhoneNumber]?
    let securityCode: SecurityCode?
    let authenticationType: AuthenticationType?
    let recoveryUrl: String?
    let cantUsePhoneNumberUrl: String?
    let recoveryWebUrl: String?
    let repairPhoneNumberUrl: String?
    let repairPhoneNumberWebUrl: String?
    let aboutTwoFactorAuthenticationUrl: String?
    let twoFactorVerificationSupportUrl: String?
    let hasRecoveryKey: Bool?
    let supportsRecoveryKey: Bool?
    let autoVerified: Bool?
    let showAutoVerificationUI: Bool?
    let supportsCustodianRecovery: Bool?
    let hideSendSMSCodeOption: Bool?
    let supervisedChangePasswordFlow: Bool?
    let supportsRecovery: Bool?
    let trustedPhoneNumber: PhoneNumber?
    let hsa2Account: Bool?
    let restrictedAccount: Bool?
    let managedAccount: Bool?
}

extension AppleAuthenticator {

    // call MFAType API and return the number of digit required for PIN
    func handleTwoFactorAuthentication() async throws -&gt; Int </span><span class="c">{

        guard let data = try? await getMFAType(),
            let mfaType = try? JSONDecoder().decode(MFAType?.self, from: data)
        else </span><span class="c">{
            throw AuthenticationError.canNotReadMFATypes
        }</span><span class="c">

        // FIXME: - add support for SMS fallback in case there is no trusted device

        // I should first understand and handle case where there is a 'trustedDevices' in the answer according to
        // https://github.com/fastlane/fastlane/blob/master/spaceship/lib/spaceship/two_step_or_factor_client.rb#L18
        // when there is no 'trustedDevices', we are supposed to fallback to SMS to a phone number
        // but for my account, the API return no 'trustedDevices' but I still receive the code on my mac and iphone

        guard let count = mfaType.trustedPhoneNumbers?.count,
            count &gt; 0,
            let securityCodeLength = mfaType.securityCode?.length
        else </span><span class="c">{
            log.warning</span><span class="c">(</span><span class="c">"⚠️ No Security code length provided in answer"</span><span class="c">)
            throw AuthenticationError.requires2FATrustedPhoneNumber
        }</span><span class="c">

        return securityCodeLength</span><span class="c">

    }</span><span class="">

    func twoFactorAuthentication(pin: String) async throws </span><span class="c">{

        struct TFACode: Codable {
            let code: String
        }
        struct TFABody: Codable {
            let securityCode: TFACode
        }

        let codeType = "trusteddevice"
        let body = TFABody(securityCode: TFACode(code: pin))
        let requestHeader = ["X-Apple-Id-Session-Id": session.xAppleIdSessionId!]

        let (_, response) = try await apiCall(
            url: "https://idmsa.apple.com/appleauth/auth/verify/\(codeType)/securitycode",  // swiftlint:disable:this line_length
            method: .POST,
            body: try JSONEncoder().encode(body)</span><span class="c">,
            headers: requestHeader,
            validResponse: .range(200..&lt;413)
        )</span><span class="c">

        switch </span><span class="c">response.statusCode</span><span class="c"> {
        </span><span class="nc">case 400:
            // authentication failed
            throw AuthenticationError.invalidPinCode</span><span class="c">

        </span><span class="nc">case 412:
            // upgrade account and repair with repair token
            // see https://my.diffend.io/gems/fastlane/2.170.0/2.175.0/page/9#d2h-629314-4781
            if let location = response.value(forHTTPHeaderField: "Location") </span><span class="nc">{
                throw AuthenticationError.accountNeedsRepair(location: location, repairToken: "secret")  // X-Apple-Repair-Session-Token
            }</span><span class="nc"> else </span><span class="nc">{
                throw AuthenticationError.accountNeedsRepair(
                    location: "no location HTTP header",
                    repairToken: "secret"
                )  // X-Apple-Repair-Session-Token
            }</span><span class="c">

        </span><span class="c">case 200, 204:
            // success
            try await self.saveSession(response: response, session: session)</span><span class="c">

        </span><span class="nc">default:
            // unknown error, fail gracefully
            throw AuthenticationError.unexpectedHTTPReturnCode(code: response.statusCode)</span><span class="c">

        }</span><span class="c">

        // should we save additional cookies ?
        // return (try await getDESCookie(), session)

    }</span><span class="">

    private func getMFAType() async throws -&gt; Data? </span><span class="c">{

        let (data, _) = try await apiCall(
            url: "https://idmsa.apple.com/appleauth/auth",
            validResponse: .range(200..&lt;400)
        )</span><span class="c">

        return data</span><span class="c">

    }</span><span class="">
}

</span></pre><pre id="f2" style="display: none"><span>//
//  File.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 30/10/2024.
//

import Crypto
import Foundation
import SRP
import _CryptoExtras

extension AppleAuthenticator {
    func startSRPAuthentication(username: String, password: String) async throws </span><span class="c">{

        let hashcash = try await self.checkHashcash()</span><span class="c">

        // signification of variables : https://blog.uniauth.com/what-is-secure-remote-password

        let configuration = SRPConfiguration&lt;SHA256&gt;(.N2048)
        let client = SRPClient(configuration: configuration)
        let clientKeys = client.generateKeys()

        let A = clientKeys.public

        let (data, _) =
            try await apiCall(
                url: "https://idmsa.apple.com/appleauth/auth/signin/init",
                method: .POST,
                body: try JSONEncoder().encode(AppleSRPInitRequest(a: A.base64, accountName: username))</span><span class="c">,
                validResponse: .range(0..&lt;506)
            )</span><span class="c">

        //TODO: throw error when statusCode is not 200
        let srpResponse = try JSONDecoder().decode(AppleSRPInitResponse.self, from: data)</span><span class="c">

        let key_length = 32
        let iterations = srpResponse.iteration
        let salt = srpResponse.saltBytes()
        let B = srpResponse.b  // server public key
        let c = srpResponse.c  //what is c ?

        let serverPublicKey = SRPKey(base64: B)!  //TODO: remove !

        let derivedPassword: [UInt8] = try PBKDF2.pbkdf2(
            password: password,
            salt: salt,
            iterations: iterations,
            keyLength: key_length,
            srpProtocol: srpResponse.protocol
        )</span><span class="c">

        let sharedSecret = try client.calculateSharedSecret(
            password: derivedPassword,
            salt: salt,
            clientKeys: clientKeys,
            serverPublicKey: serverPublicKey
        )</span><span class="c">
        let clientProof = client.calculateClientProof(
            username: username,
            salt: salt,
            clientPublicKey: clientKeys.public,
            serverPublicKey: serverPublicKey,
            sharedSecret: sharedSecret
        )

        let m1 = clientProof
        let m2: [UInt8] = client.calculateServerProof(
            clientPublicKey: clientKeys.public,
            clientProof: m1,
            sharedSecret: sharedSecret
        )

        //TODO: I must verify the server proof at some point
        //try client.verifyServerProof(serverProof: ??, clientProof: m1, clientKeys: clientKeys, sharedSecret: sharedSecret)

        let (_, response) =
            try await apiCall(
                url: "https://idmsa.apple.com/appleauth/auth/signin/complete?isRememberMeEnabled=false",
                method: .POST,
                body: try JSONEncoder().encode(
                    AppleSRPCompleteRequest(accountName: username, c: c, m1: m1.base64, m2: m2.base64)
                )</span><span class="c">,
                headers: ["X-Apple-HC": hashcash],
                validResponse: .range(0..&lt;506)
            )</span><span class="c">

        // store the response to keep cookies and HTTP headers
        session.xAppleIdSessionId = response.value(forHTTPHeaderField: "X-Apple-ID-Session-Id")
        session.scnt = response.value(forHTTPHeaderField: "scnt")

        try await handleResponse(response)</span><span class="c">

    }</span><span class="">
}

/*
 {
 "protocols": [
 "s2k",
 "s2k_fo"
 ],
 "a": "5DiL4KfAjhfeVN5dkrPD0Ykc9rhOvbSUlJel9miq8fI=",
 "accountName": "xxx@me.com"
 }
 */
struct AppleSRPInitRequest: Encodable {
    let a: String
    let accountName: String
    let protocols: [String] = </span><span class="nc">["s2k", "s2k_fo"]</span><span class="">
}

/*
 {
 "iteration" : 1160,
 "salt" : "iVGSz0+eXAe5jzBsuSH9Gg==",
 "protocol" : "s2k_fo",
 "b" : "feF9PcfeU6pKeZb27kxM080eOPvg0wZurW6sGglwhIi63VPyQE1FfU1NKdU5bRHpGYcz23AKetaZWX6EqlIUYsmguN7peY9OU74+V16kvPaMFtSvS4LUrl8W+unt2BTlwRoINTYVgoIiLwXFKAowH6dA9HGaOy8TffKw/FskGK1rPqf8TZJ3IKWk6LA8AAvNhQhaH2/rdtdysJpV+T7eLpoMlcILWCOVL1mzAeTr3lMO4UdcnPokjWIoHIEJXDF8XekRbqSeCZvMlZBP1qSeRFwPuxz//doEk0AS2wU2sZFinPmfz4OV2ESQ4j9lfxE+NvapT+fPAmEUysUL61piMw==",
 "c" : "d-74e-7f288e09-93e6-11ef-9a9c-278293010698:PRN"
 }
 */
struct AppleSRPInitResponse: Decodable {
    let iteration: Int
    let salt: String
    let `protocol`: SRPProtocol
    let b: String
    let c: String
    func saltBytes() -&gt; [UInt8] </span><span class="c">{ Array(Data(base64Encoded: salt)!) }</span><span class="">
    func bBytes() -&gt; Data? </span><span class="nc">{ Data(base64Encoded: b) }</span><span class="">
}

public enum SRPProtocol: String, Sendable, Codable {
    case s2k, s2k_fo
}

struct AppleSRPCompleteRequest: Encodable {
    let accountName: String
    let c: String
    let m1: String
    let m2: String
    let rememberMe: Bool = </span><span class="nc">false</span><span class="">
}

extension SRPKey {
    public var base64: String </span><span class="c">{
        Data(self.bytes).base64EncodedString()
    }</span><span class="">
    public init?(base64: String) </span><span class="c">{
        guard let data = Data(base64Encoded: base64) else </span><span class="nc">{ return nil }</span><span class="c">
        self.init(Array(data))
    }</span><span class="">
}

extension Array where Element == UInt8 {
    public var base64: String </span><span class="c">{
        Data(self).base64EncodedString()
    }</span><span class="">
}
extension String {
    public var array: [UInt8] </span><span class="c">{
        Array(self.utf8)
    }</span><span class="">
}

struct PBKDF2 {
    static func pbkdf2(
        password: String,
        salt: [UInt8],
        iterations: Int,
        keyLength: Int,
        srpProtocol: SRPProtocol
    ) throws -&gt; [UInt8] </span><span class="c">{
        if let pwdData = password.data(using: .utf8) </span><span class="c">{
            return try pbkdf2(
                password: [UInt8](pwdData),
                salt: salt,
                iterations: iterations,
                keyLength: keyLength,
                srpProtocol: srpProtocol
            )
        }</span><span class="c"> else </span><span class="nc">{
            fatalError()
        }</span><span class="nc">
    }</span><span class="">
    static func pbkdf2(
        password: [UInt8],
        salt: [UInt8],
        iterations: Int,
        keyLength: Int,
        srpProtocol: SRPProtocol
    ) throws -&gt; [UInt8] </span><span class="c">{

        // when server asks s2k protocol, use a SHA256 hash of the password
        // when server asks s2k_fo protocol, we must use a Hex encoded string of the hash of the password
        let passwordHash: Data
        switch </span><span class="c">srpProtocol</span><span class="c"> {
        </span><span class="c">case .s2k:
            passwordHash = Data(SHA256.hash(data: Data(password)))</span><span class="c">
        </span><span class="c">case .s2k_fo:
            passwordHash = Data(
                Data(SHA256.hash(data: Data(password)))
                    .hexDigest()
                    .lowercased().utf8
            )</span><span class="c">
        }</span><span class="c">

        var result: [UInt8] = []
        try KDF.Insecure.PBKDF2.deriveKey(
            from: passwordHash,
            salt: salt,
            using: .sha256,
            outputByteCount: keyLength,
            // Swift-Crypto recommends 210000 or more rounds.  Apple's SRP uses less
            unsafeUncheckedRounds: iterations
        )</span><span class="c">.withUnsafeBytes </span><span class="c">{
            result.append(contentsOf: $0)
        }</span><span class="c">
        return result
    }</span><span class="">

}

</span></pre><pre id="f3" style="display: none"><span>//
//  File.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 30/10/2024.
//

import Foundation

extension AppleAuthenticator {
    func startUserPasswordAuthentication(username: String, password: String) async throws </span><span class="c">{

        let _ = try await self.checkHashcash()</span><span class="c">

        let (_, response) =
            try await apiCall(
                url: "https://idmsa.apple.com/appleauth/auth/signin",
                method: .POST,
                body: try JSONEncoder().encode(User(accountName: username, password: password))</span><span class="c">,
                validResponse: .range(0..&lt;506)
            )</span><span class="c">

        // store the response to keep cookies and HTTP headers
        session.xAppleIdSessionId = response.value(forHTTPHeaderField: "X-Apple-ID-Session-Id")
        session.scnt = response.value(forHTTPHeaderField: "scnt")

        // should I save other headers ?
        // X-Apple-Auth-Attributes

        try await handleResponse(response)</span><span class="c">

    }</span><span class="">
}

</span></pre><pre id="f4" style="display: none"><span>//
//  Authentication.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 18/07/2022.
//

import CLIlib
import Foundation

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

// MARK: - Module Internal structures and data

enum AuthenticationMethod {
    case usernamePassword
    case srp

    static func withSRP(_ srp: Bool) -&gt; AuthenticationMethod </span><span class="nc">{ srp ? </span><span class="nc">.srp</span><span class="nc"> : </span><span class="nc">.usernamePassword</span><span class="nc"> }</span><span class="">
}

struct User: Codable {
    var accountName: String
    var password: String
    var rememberMe = </span><span class="c">false</span><span class="">
}

enum AuthenticationError: Error, Equatable {

    case invalidUsernamePassword
    case requires2FA
    //    case requires2FATrustedDevice
    case requires2FATrustedPhoneNumber
    case invalidPinCode
    case unableToRetrieveAppleServiceKey(Error?)
    case unableToRetrieveAppleHashcash(Error?)
    case missingHTTPHeaders(String)
    case canNotReadMFATypes
    case accountNeedsRepair(location: String, repairToken: String)
    case serviceUnavailable  //503
    case notImplemented(featureName: String)  // temporray while I'm working on a feature
    case unexpectedHTTPReturnCode(code: Int)
    case other(error: Error)

    static func == (lhs: AuthenticationError, rhs: AuthenticationError) -&gt; Bool </span><span class="c">{
        switch </span><span class="c">(lhs, rhs)</span><span class="c"> {
        </span><span class="c">case (.invalidUsernamePassword, .invalidUsernamePassword):
            return true</span><span class="c">
        </span><span class="nc">case (.requires2FA, .requires2FA):
            return true</span><span class="c">
        </span><span class="c">case (.requires2FATrustedPhoneNumber, .requires2FATrustedPhoneNumber):
            return true</span><span class="c">
        </span><span class="nc">case (.invalidPinCode, .invalidPinCode):
            return true</span><span class="c">
        </span><span class="c">case (.unableToRetrieveAppleServiceKey, .unableToRetrieveAppleServiceKey):
            return true</span><span class="c">  // Can't compare errors, so just check the case
        </span><span class="nc">case (.unableToRetrieveAppleHashcash, .unableToRetrieveAppleHashcash):
            return true</span><span class="c">  // Can't compare errors, so just check the case
        </span><span class="nc">case let (.missingHTTPHeaders(a), .missingHTTPHeaders(b)):
            return a == b</span><span class="c">
        </span><span class="c">case (.canNotReadMFATypes, .canNotReadMFATypes):
            return true</span><span class="c">
        </span><span class="nc">case let (.accountNeedsRepair(locationA, repairTokenA), .accountNeedsRepair(locationB, repairTokenB)):
            return locationA == locationB &amp;&amp; </span><span class="nc">repairTokenA == repairTokenB</span><span class="c">
        </span><span class="nc">case (.serviceUnavailable, .serviceUnavailable):
            return true</span><span class="c">
        </span><span class="nc">case let (.notImplemented(featureNameA), .notImplemented(featureNameB)):
            return featureNameA == featureNameB</span><span class="c">
        </span><span class="c">case let (.unexpectedHTTPReturnCode(codeA), .unexpectedHTTPReturnCode(codeB)):
            return codeA == codeB</span><span class="c">
        </span><span class="nc">case (.other, .other):
            return true</span><span class="c">  // Can't compare errors, so just check the case
        </span><span class="nc">default:
            return false</span><span class="c">
        }
    }</span><span class="">
}

struct AppleServiceKey: Codable, Equatable {
    let authServiceUrl: String
    let authServiceKey: String

    static func == (lhs: AppleServiceKey, rhs: AppleServiceKey) -&gt; Bool </span><span class="c">{
        lhs.authServiceKey == rhs.authServiceKey &amp;&amp; </span><span class="c">lhs.authServiceUrl == rhs.authServiceUrl</span><span class="c">
    }</span><span class="">
}

struct AppleSession: Codable, Equatable {
    var itcServiceKey: AppleServiceKey?
    var xAppleIdSessionId: String? = </span><span class="c">nil</span><span class="">
    var scnt: String? = </span><span class="c">nil</span><span class="">
    var hashcash: String? = </span><span class="c">nil</span><span class="">

    static func == (lhs: AppleSession, rhs: AppleSession) -&gt; Bool </span><span class="c">{
        lhs.itcServiceKey == rhs.itcServiceKey &amp;&amp; </span><span class="c">lhs.xAppleIdSessionId == rhs.xAppleIdSessionId</span><span class="c">
            &amp;&amp; </span><span class="c">lhs.scnt == rhs.scnt</span><span class="c"> &amp;&amp; </span><span class="c">lhs.hashcash == rhs.hashcash</span><span class="c">
    }</span><span class="">

    func data() throws -&gt; Data </span><span class="c">{
        try JSONEncoder().encode(self)</span><span class="c">
    }</span><span class="">

    func string() throws -&gt; String? </span><span class="nc">{
        String(data: try self.data()</span><span class="nc">, encoding: .utf8)
    }</span><span class="">

    init(fromData data: Data) throws </span><span class="c">{
        self = try JSONDecoder().decode(AppleSession.self, from: data)</span><span class="c">
    }</span><span class="">

    init(
        itcServiceKey: AppleServiceKey? = nil,
        xAppleIdSessionId: String? = nil,
        scnt: String? = nil,
        hashcash: String? = nil
    ) </span><span class="c">{
        self.itcServiceKey = itcServiceKey
        self.xAppleIdSessionId = xAppleIdSessionId
        self.scnt = scnt
        self.hashcash = hashcash
    }</span><span class="">
}

/**
 Manage authentication with an Apple ID
 */

protocol AppleAuthenticatorProtocol: Sendable {

    // standard authentication methods
    func startAuthentication(
        with: AuthenticationMethod,
        username: String,
        password: String
    )
        async throws
    func signout() async throws

    // multi-factor authentication
    func handleTwoFactorAuthentication() async throws -&gt; Int
    func twoFactorAuthentication(pin: String) async throws
}

//FIXME: TODO: split into two classes : UsernamePasswordAuthenticator and SRPAuthenticator
@MainActor
class AppleAuthenticator: HTTPClient, AppleAuthenticatorProtocol {

    func startAuthentication(
        with authenticationMethod: AuthenticationMethod,
        username: String,
        password: String
    ) async throws </span><span class="c">{
        try await checkServiceKey()</span><span class="c">

        switch </span><span class="c">authenticationMethod</span><span class="c"> {
        </span><span class="c">case .usernamePassword:
            try await self.startUserPasswordAuthentication(username: username, password: password)</span><span class="c">
        </span><span class="c">case .srp:
            try await self.startSRPAuthentication(username: username, password: password)</span><span class="c">
        }</span><span class="c">
    }</span><span class="">

    // this is mainly for functional testing, it invalidates the session and force a full re-auth aftewards
    func signout() async throws </span><span class="c">{

        let (_, _) = try await apiCall(
            url: "https://idmsa.apple.com/appleauth/signout",
            validResponse: .range(0..&lt;500)
        )</span><span class="c">

        try await self.env().secrets!.clearSecrets()</span><span class="c">

    }</span><span class="">

    // MARK: - Private structures and data

    func checkServiceKey() async throws </span><span class="c">{
        if </span><span class="c">session.itcServiceKey == nil</span><span class="c"> </span><span class="c">{
            var appServiceKey: AppleServiceKey
            do </span><span class="c">{
                appServiceKey = try await getAppleServicekey()</span><span class="nc">
            }</span><span class="c"> catch </span><span class="c">{
                throw AuthenticationError.unableToRetrieveAppleServiceKey(error)
            }</span><span class="nc">
            session.itcServiceKey = appServiceKey
            log.debug</span><span class="nc">(</span><span class="nc">"Got an Apple Service key : \(String(describing: session.itcServiceKey))"</span><span class="nc">)
        }</span><span class="c">
    }</span><span class="">

    // by OOP design it should be private.
    internal func getAppleServicekey() async throws -&gt; AppleServiceKey </span><span class="c">{

        /*
         ➜  ~ curl https://appstoreconnect.apple.com/olympus/v1/app/config\?hostname\=itunesconnect.apple.com
         {
         "authServiceUrl" : "https://idmsa.apple.com/appleauth",
         "authServiceKey" : "e0b80c3bf78523bfe80974d320935bfa30add02e1bff88ec2166c6bd5a706c42"
         }
         */

        let url =
            "https://appstoreconnect.apple.com/olympus/v1/app/config?hostname=itunesconnect.apple.com"
        let (data, _) = try await apiCall(
            url: url,
            validResponse: .range(200..&lt;400)  //FIXME: should this be .value(200) ?
        )</span><span class="c">

        return try JSONDecoder().decode(AppleServiceKey.self, from: data)</span><span class="c">
    }</span><span class="">

    func handleResponse(_ response: HTTPURLResponse) async throws </span><span class="c">{
        switch </span><span class="c">response.statusCode</span><span class="c"> {

        </span><span class="c">case 200:
            // we were already authenticated
            try await self.saveSession(response: response, session: session)</span><span class="c">

        </span><span class="c">case 401, 403:
            // invalid username or password
            throw AuthenticationError.invalidUsernamePassword</span><span class="c">

        </span><span class="nc">case 409:
            // requires two-factors authentication
            throw AuthenticationError.requires2FA</span><span class="c">

        </span><span class="nc">case 503:
            // service unavailable. Most probably teh requested Authentication method is not supported
            throw AuthenticationError.serviceUnavailable</span><span class="c">

        </span><span class="c">default:
            log.critical</span><span class="c">(</span><span class="c">"💣 Unexpected return code : \(response.statusCode)"</span><span class="c">)
            log.debug</span><span class="nc">(</span><span class="nc">"URLResponse = \(response)"</span><span class="c">)
            throw AuthenticationError.unexpectedHTTPReturnCode(code: response.statusCode)</span><span class="c">
        }</span><span class="c">
    }</span><span class="">

    func saveSession(response: HTTPURLResponse, session: AppleSession) async throws </span><span class="c">{
        guard let cookies = response.value(forHTTPHeaderField: "Set-Cookie") else </span><span class="c">{
            log.debug</span><span class="nc">(</span><span class="nc">"No cookies set, just saving the session"</span><span class="c">)
            _ = try await self.env().secrets!.saveSession(session)</span><span class="c">
            return</span><span class="c">
        }</span><span class="c">

        // save session data to reuse in future invocation
        _ = try await self.env().secrets!.saveCookies(cookies)</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f5" style="display: none"><span>//
//  List.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 19/07/2022.
//

import CLIlib
import Foundation

protocol AppleDownloaderProtocol: Sendable {
    func list(force: Bool) async throws -&gt; DownloadList
    func download(file: DownloadList.File) async throws -&gt; AsyncStream&lt;DownloadProgress&gt;
}

@MainActor
class AppleDownloader: HTTPClient, AppleDownloaderProtocol {

    func download(file: DownloadList.File) async throws -&gt; AsyncStream&lt;DownloadProgress&gt; </span><span class="nc">{

        guard !file.remotePath.isEmpty,
            !file.filename.isEmpty,
            file.fileSize &gt; 0
        else </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"🛑 Invalid file specification : \(file)"</span><span class="nc">)
            throw DownloadError.invalidFileSpec
        }</span><span class="nc">

        let fileURL = "https://developer.apple.com/services-account/download?path=\(file.remotePath)"

        let fh = self.env().fileHandler
        let filePath = await URL(fileURLWithPath: fh.downloadFilePath(file: file))
        let downloadTarget = DownloadTarget(totalFileSize: file.fileSize, dstFilePath: filePath, startTime: Date.now)

        let downloadManager = self.env().downloadManager
        downloadManager.downloadTarget = downloadTarget
        downloadManager.env = self.env()

        return try await downloadManager.download(from: fileURL)</span><span class="nc">
    }</span><span class="">

}

</span></pre><pre id="f6" style="display: none"><span>//
//  DownloadData.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 21/08/2022.
//

import Foundation

enum DownloadError: Error, Equatable {
    case authenticationRequired
    case unknownError(errorCode: Int, errorMessage: String)
    case parsingError(error: Error?)
    case noDownloadsInDownloadList
    case invalidFileSpec
    case invalidResponse
    case zeroOrMoreThanOneFileToDownload(count: Int)
    case unknownFile(file: String)
    case needToAcceptTermsAndCondition
    case accountneedUpgrade(errorCode: Int, errorMessage: String)

    static func == (lhs: DownloadError, rhs: DownloadError) -&gt; Bool </span><span class="c">{
        switch </span><span class="c">(lhs, rhs)</span><span class="c"> {
        </span><span class="c">case (.authenticationRequired, .authenticationRequired):
            return true</span><span class="c">
        </span><span class="c">case let (.unknownError(code1, _), .unknownError(code2, _)):
            return code1 == code2</span><span class="c">
        </span><span class="c">case let (.parsingError(error1), .parsingError(error2)):
            if </span><span class="c">error1 == nil || </span><span class="nc">error2 == nil</span><span class="c"> </span><span class="c">{
                return true
            }</span><span class="c"> else </span><span class="nc">{
                // Compare error descriptions since Error is not Equatable
                return String(describing: error1) == String(describing: error2)
            }</span><span class="c">
        </span><span class="nc">case (.noDownloadsInDownloadList, .noDownloadsInDownloadList):
            return true</span><span class="c">
        </span><span class="nc">case (.invalidFileSpec, .invalidFileSpec):
            return true</span><span class="c">
        </span><span class="c">case (.invalidResponse, .invalidResponse):
            return true</span><span class="c">
        </span><span class="nc">case let (.zeroOrMoreThanOneFileToDownload(count1), .zeroOrMoreThanOneFileToDownload(count2)):
            return count1 == count2</span><span class="c">
        </span><span class="nc">case let (.unknownFile(file1), .unknownFile(file2)):
            return file1 == file2</span><span class="c">
        </span><span class="nc">case (.needToAcceptTermsAndCondition, .needToAcceptTermsAndCondition):
            return true</span><span class="c">
        </span><span class="c">case let (.accountneedUpgrade(code1, _), .accountneedUpgrade(code2, _)):
            return code1 == code2</span><span class="c">
        </span><span class="nc">default:
            return false</span><span class="c">
        }
    }</span><span class="">
}

struct DownloadList: Sendable, Codable {

    struct DownloadCategory: Sendable, Codable {
        let id: Int
        let name: String
        let sortOrder: Int
    }

    struct FileFormat: Sendable, Codable {
        let fileExtension: String
        let description: String

        // real JSON name for fileExtension is extension
        // but this is a Swift reserved keyword
        // this allows to map internal name with JSON name

        enum CodingKeys: String, Sendable, CodingKey {  // swiftlint:disable:this nesting
            case fileExtension = "extension"
            case description
        }
    }

    struct File: Sendable, Codable {
        let filename: String
        let displayName: String?
        let remotePath: String
        let fileSize: Int
        let sortOrder: Int
        let dateCreated: String
        let dateModified: String
        let fileFormat: FileFormat
        let existInCache: Bool

        init(
            filename: String,
            displayName: String?,
            remotePath: String,
            fileSize: Int,
            sortOrder: Int,
            dateCreated: String,
            dateModified: String,
            fileFormat: FileFormat,
            existInCache: Bool = false
        ) </span><span class="c">{
            self.filename = filename
            self.displayName = displayName
            self.remotePath = remotePath
            self.fileSize = fileSize
            self.sortOrder = sortOrder
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.fileFormat = fileFormat
            self.existInCache = existInCache
        }</span><span class="">

        init(from: File, existInCache: Bool) </span><span class="c">{
            self.filename = from.filename
            self.displayName = from.displayName
            self.remotePath = from.remotePath
            self.fileSize = from.fileSize
            self.sortOrder = from.sortOrder
            self.dateCreated = from.dateCreated
            self.dateModified = from.dateModified
            self.fileFormat = from.fileFormat
            self.existInCache = existInCache
        }</span><span class="">
        // add coding keys to bypass decoding of existIncache
        init(from decoder: Decoder) throws </span><span class="c">{
            let values = try decoder.container(keyedBy: CodingKeys.self)</span><span class="c">
            filename = try values.decode(String.self, forKey: .filename)</span><span class="c">
            displayName = try values.decodeIfPresent(String.self, forKey: .displayName)</span><span class="c">
            remotePath = try values.decode(String.self, forKey: .remotePath)</span><span class="c">
            fileSize = try values.decode(Int.self, forKey: .fileSize)</span><span class="c">
            sortOrder = try values.decode(Int.self, forKey: .sortOrder)</span><span class="c">
            dateCreated = try values.decode(String.self, forKey: .dateCreated)</span><span class="c">
            dateModified = try values.decode(String.self, forKey: .dateModified)</span><span class="c">
            fileFormat = try values.decode(FileFormat.self, forKey: .fileFormat)</span><span class="c">
            existInCache = false
        }</span><span class="">
        enum CodingKeys: String, Sendable, CodingKey {  // swiftlint:disable:this nesting
            case filename
            case displayName
            case remotePath
            case fileSize
            case sortOrder
            case dateCreated
            case dateModified
            case fileFormat
        }
    }

    struct Download: Sendable, Codable {
        let id: String
        let name: String
        let description: String
        let isReleased: Int
        let datePublished: String?
        let dateCreated: String
        let dateModified: String
        let categories: [DownloadCategory]
        let files: [File]
        let isRelatedSeed: Bool
        init(
            id: String,
            name: String,
            description: String,
            isReleased: Int,
            datePublished: String?,
            dateCreated: String,
            dateModified: String,
            categories: [DownloadCategory],
            files: [File],
            isRelatedSeed: Bool
        ) </span><span class="c">{
            self.id = id
            self.name = name
            self.description = description
            self.isReleased = isReleased
            self.datePublished = datePublished
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.categories = categories
            self.files = files
            self.isRelatedSeed = isRelatedSeed
        }</span><span class="">
        init(from: Download, replaceWith newFile: File) </span><span class="c">{
            self.id = from.id
            self.name = from.name
            self.description = from.description
            self.isReleased = from.isReleased
            self.datePublished = from.datePublished
            self.dateCreated = from.dateCreated
            self.dateModified = from.dateModified
            self.categories = from.categories
            // replace the file list with the new file
            self.files = from.files.map </span><span class="c">{ $0.filename == newFile.filename ? </span><span class="c">newFile</span><span class="c"> : </span><span class="c">$0</span><span class="c"> }</span><span class="c">
            self.isRelatedSeed = from.isRelatedSeed
        }</span><span class="">
        init(from: Download, appendFile newFile: File) </span><span class="c">{
            self.id = from.id
            self.name = from.name
            self.description = from.description
            self.isReleased = from.isReleased
            self.datePublished = from.datePublished
            self.dateCreated = from.dateCreated
            self.dateModified = from.dateModified
            self.categories = from.categories
            // append the file to the list
            self.files = from.files + [newFile]
            self.isRelatedSeed = from.isRelatedSeed
        }</span><span class="">

    }

    let creationTimestamp: String
    let resultCode: Int
    let resultString: String?
    let userString: String?
    let userLocale: String
    let protocolVersion: String
    let requestUrl: String
    let responseId: String
    let httpCode: Int?
    let httpResponseHeaders: [String: String]?
    let downloadHost: String?
    let downloads: [Download]?

}

</span></pre><pre id="f7" style="display: none"><span>import Foundation
import Logging

protocol DownloadManagerProtocol: Sendable {
    func download(from url: URL) -&gt; AsyncStream&lt;DownloadProgress&gt;
}

struct DownloadTarget: Sendable {
    let totalFileSize: Int
    let dstFilePath: URL
    let startTime: Date

    init(totalFileSize: Int, dstFilePath: URL, startTime: Date = Date.now) </span><span class="c">{
        self.totalFileSize = totalFileSize
        self.dstFilePath = dstFilePath
        self.startTime = startTime
    }</span><span class="">
}

struct DownloadProgress: Sendable {
    let bytesWritten: Int64
    let totalBytes: Int64
    let startTime: Date
    var percentage: Double </span><span class="c">{ Double(bytesWritten) / Double(totalBytes) }</span><span class="">
    var bandwidth: Double </span><span class="nc">{
        let elapsed = 0 - startTime.timeIntervalSinceNow
        return elapsed &gt; 0 ? </span><span class="nc">Double(bytesWritten) / Double(elapsed) / 1024 / 1024</span><span class="nc"> : </span><span class="nc">0</span><span class="nc">
    }</span><span class="">
}

@MainActor
class DownloadManager {

    var env: Environment? = </span><span class="c">nil</span><span class="">
    var downloadTarget: DownloadTarget? = </span><span class="c">nil</span><span class="">
    private let log: Logger

    public init(env: Environment? = nil, downloadTarget: DownloadTarget? = nil, logger: Logger) </span><span class="c">{
        self.env = env
        self.downloadTarget = downloadTarget
        self.log = logger
    }</span><span class="">

    func download(from url: String) async throws -&gt; AsyncStream&lt;DownloadProgress&gt; </span><span class="nc">{

        guard let downloadTarget = self.downloadTarget else </span><span class="nc">{
            fatalError(</span><span class="nc">"Developer forgot to set the download target"</span><span class="nc">)
        }</span><span class="nc">

        guard let env = self.env else </span><span class="nc">{
            fatalError(</span><span class="nc">"Developer forgot to set the environment"</span><span class="nc">)
        }</span><span class="nc">

        var request: URLRequest
        var headers: [String: String] = ["Accept": "*/*"]

        // reload cookies if they exist
        let cookies = try? await env.secrets!.loadCookies()
        if let cookies </span><span class="nc">{
            // cookies existed, let's add them to our HTTPHeaders
            headers.merge(HTTPCookie.requestHeaderFields(with: cookies)) </span><span class="nc">{ (current, _) in current }</span><span class="nc">
        } else </span><span class="nc">{
            log.debug</span><span class="nc">(</span><span class="nc">"⚠️ I could not load cookies"</span><span class="nc">)
            throw DownloadError.authenticationRequired
        }</span><span class="nc">

        // build the request
        request = self.request(for: url, withHeaders: headers)
        _log(request: request, to: log)

        // create the download task, start it , and start streaming its progress
        return AsyncStream </span><span class="nc">{ continuation in
            let delegate = DownloadDelegate(
                target: downloadTarget,
                continuation: continuation,
                fileHandler: env.fileHandler,
                log: self.log
            )
            let session = URLSession(configuration: .default, delegate: delegate, delegateQueue: nil)
            let task = session.downloadTask(with: request)
            task.resume()
        }</span><span class="nc">
    }</span><span class="">

    // prepare an URLRequest for a given url, method, body, and headers
    // https://softwareengineering.stackexchange.com/questions/100959/how-do-you-unit-test-private-methods
    internal func request(
        for url: String,
        method: HTTPVerb = .GET,
        withBody body: Data? = nil,
        withHeaders headers: [String: String]? = nil
    ) -&gt; URLRequest </span><span class="c">{

        // create the request
        let url = URL(string: url)!
        var request = URLRequest(url: url)

        // add HTTP verb
        request.httpMethod = method.rawValue

        // add body
        if let body </span><span class="nc">{
            request.httpBody = body
        }</span><span class="c">

        // add headers
        if let headers </span><span class="c">{
            for (key, value) in headers </span><span class="c">{
                request.addValue(value, forHTTPHeaderField: key)
            }</span><span class="c">
        }</span><span class="c">

        return request
    }</span><span class="">
}

// MARK: Download Delegate functions
final class DownloadDelegate: NSObject, URLSessionDownloadDelegate {

    private let downloadTarget: DownloadTarget
    private let continuation: AsyncStream&lt;DownloadProgress&gt;.Continuation
    private let log: Logger
    private let fileHandler: FileHandlerProtocol
    init(
        target: DownloadTarget,
        continuation: AsyncStream&lt;DownloadProgress&gt;.Continuation,
        fileHandler: FileHandlerProtocol,
        log: Logger
    ) </span><span class="nc">{
        self.downloadTarget = target
        self.continuation = continuation
        self.log = log
        self.fileHandler = fileHandler
    }</span><span class="">
    // URLSessionDownloadDelegate methods
    func urlSession(
        _ session: URLSession,
        downloadTask: URLSessionDownloadTask,
        didWriteData bytesWritten: Int64,
        totalBytesWritten: Int64,
        totalBytesExpectedToWrite: Int64
    ) </span><span class="nc">{
        let total =
            totalBytesExpectedToWrite &lt;= 0 ? </span><span class="nc">Int64(self.downloadTarget.totalFileSize)</span><span class="nc"> : </span><span class="nc">totalBytesExpectedToWrite</span><span class="nc">
        let progress = DownloadProgress(
            bytesWritten: totalBytesWritten,
            totalBytes: total,
            startTime: self.downloadTarget.startTime
        )
        continuation.yield(progress)
    }</span><span class="">

    func urlSession(
        _ session: URLSession,
        downloadTask: URLSessionDownloadTask,
        didFinishDownloadingTo location: URL
    ) </span><span class="nc">{
        do </span><span class="nc">{
            let dst = self.downloadTarget.dstFilePath
            log.debug</span><span class="nc">(</span><span class="nc">"Finished downloading at \(location)\nMoving to \(dst)"</span><span class="nc">)

            try self.fileHandler.move(from: location, to: dst)</span><span class="nc">

        }</span><span class="nc"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"🛑 Error moving downloaded file: \(error)"</span><span class="nc">)
        }</span><span class="nc">
        continuation.finish()

    }</span><span class="">

    func urlSession(
        _ session: URLSession,
        task: URLSessionTask,
        willPerformHTTPRedirection response: HTTPURLResponse,
        newRequest request: URLRequest
    ) async -&gt; URLRequest? </span><span class="nc">{
        request
    }</span><span class="">

    func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) </span><span class="nc">{
        // how to report error to user ?
        log.error</span><span class="nc">(</span><span class="nc">"error \(String(describing: error))"</span><span class="nc">)
        continuation.finish()
    }</span><span class="">
}

</span></pre><pre id="f8" style="display: none"><span>//
//  HTTPClient.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 21/07/2022.
//

import CLIlib
import Foundation
import Logging

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

/*
    This file contains code to make our APICall testable.

    Inspired from https://masilotti.com/testing-nsurlsession-input/
 */

// make URLSession testable by abstracting its protocol
// it allows to use the real URLSession or a mock interchangably
// @MainActor
protocol URLSessionProtocol: Sendable {
    func data(
        for request: URLRequest,
        delegate: URLSessionTaskDelegate?
    ) async throws -&gt; (
        Data, URLResponse
    )
}

// make the real URLSession implements our new protocol to make the compiler happy
extension URLSession: URLSessionProtocol {}

// callers can express expected HTTP Response code either as range, either as specific value
enum ExpectedResponseCode {
    case range(Range&lt;Int&gt;)
    case value(Int)

    func isValid(response: Int) -&gt; Bool </span><span class="c">{
        switch </span><span class="c">self</span><span class="c"> {
        </span><span class="c">case .range(let range):
            return range.contains(response)</span><span class="c">
        </span><span class="c">case .value(let value):
            return value == response</span><span class="c">
        }
    }</span><span class="">
}

enum HTTPVerb: String {
    case GET
    case POST
}

// provide common code for all network clients
@MainActor
class HTTPClient {

    var environment: Environment? = </span><span class="c">nil</span><span class="">
    let log: Logger

    public init(log: Logger) </span><span class="c">{
        self.log = log
    }</span><span class="">

    public func env() -&gt; Environment </span><span class="c">{
        guard let env = self.environment else </span><span class="nc">{
            fatalError(</span><span class="nc">"Environment not set"</span><span class="nc">)
        }</span><span class="c">
        return env</span><span class="c">
    }</span><span class="">

    // some ID returned by Apple API to authenticate us
    var session = </span><span class="c">AppleSession()</span><span class="">

    // to be shared between apiCall and download methods
    // prepare headers with correct cookies and X- value for Apple authentication
    func prepareAuthenticationHeaders() async -&gt; [String: String] </span><span class="c">{

        var requestHeaders: [String: String] = [
            "Content-Type": "application/json",
            "Accept": "application/json, text/javascript",
            "X-Requested-With": "XMLHttpRequest",
            "User-Agent": "curl/7.79.1",
        ]

        // reload previous session if it exists
        let session = try? await self.env().secrets!.loadSession()
        if let session </span><span class="nc">{

            // session is loaded
            log.debug(</span><span class="nc">"Session data loaded"</span><span class="nc">, metadata: </span><span class="nc">["data": "\(session)"]</span><span class="nc">)
            self.session = session

        }</span><span class="c"> else </span><span class="c">{
            log.debug</span><span class="nc">(</span><span class="nc">"⚠️ I could not load session (this is normal the first time you authenticate)"</span><span class="c">)
        }

        // populate HTTP request with headers from session (either from self or the one just loaded)
        if let isk = self.session.itcServiceKey </span><span class="c">{
            requestHeaders["X-Apple-Widget-Key"] = isk.authServiceKey
        }</span><span class="c">
        if let aisi = self.session.xAppleIdSessionId </span><span class="c">{
            requestHeaders["X-Apple-ID-Session-Id"] = aisi
        }</span><span class="c">
        if let scnt = self.session.scnt </span><span class="c">{
            requestHeaders["scnt"] = scnt
        }</span><span class="c">

        // reload cookies if they exist
        let cookies = try? await self.env().secrets!.loadCookies()
        if let cookies </span><span class="c">{
            // cookies existed, let's add them to our HTTPHeaders
            requestHeaders.merge(HTTPCookie.requestHeaderFields(with: cookies)) </span><span class="nc">{ (current, _) in current
            }</span><span class="c">
        } else </span><span class="nc">{
            // swiftlint:disable line_length
            log.debug</span><span class="nc">(</span><span class="nc">"⚠️ I could not load cookies (this is normal the first time you authenticate)"</span><span class="nc">)
        }</span><span class="c">

        return requestHeaders
    }</span><span class="">

    // generic API CALL method
    // this is used by authentication API calls
    func apiCall(
        url: String,
        method: HTTPVerb = .GET,
        body: Data? = nil,
        headers: [String: String] = [:],
        validResponse: ExpectedResponseCode = .value(0)
    ) async throws -&gt; (Data, HTTPURLResponse) </span><span class="c">{

        let request: URLRequest

        // let's add provided headers to our request (keeping new value in case of conflicts)
        var requestHeaders = await prepareAuthenticationHeaders()

        // add the headers our callers want in this request
        requestHeaders.merge(headers, uniquingKeysWith: </span><span class="nc">{ (_, new) in new }</span><span class="c">)

        // and build the request
        request = self.request(
            for: url,
            method: method,
            withBody: body,
            withHeaders: requestHeaders
        )

        _log(request: request, to: log)

        // send request with that session
        let (data, response) = try await self.env().urlSessionData.data(for: request, delegate: nil)</span><span class="c">
        guard let httpResponse = response as? HTTPURLResponse,
            validResponse.isValid(response: httpResponse.statusCode)
        else </span><span class="c">{
            log.error</span><span class="c">(</span><span class="c">
                </span><span class="c">"=== HTTP ERROR. Status code \((response as? HTTPURLResponse)!.statusCode) not in range \(validResponse) ==="</span><span class="c">
            )
            log.debug</span><span class="nc">(</span><span class="nc">"URLResponse : \(response)"</span><span class="c">)
            throw URLError(.badServerResponse)
        }</span><span class="c">

        _log(response: httpResponse, data: data, error: nil, to: log)

        return (data, httpResponse)</span><span class="c">
    }</span><span class="">

    // prepare an URLRequest for a given url, method, body, and headers
    // https://softwareengineering.stackexchange.com/questions/100959/how-do-you-unit-test-private-methods
    internal func request(
        for url: String,
        method: HTTPVerb = .GET,
        withBody body: Data? = nil,
        withHeaders headers: [String: String]? = nil
    ) -&gt; URLRequest </span><span class="c">{

        // create the request
        let url = URL(string: url)!
        var request = URLRequest(url: url)

        // add HTTP verb
        request.httpMethod = method.rawValue

        // add body
        if let body </span><span class="c">{
            request.httpBody = body
        }</span><span class="c">

        // add headers
        if let headers </span><span class="c">{
            for (key, value) in headers </span><span class="c">{
                request.addValue(value, forHTTPHeaderField: key)
            }</span><span class="c">
        }</span><span class="c">

        return request
    }</span><span class="">
}

</span></pre><pre id="f9" style="display: none"><span>//
//  Install.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 22/08/2022.
//

import CLIlib
import Foundation
import Logging

protocol InstallerProtocol {
    func install(file: URL) async throws
    func installCommandLineTools(atPath file: URL) async throws
    func installPkg(atURL pkg: URL) async throws -&gt; ShellOutput
    func installXcode(at src: URL) async throws
    func uncompressXIP(atURL file: URL) async throws
    func moveApp(at src: URL) async throws -&gt; String
    func fileMatch(file: URL) async -&gt; Bool
}

enum InstallerError: Error {
    case unsupportedInstallation
    case fileDoesNotExistOrIncorrect
    case xCodeUnxipDirectoryDoesntExist
    case xCodeXIPInstallationError
    case xCodeMoveInstallationError
    case xCodePKGInstallationError
    case CLToolsInstallationError
}

@MainActor
class ShellInstaller: InstallerProtocol {

    let log: Logger
    let env: Environment
    public init(env: inout Environment, log: Logger) </span><span class="c">{
        self.env = env
        self.log = log
    }</span><span class="">

    // the shell commands we need to install XCode and its command line tools
    let SUDOCOMMAND = </span><span class="c">"/usr/bin/sudo"</span><span class="">
    let HDIUTILCOMMAND = </span><span class="c">"/usr/bin/hdiutil"</span><span class="">
    let INSTALLERCOMMAND = </span><span class="c">"/usr/sbin/installer"</span><span class="">

    // the pkg provided by Xcode to install
    let PKGTOINSTALL = </span><span class="c">[
        "XcodeSystemResources.pkg",
        "CoreTypes.pkg",
        "MobileDevice.pkg",
        "MobileDeviceDevelopment.pkg",
    ]</span><span class="">

    /// Install Xcode or Xcode Command Line Tools
    ///  At this stage, we do support only these two installation.
    ///
    ///   **Xcode** is provided as a XIP file. The installation procedure is as follow:
    ///   - It is uncompressed
    ///   - It is moved to /Applications
    ///   - Four packages are installed
    ///         - `/Applications/Xcode.app/Contents/Resources/Packages/XcodeSystemResources.pkg`
    ///         - `/Applications/Xcode.app/Contents/Resources/Packages/CoreTypes.pkg`
    ///         - `/Applications/Xcode.app/Contents/Resources/Packages/MobileDevice.pkg`
    ///         - `/Applications/Xcode.app/Contents/Resources/Packages/MobileDeviceDevelopment.pkg`
    ///
    ///   **Command_Line_Tools_for_Xcode** is provided as a DMG file. The installation procedure is as follow:
    ///   - the DMG file is mounted
    ///   - Package `/Volumes/Command\ Line\ Developer\ Tools/Command\ Line\ Tools.pkg` is installed.
    func install(file: URL) async throws </span><span class="c">{

        // verify this is one the files we do support
        let installationType = SupportedInstallation.supported(file.lastPathComponent)
        guard installationType != .unsuported else </span><span class="c">{
            log.debug</span><span class="c">(</span><span class="c">"Unsupported installation type"</span><span class="c">)
            throw InstallerError.unsupportedInstallation
        }</span><span class="c">

        // find matching File in DownloadList (if there is one)
        // and compare existing filesize vs expected filesize
        guard fileMatch(file: file) else </span><span class="c">{
            log.debug</span><span class="nc">(</span><span class="nc">"File does not exist or has incorrect size"</span><span class="c">)
            throw InstallerError.fileDoesNotExistOrIncorrect
        }</span><span class="c">

        // Dispatch installation between DMG and XIP
        switch </span><span class="c">installationType</span><span class="c"> {
        </span><span class="nc">case .xCode:
            try await self.installXcode(at: file)</span><span class="c">
        </span><span class="c">case .xCodeCommandLineTools:
            try await self.installCommandLineTools(atPath: file)</span><span class="c">
        </span><span class="nc">case .unsuported:
            throw InstallerError.unsupportedInstallation</span><span class="c">
        }</span><span class="c">
    }</span><span class="">

    // swiftlint:disable line_length
    ///
    ///  Verifies if file exists on disk. Also check if file exists in cached download list,
    ///  in that case, it verifies the actuali file size is the same as the one from the cached list
    ///
    /// - Parameters
    ///     - file  : the full path of the file to test
    /// - Returns
    ///     - true when file exists and, when download list cache exists too, if file size matches the one mentioned in the cached download list
    ///
    // swiftlint:enable line_length
    func fileMatch(file: URL) -&gt; Bool </span><span class="c">{

        // File exist on disk ?
        // no =&gt; return FALSE
        // yes - do an additional check
        //    if there is a download list cache AND file is present in list AND size DOES NOT match =&gt; False
        // all other cases return true (we can try to install even if their is no cached download list)

        var match = self.env.fileHandler.fileExists(file: file, fileSize: 0)

        if </span><span class="c">!match</span><span class="c"> </span><span class="c">{
            return false
        }</span><span class="c">

        // find file in downloadlist (if the cached download list exists)
        if let dll = try? self.env.fileHandler.loadDownloadList() </span><span class="c">{
            if let dlFile = dll.find(fileName: file.lastPathComponent) </span><span class="nc">{
                // compare download list cached sized with actual size
                match = self.env.fileHandler.fileExists(file: file, fileSize: dlFile.fileSize)
            }</span><span class="c">
        }
        return match</span><span class="c">
    }</span><span class="">

}

</span></pre><pre id="f10" style="display: none"><span>//
//  InstallCLTools.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 29/08/2022.
//

import CLIlib
import Foundation
import Subprocess

// MARK: Command Line Tools
// Command Line Tools installation functions
extension ShellInstaller {

    func installCommandLineTools(atPath file: URL) async throws </span><span class="c">{

        let filePath = file.path

        // check if file exists
        guard self.env.fileHandler.fileExists(file: file, fileSize: 0) else </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Command line disk image does not exist : \(filePath)"</span><span class="nc">)
            throw InstallerError.fileDoesNotExistOrIncorrect
        }</span><span class="c">

        // mount, install, unmount
        let totalSteps = 3
        var currentStep: Int = 0

        var result: ShellOutput

        // first mount the disk image
        log.debug</span><span class="nc">(</span><span class="nc">"Mounting disk image \(file.lastPathComponent)"</span><span class="c">)
        currentStep += 1
        self.env.progressBar.update(step: currentStep, total: totalSteps, text: "Mounting disk image...")
        result = try await self.mountDMG(atURL: file)</span><span class="c">
        if </span><span class="c">!result.terminationStatus.isSuccess</span><span class="c"> </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Can not mount disk image : \(filePath)\n\(String(describing: result))"</span><span class="nc">)
            throw InstallerError.CLToolsInstallationError
        }</span><span class="c">

        // second install the package
        // find the name of the package ?
        let pkg = URL(fileURLWithPath: "/Volumes/Command Line Developer Tools/Command Line Tools.pkg")
        let pkgPath = pkg.path
        log.debug</span><span class="nc">(</span><span class="nc">"Installing pkg \(pkgPath)"</span><span class="c">)
        currentStep += 1
        self.env.progressBar.update(step: currentStep, total: totalSteps, text: "Installing package...")
        result = try await self.installPkg(atURL: pkg)</span><span class="c">
        if </span><span class="c">!result.terminationStatus.isSuccess</span><span class="c"> </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Can not install package : \(pkgPath)\n\(String(describing: result))"</span><span class="nc">)
            throw InstallerError.CLToolsInstallationError
        }</span><span class="c">

        // third unmount the disk image
        let mountedDiskImage = URL(fileURLWithPath: "/Volumes/Command Line Developer Tools")
        log.debug</span><span class="nc">(</span><span class="nc">"Unmounting volume \(mountedDiskImage)"</span><span class="c">)
        currentStep += 1
        self.env.progressBar.update(step: currentStep, total: totalSteps, text: "Unmounting volume...")
        result = try await self.unmountDMG(volume: mountedDiskImage)</span><span class="c">
        if </span><span class="c">!result.terminationStatus.isSuccess</span><span class="c"> </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">
                </span><span class="nc">"Can not unmount volume : \(mountedDiskImage)\n\(String(describing: result))"</span><span class="nc">
            )
            throw InstallerError.CLToolsInstallationError
        }</span><span class="c">
    }</span><span class="">

    private func mountDMG(atURL dmg: URL) async throws -&gt; ShellOutput </span><span class="c">{

        let dmgPath = dmg.path

        // check if file exists
        guard self.env.fileHandler.fileExists(file: dmg, fileSize: 0) else </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Disk Image does not exist : \(dmgPath)"</span><span class="nc">)
            throw InstallerError.fileDoesNotExistOrIncorrect
        }</span><span class="c">

        // hdiutil mount ./xcode-cli.dmg
        return try await self.env.run(.path(HDIUTILCOMMAND), arguments: ["mount", dmgPath])</span><span class="c">
    }</span><span class="">

    private func unmountDMG(volume: URL) async throws -&gt; ShellOutput </span><span class="c">{

        // hdiutil unmount /Volumes/Command\ Line\ Developer\ Tools/
        try await self.env.run(.path(HDIUTILCOMMAND), arguments: ["unmount", volume.path])</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f11" style="display: none"><span>//
//  InstallDownloadListExtension.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 29/08/2022.
//

import Foundation

// MARK: Extensions - DownloadList
// not fileprivate to allow testing
extension DownloadList {

    /// Check an entire list for files matching the given filename
    /// This generic function avoids repeating code in the two `find(...)` below
    /// - Parameters
    ///     - fileName: the file name to check (without full path)
    ///     - inList: either a [Download] or a [File]
    ///     - comparison: a function that receives either a `Download` either a `File`
    ///                and returns a `File` when there is a file name match, nil otherwise
    /// - Returns
    ///     a File struct if a file matches, nil otherwise

    private func _find&lt;T: Sequence&gt;(
        fileName: String,
        inList list: T,
        comparison: (T.Element) -&gt; File?
    ) -&gt; File? </span><span class="c">{

        // first returns an array of File? with nil when filename does not match
        // or file otherwise.
        // for example : [nil, file, nil, nil]
        let result: [File?] = list.compactMap </span><span class="c">{ element -&gt; File? in
            return comparison(element)
        }</span><span class="c">
        // then remove all nil values
        //        .filter { file in
        //            return file != nil
        //        }

        // we should have 0 or 1 element
        if </span><span class="c">result.count &gt; 0</span><span class="c"> </span><span class="c">{
            assert(</span><span class="c">result.count == 1</span><span class="c">)
            return result[0]
        }</span><span class="c"> else </span><span class="c">{
            return nil
        }</span><span class="c">

    }</span><span class="">

    /// check the entire list of downloads for files matching the given filename
    /// - Parameters
    ///     - fileName: the file name to check (without full path)
    /// - Returns
    ///     a File struct if a file matches, nil otherwise
    func find(fileName: String) -&gt; File? </span><span class="c">{

        guard let listOfDownloads = self.downloads else </span><span class="nc">{
            return nil
        }</span><span class="c">

        return _find(
            fileName: fileName,
            inList: listOfDownloads,
            comparison: </span><span class="c">{ element in
                let download = element as Download
                return find(fileName: fileName, inDownload: download)
            }</span><span class="c">
        )
    }</span><span class="">

    // search the list of files ([File]) for an individual file match
    func find(fileName: String, inDownload download: Download) -&gt; File? </span><span class="c">{

        _find(
            fileName: fileName,
            inList: download.files,
            comparison: </span><span class="c">{ element in
                let file = element as File
                return file.filename == fileName ? </span><span class="c">file</span><span class="c"> : </span><span class="c">nil</span><span class="c">
            }</span><span class="c">
        )

    }</span><span class="">
}

</span></pre><pre id="f12" style="display: none"><span>//
//  InstallPkg.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 29/08/2022.
//

import CLIlib
import Foundation
import Subprocess

// MARK: PKG
// generic PKG installation function
extension ShellInstaller {

    func installPkg(atURL pkg: URL) async throws -&gt; ShellOutput </span><span class="c">{

        let pkgPath = pkg.path

        // check if file exists
        guard self.env.fileHandler.fileExists(file: pkg, fileSize: 0) else </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Package does not exist : \(pkgPath)"</span><span class="nc">)
            throw InstallerError.fileDoesNotExistOrIncorrect
        }</span><span class="c">

        return try await self.env.run(
            .path(SUDOCOMMAND),
            arguments: [INSTALLERCOMMAND, "-pkg", pkgPath, "-target", "/"]
        )</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f13" style="display: none"><span>//
//  InstallSupportedFiles.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 28/08/2022.
//

import Foundation

enum SupportedInstallation {
    case xCode
    case xCodeCommandLineTools
    case unsuported

    static func supported(_ file: String) -&gt; SupportedInstallation </span><span class="c">{

        // generic method to test file type

        struct SupportedFiles {
            // the start of the file names we currently support for installtion
            static let packages = ["Xcode", "Command Line Tools for Xcode"]

            // the file extensions of the the file names we currently support for installation
            static let extensions = ["xip", "dmg"]

            // the return values for this function
            static let values: [SupportedInstallation] = [.xCode, .xCodeCommandLineTools]

            static func enumerated() -&gt; EnumeratedSequence&lt;[String]&gt; </span><span class="c">{
                assert(</span><span class="c">packages.count == extensions.count</span><span class="c">)
                assert(</span><span class="c">packages.count == values.count</span><span class="c">)
                return packages.enumerated()
            }
        }

        // first return a [SupportedInstallation] with either unsupported or installation type
        let tempResult: [SupportedInstallation] = SupportedFiles.enumerated().compactMap </span><span class="c">{
            (index, filePrefix) in
            if </span><span class="c">file.hasPrefix(filePrefix) &amp;&amp; </span><span class="c">file.hasSuffix(SupportedFiles.extensions[index])</span><span class="c"> </span><span class="c">{
                return SupportedFiles.values[index]
            }</span><span class="c"> else </span><span class="c">{
                return SupportedInstallation.unsuported
            }</span><span class="c">
        }</span><span class="c">

        // then remove all unsupported values
        let result: [SupportedInstallation] = tempResult.filter </span><span class="c">{ installationType in
            return installationType != .unsuported
        }</span><span class="c">

        // at this stage we should have 0 or 1 value left
        assert(</span><span class="c">result.count == 0 || </span><span class="c">result.count == 1</span><span class="c">)
        return result.count == 0 ? </span><span class="c">.unsuported</span><span class="c"> : </span><span class="c">result[0]</span><span class="c">

        // non generic method to test the file type

        //        if file.hasPrefix("Command Line Tools for Xcode") &amp;&amp; file.hasSuffix(".dmg") {
        //            result = .xCodeCommandLineTools
        //        } else if file.hasPrefix("Xcode") &amp;&amp; file.hasSuffix(".xip") {
        //            result = .xCode
        //        } else {
        //            result = .unsuported
        //        }

        //        return result
    }</span><span class="">
}

</span></pre><pre id="f14" style="display: none"><span>//
//  InstallXcode.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 29/08/2022.
//

import CLIlib
import Foundation
import Subprocess
import libunxip

// MARK: XCODE
// XCode installation functions
extension ShellInstaller {

    func installXcode(at src: URL) async throws </span><span class="nc">{

        // unXIP, mv, 4 PKG to install
        let totalSteps = 2 + PKGTOINSTALL.count
        var currentStep: Int = 0

        var result: ShellOutput

        // first uncompress file
        log.debug</span><span class="nc">(</span><span class="nc">"Decompressing files"</span><span class="nc">)
        // run synchronously as there is no output for this operation
        currentStep += 1
        self.env.progressBar.update(
            step: currentStep,
            total: totalSteps,
            text: "Expanding Xcode xip (this might take a while)"
        )

        do </span><span class="nc">{
            try await self.uncompressXIP(atURL: src)</span><span class="nc">
        }</span><span class="nc"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Failed to extract XIP file: \(error)"</span><span class="nc">)
            throw InstallerError.xCodeXIPInstallationError
        }</span><span class="nc">

        // second move file to /Applications
        log.debug</span><span class="nc">(</span><span class="nc">"Moving app to destination"</span><span class="nc">)
        currentStep += 1
        self.env.progressBar.update(
            step: currentStep,
            total: totalSteps,
            text: "Moving Xcode to /Applications"
        )
        // find .app file
        let appFile = try env.fileHandler.downloadedFiles()</span><span class="nc">.filter(</span><span class="nc">{ fileName in
            return fileName.hasSuffix(".app")
        }</span><span class="nc">)
        if </span><span class="nc">appFile.count != 1</span><span class="nc"> </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">
                </span><span class="nc">"Zero or several app file to install in \(appFile), not sure which one is the correct one"</span><span class="nc">
            )
            throw InstallerError.xCodeMoveInstallationError
        }</span><span class="nc">

        let installedFile =
            try await self.moveApp(at: self.env.fileHandler.downloadDirectory().appendingPathComponent(appFile[0]))</span><span class="nc">

        // /Applications/Xcode.app/Contents/Resources/Packages/

        // third install packages provided with Xcode app
        for pkg in PKGTOINSTALL </span><span class="nc">{
            log.debug</span><span class="nc">(</span><span class="nc">"Installing package \(pkg)"</span><span class="nc">)
            currentStep += 1
            self.env.progressBar.update(
                step: currentStep,
                total: totalSteps,
                text: "Installing additional packages... \(pkg)"
            )
            result = try await self.installPkg(
                atURL: URL(fileURLWithPath: "\(installedFile)/Contents/resources/Packages/\(pkg)")
            )</span><span class="nc">
            if </span><span class="nc">!result.terminationStatus.isSuccess</span><span class="nc"> </span><span class="nc">{
                log.error</span><span class="nc">(</span><span class="nc">"Can not install pkg at : \(pkg)\n\(result)"</span><span class="nc">)
                throw InstallerError.xCodePKGInstallationError
            }</span><span class="nc">
        }</span><span class="nc">

    }</span><span class="">

    // expand a XIP file.  There is no way to create XIP file.
    // This code can not be tested without a valid, signed,  Xcode archive
    // https://en.wikipedia.org/wiki/.XIP
    func uncompressXIP(atURL file: URL) async throws </span><span class="c">{

        let filePath = file.path

        // not necessary, file existence has been checked before
        guard self.env.fileHandler.fileExists(file: file, fileSize: 0) else </span><span class="c">{
            log.error</span><span class="c">(</span><span class="c">"File to unXip does not exist : \(filePath)"</span><span class="c">)
            throw InstallerError.fileDoesNotExistOrIncorrect
        }</span><span class="nc">

        let output = file.deletingLastPathComponent()
        guard chdir(output.path) == 0 else </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Failed to access output directory at \(output): \(String(cString: strerror(errno)))"</span><span class="nc">)
            throw InstallerError.xCodeUnxipDirectoryDoesntExist
        }</span><span class="nc">

        // Use unxip library to decompress the XIP file
        let handle = try FileHandle(forReadingFrom: file)</span><span class="nc">
        let data = DataReader(descriptor: handle.fileDescriptor)
        for</span><span class="nc"> try await file in Unxip.makeStream(from: .xip(), to: .disk(), input: data) </span><span class="nc">{
            log.trace</span><span class="nc">(</span><span class="nc">"Uncompressing XIP file at \(file.name)"</span><span class="nc">)
            // do nothing at the moment
            // a future version might report progress to the UI
        }</span><span class="nc">
    }</span><span class="">

    func moveApp(at src: URL) async throws -&gt; String </span><span class="c">{

        // extract file name
        let fileName = src.lastPathComponent

        // create source and destination URL
        let appURL = URL(fileURLWithPath: "/Applications/\(fileName)")

        log.debug</span><span class="nc">(</span><span class="nc">"Going to move \n \(src) to \n \(appURL)"</span><span class="c">)
        // move synchronously
        try self.env.fileHandler.move(from: src, to: appURL)</span><span class="c">

        return appURL.path</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f15" style="display: none"><span>//
//  List.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 21/08/2022.
//

import CLIlib
import Foundation

extension AppleDownloader {

    // load the list of available downloads
    // when force is true, dowload from Apple even when there is a cache on disk
    // https://developer.apple.com
    // POST /services-account/QH65B2/downloadws/listDownloads.action
    //
    func list(force: Bool) async throws -&gt; DownloadList </span><span class="nc">{

        var downloadList: DownloadList?

        if </span><span class="nc">!force</span><span class="nc"> </span><span class="nc">{
            // load the list from file if we have it
            downloadList = try? self.env().fileHandler.loadDownloadList()
        }</span><span class="nc">

        if </span><span class="nc">downloadList == nil</span><span class="nc"> </span><span class="nc">{
            // need to download the list from Apple
            log.debug</span><span class="nc">(</span><span class="nc">"Downloading list from Apple..."</span><span class="nc">)
            let url =
                "https://developer.apple.com/services-account/QH65B2/downloadws/listDownloads.action"
            let (data, response) = try await apiCall(
                url: url,
                method: .POST,
                validResponse: .range(200..&lt;400)
            )</span><span class="nc">

            guard response.statusCode == 200 else </span><span class="nc">{
                log.error</span><span class="nc">(</span><span class="nc">"🛑 Download List response is not 200, something is incorrect"</span><span class="nc">)
                log.debug</span><span class="nc">(</span><span class="nc">"URLResponse = \(response)"</span><span class="nc">)
                throw DownloadError.invalidResponse
            }</span><span class="nc">

            do </span><span class="nc">{
                downloadList = try JSONDecoder().decode(DownloadList.self, from: data)</span><span class="nc">
            }</span><span class="nc"> catch </span><span class="nc">{
                throw DownloadError.parsingError(error: error)
            }</span><span class="nc">

            if </span><span class="nc">downloadList!.resultCode == 0</span><span class="nc"> </span><span class="nc">{

                // grab authentication cookie for later download
                if let cookies = response.value(forHTTPHeaderField: "Set-Cookie") </span><span class="nc">{
                    // save the new cookies we received (ADCDownloadAuth)
                    _ = try await self.env().secrets!.saveCookies(cookies)</span><span class="nc">
                }</span><span class="nc"> else </span><span class="nc">{
                    // swiftlint:disable line_length
                    log.error</span><span class="nc">(</span><span class="nc">
                        </span><span class="nc">"🛑 Download List response does not contain authentication cookie, something is incorrect"</span><span class="nc">
                    )
                    log.debug</span><span class="nc">(</span><span class="nc">"URLResponse = \(response)"</span><span class="nc">)
                    throw DownloadError.invalidResponse
                }</span><span class="nc">

                // success, save the list for reuse
                _ = try self.env().fileHandler.saveDownloadList(list: downloadList!)</span><span class="nc">

            }</span><span class="nc"> else </span><span class="nc">{

                switch </span><span class="nc">downloadList!.resultCode</span><span class="nc"> {
                </span><span class="nc">case 1100:  // authentication expired
                    throw DownloadError.authenticationRequired</span><span class="nc">
                </span><span class="nc">case 2100:  // needs to accept ToC
                    throw DownloadError.needToAcceptTermsAndCondition</span><span class="nc">
                </span><span class="nc">case 2170:  // accounts need upgrade
                    log.error</span><span class="nc">(</span><span class="nc">
                        </span><span class="nc">"Error \(downloadList!.resultCode) : \(downloadList!.userString ?? </span><span class="nc">"no user string"</span><span class="nc">)"
                    )
                    throw DownloadError.accountneedUpgrade(
                        errorCode: downloadList!.resultCode,
                        errorMessage: downloadList!.userString ?? </span><span class="nc">"Your developer account needs to be updated"</span><span class="nc">
                    )
                </span><span class="nc">default:
                    // is there other error cases that I need to handle explicitly ?
                    throw DownloadError.unknownError(
                        errorCode: downloadList!.resultCode,
                        errorMessage: downloadList!.userString ?? </span><span class="nc">"Unknwon error"</span><span class="nc">
                    )
                }
            }</span><span class="nc">
        }</span><span class="nc">

        guard let dList = downloadList else </span><span class="nc">{
            throw DownloadError.noDownloadsInDownloadList
        }</span><span class="nc">
        return dList</span><span class="nc">

    }</span><span class="">
}

</span></pre><pre id="f16" style="display: none"><span>//
//  URLLogger.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 18/07/2022.
//

import CLIlib
import Foundation
import Logging

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

// Using Swift's modern regex syntax
func _filterPassword(_ input: String) -&gt; String </span><span class="c">{
    let regex = /("password":").*?("[\,\}])/
    return input.replacing(regex) </span><span class="c">{ match in
        "\(match.1)*****\(match.2)"
    }</span><span class="c">
}</span><span class="">

func _log(request: URLRequest, to logger: Logger) </span><span class="c">{

    logger.debug</span><span class="nc">(</span><span class="nc">"\n - - - - - - - - - - OUTGOING - - - - - - - - - - \n"</span><span class="c">)
    defer { logger.debug</span><span class="nc">(</span><span class="nc">"\n - - - - - - - - - -  END - - - - - - - - - - \n"</span><span class="c">) }
    let urlAsString = request.url?.absoluteString ?? </span><span class="nc">""</span><span class="c">
    let urlComponents = URLComponents(string: urlAsString)
    let method = request.httpMethod != nil ? </span><span class="c">"\(request.httpMethod ?? </span><span class="nc">""</span><span class="c">)" : </span><span class="nc">""</span><span class="c">
    let path = "\(urlComponents?.path ?? </span><span class="nc">""</span><span class="c">)"
    let query = "\(urlComponents?.query ?? </span><span class="c">""</span><span class="c">)"
    let host = "\(urlComponents?.host ?? </span><span class="nc">""</span><span class="c">)"
    var output = """
        \(urlAsString) \n\n
        \(method) \(path)?\(query) HTTP/1.1 \n
        HOST: \(host)\n
        """

    for (key, value) in request.allHTTPHeaderFields ?? </span><span class="nc">[:]</span><span class="c"> </span><span class="c">{
        output += "\(key): \(value)\n"

    }</span><span class="c">

    if let body = request.httpBody </span><span class="c">{
        output += "\n \(String(data: body, encoding: .utf8) ?? </span><span class="nc">""</span><span class="c">)"
    }</span><span class="c">
    logger.debug</span><span class="nc">(</span><span class="nc">"\(_filterPassword(output))"</span><span class="c">)
}</span><span class="">

func _log(response: HTTPURLResponse?, data: Data?, error: Error?, to logger: Logger) </span><span class="c">{

    logger.debug</span><span class="nc">(</span><span class="nc">"\n - - - - - - - - - - INCOMMING - - - - - - - - - - \n"</span><span class="c">)
    defer { logger.debug</span><span class="nc">(</span><span class="nc">"\n - - - - - - - - - -  END - - - - - - - - - - \n"</span><span class="c">) }
    let urlString = response?.url?.absoluteString
    let components = NSURLComponents(string: urlString ?? </span><span class="nc">""</span><span class="c">)
    let path = "\(components?.path ?? </span><span class="nc">""</span><span class="c">)"
    let query = "\(components?.query ?? </span><span class="c">""</span><span class="c">)"
    var output = ""
    if let urlString </span><span class="c">{
        output += "\(urlString)"
        output += "\n\n"
    }</span><span class="c">
    if let statusCode = response?.statusCode </span><span class="c">{
        output += "HTTP \(statusCode) \(path)?\(query)\n"
    }</span><span class="c">
    if let host = components?.host </span><span class="c">{
        output += "Host: \(host)\n"
    }</span><span class="c">
    for (key, value) in response?.allHeaderFields ?? </span><span class="nc">[:]</span><span class="c"> </span><span class="c">{
        output += "\(key): \(value)\n"
    }</span><span class="c">
    if let data </span><span class="c">{
        output += "\n\(String(data: data, encoding: .utf8) ?? </span><span class="nc">""</span><span class="c">)\n"
    }
    if </span><span class="c">error != nil</span><span class="c"> </span><span class="nc">{
        output += "\nError: \(error!.localizedDescription)\n"
    }</span><span class="c">
    logger.debug</span><span class="nc">(</span><span class="nc">"\(_filterPassword(output))"</span><span class="c">)
}</span><span class="">

</span></pre><pre id="f17" style="display: none"><span>//
//  ExtensionURLRequest.swift
//
//  Created by Abhishek Maurya on 16/07/20.
//  Copyright © 2020. All rights reserved.
//
import Foundation

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

extension URLRequest {
    public func cURL(pretty: Bool = false) -&gt; String </span><span class="c">{
        let newLine = pretty ? </span><span class="c">"\\\n"</span><span class="c"> : </span><span class="c">""</span><span class="c">
        let method = (pretty ? </span><span class="c">"--request "</span><span class="c"> : </span><span class="c">"-X "</span><span class="c">) + "\(self.httpMethod ?? </span><span class="nc">"GET"</span><span class="c">) \(newLine)"
        let url: String = (pretty ? </span><span class="c">"--url "</span><span class="c"> : </span><span class="c">""</span><span class="c">) + "\'\(self.url?.absoluteString ?? </span><span class="nc">""</span><span class="c">)\' \(newLine)"

        var cURL = (pretty ? </span><span class="c">"curl -v --disable "</span><span class="c"> : </span><span class="c">"curl -q "</span><span class="c">)
        var header = ""
        var data: String = ""

        if let httpHeaders = self.allHTTPHeaderFields, httpHeaders.keys.count &gt; 0 </span><span class="c">{
            for (key, value) in httpHeaders </span><span class="c">{
                header += (pretty ? </span><span class="c">"--header "</span><span class="c"> : </span><span class="c">"-H "</span><span class="c">) + "\'\(key): \(value)\' \(newLine)"
            }</span><span class="c">
        }</span><span class="c">

        if let bodyData = self.httpBody, let bodyString = String(data: bodyData, encoding: .utf8),
            !bodyString.isEmpty
        </span><span class="c">{
            data = "--data '\(bodyString)'"
        }</span><span class="c">

        cURL += method + url + header + data

        return cURL
    }</span><span class="">
}

</span></pre><pre id="f18" style="display: none"><span>//
//  CLIAuthenticate.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 23/07/2022.
//

import ArgumentParser
import CLIlib
import Foundation
import Logging

extension MainCommand {

    struct Authenticate: AsyncParsableCommand {
        nonisolated static let configuration =
            CommandConfiguration(abstract: "Authenticate yourself against Apple Developer Portal")

        @OptionGroup var globalOptions: GlobalOptions
        @OptionGroup var cloudOption: CloudOptions

        @</span><span class="nc">Option(name: .long, help: "Use SRP authentication")</span><span class="">
        var srp = </span><span class="nc">true</span><span class="">

        func run() async throws </span><span class="nc">{
            try await run(with: nil)</span><span class="nc">
        }</span><span class="">

        func run(with env: Environment?) async throws </span><span class="nc">{

            let xci = try await MainCommand.XCodeInstaller(
                with: env,
                for: cloudOption.secretManagerRegion,
                verbose: globalOptions.verbose,
            )</span><span class="nc">

            try await xci.authenticate(with: AuthenticationMethod.withSRP(srp))</span><span class="nc">
        }</span><span class="">
    }

    struct Signout: AsyncParsableCommand {
        nonisolated static let configuration = CommandConfiguration(abstract: "Signout from Apple Developer Portal")

        @OptionGroup var globalOptions: GlobalOptions
        @OptionGroup var cloudOption: CloudOptions

        func run() async throws </span><span class="nc">{
            try await run(with: nil)</span><span class="nc">
        }</span><span class="">

        func run(with env: Environment?) async throws </span><span class="nc">{

            let xci = try await MainCommand.XCodeInstaller(
                with: env,
                for: cloudOption.secretManagerRegion,
                verbose: globalOptions.verbose
            )</span><span class="nc">
            try await xci.signout()</span><span class="nc">
        }</span><span class="">
    }

}

</span></pre><pre id="f19" style="display: none"><span>//
//  CLIAuthenticate.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 23/07/2022.
//

import ArgumentParser
import CLIlib
import Foundation
import Logging

// download implementation
extension MainCommand {

    struct Download: AsyncParsableCommand {
        nonisolated static let configuration = CommandConfiguration(
            abstract: "Download the specified version of Xcode"
        )

        @OptionGroup var globalOptions: GlobalOptions
        @OptionGroup var downloadListOptions: DownloadListOptions
        @OptionGroup var cloudOption: CloudOptions

        @Option(
            name: .shortAndLong,
            help: "The exact package name to downloads. When omited, it asks interactively"
        )
        var name: String?

        func run() async throws </span><span class="nc">{
            try await run(with: nil)</span><span class="nc">
        }</span><span class="">

        func run(with env: Environment?) async throws </span><span class="c">{
            let xci = try await MainCommand.XCodeInstaller(
                with: env,
                for: cloudOption.secretManagerRegion,
                verbose: globalOptions.verbose
            )</span><span class="c">

            try await xci.download(
                fileName: name,
                force: downloadListOptions.force,
                xCodeOnly: downloadListOptions.onlyXcode,
                majorVersion: downloadListOptions.xCodeVersion,
                sortMostRecentFirst: downloadListOptions.mostRecentFirst,
                datePublished: downloadListOptions.datePublished
            )</span><span class="c">
        }</span><span class="">
    }

}

</span></pre><pre id="f20" style="display: none"><span>//
//  CLIInstall.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 22/08/2022.
//

import ArgumentParser
import CLIlib
import Foundation
import Logging

// Install implementation
@MainActor
extension MainCommand {

    struct Install: AsyncParsableCommand {

        nonisolated static let configuration =
            CommandConfiguration(abstract: "Install a specific XCode version or addon package")

        @OptionGroup var globalOptions: GlobalOptions

        @Option(
            name: .shortAndLong,
            help: "The exact package name to install. When omited, it asks interactively"
        )
        var name: String?

        func run() async throws </span><span class="nc">{
            try await run(with: nil)</span><span class="nc">
        }</span><span class="">

        func run(with env: Environment?) async throws </span><span class="c">{
            let xci = try await MainCommand.XCodeInstaller(
                with: env,
                verbose: globalOptions.verbose
            )</span><span class="c">

            _ = try await xci.install(file: name)</span><span class="c">
        }</span><span class="">
    }
}

</span></pre><pre id="f21" style="display: none"><span>//
//  CLIAuthenticate.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 23/07/2022.
//

import ArgumentParser
import CLIlib
import Foundation
import Logging

// list implementation
extension MainCommand {

    struct DownloadListOptions: ParsableArguments {

        nonisolated static let configuration =
            CommandConfiguration(
                abstract: "Common options for list and download commands",
                shouldDisplay: false
            )

        @</span><span class="c">Flag(
            name: .shortAndLong,
            help:
                "Force to download the list from Apple Developer Portal, even if we have it in the cache"
        )</span><span class="">
        var force: Bool = </span><span class="c">false</span><span class="">

        @</span><span class="c">Flag(name: .shortAndLong, help: "Filter on Xcode package only")</span><span class="">
        var onlyXcode: Bool = </span><span class="c">false</span><span class="">

        @</span><span class="c">Option(
            name: [.customLong("xcode-version"), .short],
            help: "Filter on provided Xcode version number"
        )</span><span class="">
        var xCodeVersion: String = </span><span class="c">"16"</span><span class="">

        @</span><span class="c">Flag(name: .shortAndLong, help: "Sort by most recent releases first")</span><span class="">
        var mostRecentFirst: Bool = </span><span class="c">false</span><span class="">

        @</span><span class="c">Flag(name: .shortAndLong, help: "Show publication date")</span><span class="">
        var datePublished: Bool = </span><span class="c">false</span><span class="">

    }

    @MainActor
    struct List: AsyncParsableCommand {

        nonisolated static let configuration =
            CommandConfiguration(abstract: "List available versions of Xcode and development tools")

        @OptionGroup var globalOptions: GlobalOptions
        @OptionGroup var downloadListOptions: DownloadListOptions
        @OptionGroup var cloudOption: CloudOptions

        func run() async throws </span><span class="nc">{
            try await run(with: nil)</span><span class="nc">
        }</span><span class="">

        func run(with env: Environment?) async throws </span><span class="c">{
            let xci = try await MainCommand.XCodeInstaller(
                with: env,
                for: cloudOption.secretManagerRegion,
                verbose: globalOptions.verbose
            )</span><span class="c">

            _ = try await xci.list(
                force: downloadListOptions.force,
                xCodeOnly: downloadListOptions.onlyXcode,
                majorVersion: downloadListOptions.xCodeVersion,
                sortMostRecentFirst: downloadListOptions.mostRecentFirst,
                datePublished: downloadListOptions.datePublished
            )</span><span class="c">
        }</span><span class="">
    }
}

</span></pre><pre id="f22" style="display: none"><span>//
//  CLI.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 18/07/2022.
//

import ArgumentParser
import CLIlib
import Foundation
import Logging

enum CLIError: Error {
    case invalidInput
}

@main
@MainActor
struct MainCommand: AsyncParsableCommand {

    // arguments that are global to all commands
    struct GlobalOptions: ParsableArguments {

        @</span><span class="c">Flag(name: .shortAndLong, help: "Produce verbose output for debugging")</span><span class="">
        var verbose = </span><span class="c">false</span><span class="">
    }

    // arguments for Authenticate, Signout, List, and Download
    struct CloudOptions: ParsableArguments {

        @Option(
            name: [.customLong("secretmanager-region"), .short],
            help: "Instructs to use AWS Secrets Manager to store and read secrets in the given AWS Region"
        )
        var secretManagerRegion: String?
    }

    @OptionGroup var globalOptions: GlobalOptions

    // Customize the command's help and subcommands by implementing the
    // `configuration` property.
    nonisolated static let configuration = CommandConfiguration(
        commandName: "xcodeinstall",

        // Optional abstracts and discussions are used for help output.
        abstract: "A utility to download and install Xcode",

        // Commands can define a version for automatic '--version' support.
        version: Version.version,  // generated by scripts/deploy/version.sh

        // Pass an array to `subcommands` to set up a nested tree of subcommands.
        // With language support for type-level introspection, this could be
        // provided by automatically finding nested `ParsableCommand` types.
        subcommands: [
            Authenticate.self, Signout.self, List.self,
            Download.self, Install.self, StoreSecrets.self,
        ]

        // A default subcommand, when provided, is automatically selected if a
        // subcommand is not given on the command line.
        // defaultSubcommand: List.self)
    )

    public static func XCodeInstaller(
        with env: (any Environment)? = nil,
        for region: String? = nil,
        verbose: Bool
    ) async throws -&gt; XCodeInstall </span><span class="c">{

        var logger = Logger(label: "xcodeinstall")
        if </span><span class="c">verbose</span><span class="c"> </span><span class="c">{
            logger.logLevel = .debug
        }</span><span class="c"> else </span><span class="c">{
            logger.logLevel = .error
        }</span><span class="c">

        var runtimeEnv: any Environment = (env == nil ? </span><span class="nc">RuntimeEnvironment(region: region, log: logger)</span><span class="c"> : </span><span class="c">env!</span><span class="c">)

        let xci: XCodeInstall!
        if let region </span><span class="c">{
            // overwrite the secret storage
            runtimeEnv.secrets = try SecretsStorageAWS(region: region, log: logger)</span><span class="c">
            xci = XCodeInstall(log: logger, env: runtimeEnv)
        }</span><span class="c"> else </span><span class="c">{
            // the env creates a file-based secrets storage by default
            xci = XCodeInstall(log: logger, env: runtimeEnv)
        }</span><span class="c">
        return xci</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f23" style="display: none"><span>//
//  CLIProgressBar.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 10/08/2022.
//

// found here https://www.fivestars.blog/articles/ultimate-guide-swift-executables/ and
// https://www.fivestars.blog/articles/executables-progress/

// alternatives to consider to reduce size of dependencies
// https://github.com/vapor/console-kit/tree/main/Sources/ConsoleKit/Activity
// https://github.com/nsscreencast/469-swift-command-line-progress-bar
// https://github.com/jkandzi/Progress.swift/blob/master/Sources/Progress.swift

import CLIlib
import Foundation

protocol CLIProgressBarProtocol: ProgressUpdateProtocol {
    func define(animationType: ProgressBarType, message: String)
}

class CLIProgressBar: CLIProgressBarProtocol {

    private var progressAnimation: ProgressUpdateProtocol?
    private var message: String?
    private let stream: OutputBuffer = </span><span class="nc">FileHandle.standardOutput</span><span class="">

    func define(animationType: ProgressBarType, message: String) </span><span class="nc">{
        self.message = message
        self.progressAnimation = ProgressBar(
            output: stream,
            progressBarType: animationType,
            title: self.message
        )
    }</span><span class="">

    /// Update the animation with a new step.
    /// - Parameters:
    ///   - step: The index of the operation's current step.
    ///   - total: The total number of steps before the operation is complete.
    ///   - text: The description of the current step.
    func update(step: Int, total: Int, text: String) </span><span class="nc">{
        self.progressAnimation?.update(step: step, total: total, text: text)
    }</span><span class="">

    /// Complete the animation.
    /// - Parameters:
    ///   - success: Defines if the operation the animation represents was succesful.
    func complete(success: Bool) </span><span class="nc">{
        self.progressAnimation?.complete(success: success)
    }</span><span class="">

    /// Clear the animation.
    func clear() </span><span class="nc">{
        self.progressAnimation?.clear()
    }</span><span class="">

}

</span></pre><pre id="f24" style="display: none"><span>//
//  CLIStoreSecrets.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 01/09/2022.
//

import ArgumentParser
import CLIlib
import Foundation
import Logging

extension MainCommand {

    struct StoreSecrets: AsyncParsableCommand {
        nonisolated static let configuration =
            CommandConfiguration(
                commandName: "storesecrets",
                abstract: "Store your Apple Developer Portal username and password in AWS Secrets Manager"
            )

        @OptionGroup var globalOptions: GlobalOptions

        // repeat of CloudOption but this time mandatory
        @Option(
            name: [.customLong("secretmanager-region"), .short],
            help: "Instructs to use AWS Secrets Manager to store and read secrets in the given AWS Region"
        )
        var secretManagerRegion: String

        func run() async throws </span><span class="nc">{
            try await run(with: nil)</span><span class="nc">
        }</span><span class="">

        func run(with env: Environment?) async throws </span><span class="c">{
            let xci = try await MainCommand.XCodeInstaller(
                with: env,
                for: secretManagerRegion,
                verbose: globalOptions.verbose
            )</span><span class="c">

            _ = try await xci.storeSecrets()</span><span class="nc">
        }</span><span class="">
    }

}

</span></pre><pre id="f25" style="display: none"><span>//
//  Environment.swift
//
//
//  Created by Stormacq, Sebastien on 22/11/2022.
//

import CLIlib
import Foundation
import Logging
import Subprocess

#if canImport(System)
import System
#else
import SystemPackage
#endif

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

/**

 a global struct to give access to classes for which I wrote tests.
 this global object allows me to simplify dependency injection */

@MainActor
protocol Environment: Sendable {
    var fileHandler: FileHandlerProtocol { get }
    var display: DisplayProtocol { get }
    var readLine: ReadLineProtocol { get }
    var progressBar: CLIProgressBarProtocol { get }
    var secrets: SecretsHandlerProtocol? { get set }
    var authenticator: AppleAuthenticatorProtocol { get }
    var downloader: AppleDownloaderProtocol { get }
    var urlSessionData: URLSessionProtocol { get }
    var downloadManager: DownloadManager { get }
    func run(
        _ executable: Executable,
        arguments: Arguments,
        workingDirectory: FilePath?,
    ) async throws -&gt; ShellOutput
    func run(
        _ executable: Executable,
        arguments: Arguments,
    ) async throws -&gt; ShellOutput
}

@MainActor
struct RuntimeEnvironment: Environment {

    let region: String?
    let log: Logger

    init(region: String? = nil, log: Logger) </span><span class="nc">{
        self.region = region
        self.log = log

        self._authenticator = AppleAuthenticator(log: log)
        self._downloader = AppleDownloader(log: log)
        self._fileHandler = FileHandler(log: log)
        self._secrets = SecretsStorageFile(log: log)

        self.urlSessionData = URLSession.shared
        self.downloadManager = DownloadManager(logger: self.log)
    }</span><span class="">

    // CLI related classes
    var display: DisplayProtocol = </span><span class="nc">Display()</span><span class="">
    var readLine: ReadLineProtocol = </span><span class="nc">ReadLine()</span><span class="">

    // progress bar
    var progressBar: CLIProgressBarProtocol = </span><span class="nc">CLIProgressBar()</span><span class="">

    // Utilities classes
    private var _fileHandler: FileHandlerProtocol
    var fileHandler: FileHandlerProtocol </span><span class="nc">{ self._fileHandler }</span><span class="">

    // Secrets - will be overwritten by CLI when using AWS Secrets Manager
    private var _secrets: SecretsHandlerProtocol? = </span><span class="nc">nil</span><span class="">
    var secrets: SecretsHandlerProtocol? {
        get </span><span class="nc">{ _secrets }</span><span class="">
        set </span><span class="nc">{ _secrets = newValue }</span><span class="">
    }

    // Commands
    private var _authenticator: AppleAuthenticatorProtocol
    var authenticator: AppleAuthenticatorProtocol {
        get </span><span class="nc">{
            (self._authenticator as? AppleAuthenticator)?.environment = self
            return self._authenticator
        }</span><span class="">
        set </span><span class="nc">{
            self._authenticator = newValue
        }</span><span class="">
    }
    private var _downloader: AppleDownloaderProtocol
    var downloader: AppleDownloaderProtocol {
        get </span><span class="nc">{
            (self._downloader as? AppleDownloader)?.environment = self
            return self._downloader
        }</span><span class="">
        set </span><span class="nc">{
            self._downloader = newValue
        }</span><span class="">
    }

    // Network
    let urlSessionData: URLSessionProtocol
    let downloadManager: DownloadManager

    func run(
        _ executable: Executable,
        arguments: Arguments,
    ) async throws -&gt; ShellOutput </span><span class="nc">{
        try await run(
            executable,
            arguments: arguments,
            workingDirectory: nil
        )</span><span class="nc">
    }</span><span class="">
    func run(
        _ executable: Executable,
        arguments: Arguments,
        workingDirectory: FilePath?,
    ) async throws -&gt; ShellOutput </span><span class="nc">{
        try await Subprocess.run(
            executable,
            arguments: arguments,
            environment: .inherit,
            workingDirectory: workingDirectory,
            platformOptions: PlatformOptions(),
            input: .none,
            output: .string(limit: 1024, encoding: UTF8.self),
            error: .string(limit: 1024, encoding: UTF8.self)
        )</span><span class="nc">
    }</span><span class="">
}

</span></pre><pre id="f26" style="display: none"><span>//
//  Helper.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 19/07/2022.
//

import Foundation

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

protocol Secrets {
    func data() throws -&gt; Data
    func string() throws -&gt; String?
}

// the data to be stored in Secrets Manager as JSON
struct AppleCredentialsSecret: Codable, Secrets {

    let username: String
    let password: String

    func data() throws -&gt; Data </span><span class="c">{
        try JSONEncoder().encode(self)</span><span class="c">
    }</span><span class="">

    func string() throws -&gt; String? </span><span class="c">{
        String(data: try self.data()</span><span class="c">, encoding: .utf8)
    }</span><span class="">

    init(fromData data: Data) throws </span><span class="nc">{
        self = try JSONDecoder().decode(AppleCredentialsSecret.self, from: data)</span><span class="nc">
    }</span><span class="">

    init(fromString string: String) throws </span><span class="nc">{
        if let data = string.data(using: .utf8) </span><span class="nc">{
            try self.init(fromData: data)</span><span class="nc">
        }</span><span class="nc"> else </span><span class="nc">{
            fatalError(</span><span class="nc">"Can not create data from string : \(string)"</span><span class="nc">)
        }</span><span class="nc">
    }</span><span class="">

    init(username: String = "", password: String = "") </span><span class="c">{
        self.username = username
        self.password = password
    }</span><span class="">

}

protocol SecretsHandlerProtocol: Sendable {

    func clearSecrets() async throws

    //    func clearSecrets(preserve: Bool)
    //    func restoreSecrets()

    func saveCookies(_ cookies: String?) async throws -&gt; String?
    func loadCookies() async throws -&gt; [HTTPCookie]

    func saveSession(_ session: AppleSession) async throws -&gt; AppleSession
    func loadSession() async throws -&gt; AppleSession?

    func retrieveAppleCredentials() async throws -&gt; AppleCredentialsSecret
    func storeAppleCredentials(_ credentials: AppleCredentialsSecret) async throws
}

extension SecretsHandlerProtocol {

    ///
    /// Merge given cookies with the one stored already
    ///
    /// - Parameters
    ///     - cookies : the new cookies to store (or to append)
    ///
    /// - Returns : the new string with all cookies
    ///
    func mergeCookies(existingCookies: [HTTPCookie], newCookies: String?) async throws -&gt; String? </span><span class="c">{

        guard let cookieString = newCookies else </span><span class="nc">{
            return nil
        }</span><span class="c">

        var result = existingCookies

        // transform received cookie string into [HTTPCookie]
        let newCookies = cookieString.cookies()

        // merge cookies, new values have priority

        // browse new cookies
        for newCookie in newCookies </span><span class="c">{

            // if a newCookie match an existing one
            if </span><span class="c">(existingCookies.contains </span><span class="c">{ cookie in cookie.name == newCookie.name }</span><span class="c">) </span><span class="c">{

                // replace old with new
                // assuming there is only one !!
                result.removeAll </span><span class="c">{ cookie in cookie.name == newCookie.name }</span><span class="c">
                result.append(newCookie)
            }</span><span class="c"> else </span><span class="c">{
                // add new to existing
                result.append(newCookie)
            }</span><span class="c">

        }</span><span class="c">

        // save new set of cookie as string
        return result.string()</span><span class="c">

    }</span><span class="">
}

extension String {

    func cookies() -&gt; [HTTPCookie] </span><span class="c">{
        var fakeHttpHeader = [String: String]()
        fakeHttpHeader["Set-Cookie"] = self
        // only cookies from this domain or subdomains are going to be created
        return HTTPCookie.cookies(
            withResponseHeaderFields: fakeHttpHeader,
            for: URL(string: "https://apple.com")!
        )

    }</span><span class="">

}

extension Array where Element == HTTPCookie {

    func string() -&gt; String? </span><span class="c">{

        var cookieString = ""

        // for each cookie
        for cookie in self </span><span class="c">{

            if let props = cookie.properties </span><span class="c">{

                // return all properties as an array of strings with key=value
                var cookieAsString = props.map </span><span class="c">{ (key: HTTPCookiePropertyKey, value: Any) -&gt; String in
                    switch </span><span class="c">key.rawValue</span><span class="c"> {
                    // boolean values are handled separately
                    </span><span class="c">case "Secure": return "Secure"</span><span class="c">
                    </span><span class="c">case "HttpOnly": return "HttpOnly"</span><span class="c">
                    </span><span class="c">case "Discard": return ""</span><span class="c">

                    // name and value are handled separately to produce name=value
                    // (and not Name=name and Value=value)
                    </span><span class="c">case "Name": return ""</span><span class="c">
                    </span><span class="c">case "Value": return ""</span><span class="c">

                    </span><span class="c">default: return "\(key.rawValue)=\(value)"</span><span class="c">
                    }
                }</span><span class="c">

                // remove empty strings
                cookieAsString.removeAll </span><span class="c">{ string in string == "" }</span><span class="c">

                // add a coma in between cookies
                if </span><span class="c">cookieString != ""</span><span class="c"> </span><span class="c">{
                    cookieString += ", "
                }</span><span class="c">

                // add name=value
                if let name = props[HTTPCookiePropertyKey.name] as? String,
                    let value = props[HTTPCookiePropertyKey.value] as? String
                </span><span class="c">{
                    cookieString += "\(name)=\(value); "
                }</span><span class="c"> else </span><span class="nc">{
                    fatalError(</span><span class="nc">"Cookie string has no name or value values"</span><span class="nc">)
                }</span><span class="c">

                // concatenate all strings, spearated by a coma
                cookieString += cookieAsString.joined(separator: "; ")
            }
        }</span><span class="c">

        // remove last
        return cookieString</span><span class="c">
    }</span><span class="">

}

</span></pre><pre id="f27" style="display: none"><span>//
//  SecretsStorageAWSSoto.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 04/09/2022.
//

import CLIlib
import Foundation
import Logging
import SotoSecretsManager

// use a class to have a chance to call client.shutdown() at deinit
final class SecretsStorageAWSSoto: SecretsStorageAWSSDKProtocol {

    let log: Logger
    let maxRetries = </span><span class="c">3</span><span class="">

    let awsClient: AWSClient?  // var for injection
    let smClient: SecretsManager?  // var for injection

    private init(awsClient: AWSClient? = nil, smClient: SecretsManager? = nil, log: Logger) </span><span class="c">{
        self.awsClient = awsClient
        self.smClient = smClient
        self.log = log
    }</span><span class="">

    static func forRegion(_ region: String, log: Logger) throws -&gt; SecretsStorageAWSSDKProtocol </span><span class="c">{
        try SecretsStorageAWSSoto.forRegion(region, awsClient: nil, smClient: nil, log: log)</span><span class="c">
    }</span><span class="">
    static func forRegion(
        _ region: String,
        awsClient: AWSClient? = nil,
        smClient: SecretsManager? = nil,
        log: Logger
    ) throws -&gt; SecretsStorageAWSSDKProtocol </span><span class="c">{
        guard let awsRegion = Region(awsRegionName: region) else </span><span class="c">{
            throw SecretsStorageAWSError.invalidRegion(region: region)
        }</span><span class="c">
        var newAwsClient: AWSClient? = nil
        if </span><span class="c">awsClient == nil</span><span class="c"> </span><span class="c">{
            newAwsClient = AWSClient(
                credentialProvider: .selector(.environment, .ec2, .configFile()),
                retryPolicy: .jitter(),
                httpClientProvider: .createNew
            )
        }</span><span class="c">
        var newSMClient: SecretsManager?
        if </span><span class="c">smClient == nil</span><span class="c"> </span><span class="c">{
            newSMClient = SecretsManager(
                client: awsClient ?? </span><span class="c">newAwsClient!</span><span class="c">,
                region: awsRegion
            )
        }</span><span class="c">
        return SecretsStorageAWSSoto(
            awsClient: awsClient ?? </span><span class="c">newAwsClient!</span><span class="c">,
            smClient: smClient ?? </span><span class="c">newSMClient!</span><span class="c">,
            log: log
        )</span><span class="c">
    }</span><span class="">

    deinit </span><span class="c">{
        try? self.awsClient?.syncShutdown()
    }</span><span class="">

    // MARK: private functions - AWS SecretsManager Call using Soto SDK

    //    func list() async throws {
    //        print("calling list secrets")
    //        let request = SecretsManager.ListSecretsRequest()
    //        _ = try await smClient.listSecrets(request)
    //    }

    ///
    /// Create a secret in AWS SecretsManager
    /// - Parameters:
    ///     - secretId : the name of the secret
    ///     - secretValue : a string to store as a secret
    /// - Throws:
    ///         This function throws error from the underlying SDK
    ///
    private func createSecret(secretId: String, secretValue: Secrets) async throws </span><span class="nc">{
        do </span><span class="nc">{
            let secretString = try secretValue.string()</span><span class="nc">
            let createSecretRequest = SecretsManager.CreateSecretRequest(
                description: "xcodeinstall secret",
                name: secretId,
                secretString: secretString
            )
            _ = try await smClient?.createSecret(createSecretRequest)</span><span class="nc">
        }</span><span class="nc"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Can not create secret \(secretId) : \(error)"</span><span class="nc">)
            throw error
        }</span><span class="nc">
    }</span><span class="">

    ///
    ///  Execute an API call AWS SecretsManager and create the secret when the secret name does not exist.
    ///  Aftre creating the secret, the API call is attempted again.  The function tries 3 times before abording
    ///
    /// - Parameters:
    ///     - secretId : the name of the secret
    ///     - secretValue : a string to store as a secret,
    ///     - step: the current retry step (start at 1)
    ///     - block: the block of code to execute (contains the call to SecretsManager)
    /// - Throws:
    ///         This function throws error from the underlying SDK
    ///

    private func executeRequestAndCreateWhenNotExist(
        secretId: String,
        secretValue: Secrets,
        step: Int,
        block: () async throws -&gt; Void
    ) async throws </span><span class="c">{

        do </span><span class="c">{
            // try to execute the supplied block
            try await block()</span><span class="nc">

            // if it fails with a resource not found error,
        }</span><span class="c"> catch let error as SotoSecretsManager.SecretsManagerErrorType </span><span class="nc">{

            // create the resource and try again
            if </span><span class="nc">error == .resourceNotFoundException</span><span class="nc"> </span><span class="nc">{
                log.debug</span><span class="nc">(</span><span class="nc">"Secrets \(secretId) does not exist, creating it"</span><span class="nc">)
                try await self.createSecret(secretId: secretId, secretValue: secretValue)</span><span class="nc">

                if </span><span class="nc">step &lt;= maxRetries</span><span class="nc"> </span><span class="nc">{
                    // recursive call to ourselevs
                    log.debug</span><span class="nc">(</span><span class="nc">"Re-trying the block call (attempt #\(step + 1))"</span><span class="nc">)
                    try await self.executeRequestAndCreateWhenNotExist(
                        secretId: secretId,
                        secretValue: secretValue,
                        step: step + 1,
                        block: block
                    )</span><span class="nc">
                }</span><span class="nc"> else </span><span class="nc">{
                    log.error</span><span class="nc">(</span><span class="nc">"Max attempt to call Secrets Manager"</span><span class="nc">)
                }</span><span class="nc">

            }</span><span class="nc"> else </span><span class="nc">{
                log.error</span><span class="nc">(</span><span class="nc">"AWS API Error\n\(error)"</span><span class="nc">)
                throw error
            }</span><span class="nc">

        }</span><span class="nc">
    }</span><span class="">

    ///
    ///  Update an existing secret
    ///
    ///  - Parameters
    ///     - secretId : the name of the secret
    ///     - newValue : the updated value
    /// - Throws:
    ///         This function throws error from the underlying SDK
    ///
    func updateSecret&lt;T: Secrets&gt;(secretId: AWSSecretsName, newValue: T) async throws </span><span class="c">{
        do </span><span class="c">{

            // maybe the secret does not exist yet - so wrap our call with
            // a function hat will create it in case it does not exist
            try await executeRequestAndCreateWhenNotExist(
                secretId: secretId.rawValue,
                secretValue: newValue,
                step: 1,
                block: </span><span class="c">{

                    let secretString = try newValue.string()</span><span class="c">
                    let putSecretRequest = SecretsManager.PutSecretValueRequest(
                        secretId: secretId.rawValue,
                        secretString: secretString
                    )

                    log.debug</span><span class="c">(</span><span class="c">"Updating secret \(secretId) with \(newValue)"</span><span class="c">)
                    let putSecretResponse = try await smClient?.putSecretValue(putSecretRequest)</span><span class="nc">
                    log.debug</span><span class="nc">(</span><span class="nc">
                        </span><span class="nc">"\(putSecretResponse?.name ?? </span><span class="nc">""</span><span class="nc">) has version \(putSecretResponse?.versionId ?? </span><span class="nc">""</span><span class="nc">)"
                    )
                }</span><span class="c">
            )</span><span class="nc">

        }</span><span class="c"> catch </span><span class="c">{
            log.error</span><span class="c">(</span><span class="c">"Unexpected error while updating secrets\n\(error)"</span><span class="c">)
            throw error
        }</span><span class="nc">
    }</span><span class="">

    // FIXME: improve error handling when secret is not retrieved
    // swiftlint:disable force_cast
    func retrieveSecret&lt;T: Secrets&gt;(secretId: AWSSecretsName) async throws -&gt; T </span><span class="nc">{
        do </span><span class="nc">{
            let getSecretRequest = SecretsManager.GetSecretValueRequest(secretId: secretId.rawValue)
            log.debug</span><span class="nc">(</span><span class="nc">"Retrieving secret \(secretId)"</span><span class="nc">)
            let getSecretResponse = try await smClient?.getSecretValue(getSecretRequest)</span><span class="nc">
            log.debug</span><span class="nc">(</span><span class="nc">"Secret \(getSecretResponse?.name ?? </span><span class="nc">"nil"</span><span class="nc">) retrieved")

            guard let secret = getSecretResponse?.secretString else </span><span class="nc">{
                log.error</span><span class="nc">(</span><span class="nc">"⚠️ no value returned by AWS Secrets Manager secret \(secretId)"</span><span class="nc">)
                return secretId == .appleCredentials
                    ? </span><span class="nc">AppleCredentialsSecret() as! T</span><span class="nc"> : </span><span class="nc">AppleSessionSecret() as! T</span><span class="nc">
            }</span><span class="nc">

            switch </span><span class="nc">secretId</span><span class="nc"> {
            </span><span class="nc">case .appleCredentials:
                return try AppleCredentialsSecret(fromString: secret)</span><span class="nc"> as! T</span><span class="nc">
            </span><span class="nc">case .appleSessionToken:
                return try AppleSessionSecret(fromString: secret)</span><span class="nc"> as! T</span><span class="nc">
            }

        } catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Unexpected error while retrieving secrets\n\(error)"</span><span class="nc">)
            throw error

        }

    }</span><span class="">
    // swiftlint:enable force_cast

}

</span></pre><pre id="f28" style="display: none"><span>//
//  SecretsStorageAWS.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 01/09/2022.
//

import CLIlib
import Foundation
import Logging

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

// the errors thrown by the SecretsManager class
enum SecretsStorageAWSError: Error {
    case invalidRegion(region: String)
    case secretDoesNotExist(secretname: String)
    case invalidOperation  // when trying to retrieve secrets Apple credentials from file
}

// the names we are using to store the secrets
enum AWSSecretsName: String {
    case appleCredentials = "xcodeinstall-apple-credentials"
    case appleSessionToken = "xcodeinstall-apple-session-token"
}

// the data to be stored in Secrets Manager as JSON
struct AppleSessionSecret: Codable, Secrets {
    var rawCookies: String?
    var session: AppleSession?

    func data() throws -&gt; Data </span><span class="c">{
        try JSONEncoder().encode(self)</span><span class="c">
    }</span><span class="">

    func string() throws -&gt; String? </span><span class="c">{
        String(data: try self.data()</span><span class="c">, encoding: .utf8)
    }</span><span class="">

    func cookies() -&gt; [HTTPCookie] </span><span class="c">{
        rawCookies != nil ? </span><span class="c">rawCookies!.cookies()</span><span class="c"> : </span><span class="c">[]</span><span class="c">
    }</span><span class="">

    init(fromData data: Data) throws </span><span class="c">{
        self = try JSONDecoder().decode(AppleSessionSecret.self, from: data)</span><span class="c">
    }</span><span class="">

    init(fromString string: String) throws </span><span class="c">{
        if let data = string.data(using: .utf8) </span><span class="c">{
            try self.init(fromData: data)</span><span class="c">
        }</span><span class="c"> else </span><span class="nc">{
            fatalError(</span><span class="nc">"Can not create data from string : \(string)"</span><span class="nc">)
        }</span><span class="c">
    }</span><span class="">

    init(cookies: String? = nil, session: AppleSession? = nil) </span><span class="c">{
        self.rawCookies = cookies
        self.session = session
    }</span><span class="">

}

// the methods that must be implemented by the class encapsulating the SDK we are using
protocol SecretsStorageAWSSDKProtocol: Sendable {
    static func forRegion(_ region: String, log: Logger) throws -&gt; SecretsStorageAWSSDKProtocol
    func updateSecret&lt;T: Secrets&gt;(secretId: AWSSecretsName, newValue: T) async throws
    func retrieveSecret&lt;T: Secrets&gt;(secretId: AWSSecretsName) async throws -&gt; T
}

// permissions needed
// secretsmanager:CreateSecret
// secretsmanager:TagResource ?
// secretsmanager:GetSecretValue
// secretsmanager:PutSecretValue

@MainActor
class SecretsStorageAWS: SecretsHandlerProtocol {
    let log: Logger
    let awsSDK: SecretsStorageAWSSDKProtocol
    public init(sdk: SecretsStorageAWSSDKProtocol? = nil, region: String = "us-east-1", log: Logger) throws </span><span class="c">{
        self.log = log
        if let sdk </span><span class="c">{
            self.awsSDK = sdk
        }</span><span class="c"> else </span><span class="c">{
            self.awsSDK = try SecretsStorageAWSSoto.forRegion(region, log: self.log)</span><span class="c">
        }</span><span class="c">
    }</span><span class="">

    // MARK: protocol implementation

    // I do not delete the secrets because there is a 30 days deletion policy
    // https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html
    // Instead, I update the secret value with an empty secret
    func clearSecrets() async throws </span><span class="c">{

        let emptySession = AppleSessionSecret()
        try await self.awsSDK.updateSecret(
            secretId: AWSSecretsName.appleSessionToken,
            newValue: emptySession
        )</span><span class="c">

    }</span><span class="">

    func saveCookies(_ cookies: String?) async throws -&gt; String? </span><span class="c">{
        guard let cookieString = cookies else </span><span class="nc">{
            return nil
        }</span><span class="c">

        var result: String? = cookieString

        do </span><span class="c">{

            // read existing cookies and session
            let existingSession: AppleSessionSecret =
                try await self.awsSDK.retrieveSecret(secretId: AWSSecretsName.appleSessionToken)</span><span class="c">

            // append the new cookies and return the whole new thing
            result = try await mergeCookies(
                existingCookies: existingSession.cookies(),
                newCookies: cookies
            )</span><span class="c">

            // create a new session secret object with merged cookies and existing session
            let newSession = AppleSessionSecret(cookies: result, session: existingSession.session)

            // save this new session secret object
            try await self.awsSDK.updateSecret(
                secretId: AWSSecretsName.appleSessionToken,
                newValue: newSession
            )</span><span class="c">

        }</span><span class="c"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"⚠️ can not save cookies file in AWS Secret Manager: \(error)"</span><span class="nc">)
            throw error
        }</span><span class="c">

        return result</span><span class="c">

    }</span><span class="">

    func loadCookies() async throws -&gt; [HTTPCookie] </span><span class="c">{
        do </span><span class="c">{
            let session: AppleSessionSecret = try await self.awsSDK.retrieveSecret(
                secretId: AWSSecretsName.appleSessionToken
            )</span><span class="c">
            let result = session.cookies()
            return result</span><span class="c">
        } catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Error when trying to load session : \(error)"</span><span class="nc">)
            throw error
        }</span><span class="c">
    }</span><span class="">

    func saveSession(_ newSession: AppleSession) async throws -&gt; AppleSession </span><span class="c">{

        do </span><span class="c">{

            // read existing cookies and session
            let existingSession: AppleSessionSecret =
                try await self.awsSDK.retrieveSecret(secretId: AWSSecretsName.appleSessionToken)</span><span class="c">

            // create a new session secret object with existing cookies and new session
            let newSessionSecret = AppleSessionSecret(
                cookies: existingSession.rawCookies,
                session: newSession
            )

            try await self.awsSDK.updateSecret(
                secretId: AWSSecretsName.appleSessionToken,
                newValue: newSessionSecret
            )</span><span class="c">
        }</span><span class="c"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Error when trying to save session : \(error)"</span><span class="nc">)
            throw error
        }</span><span class="c">

        return newSession</span><span class="c">
    }</span><span class="">

    func loadSession() async throws -&gt; AppleSession? </span><span class="c">{

        let sessionSecret: AppleSessionSecret =
            try await self.awsSDK.retrieveSecret(secretId: AWSSecretsName.appleSessionToken)</span><span class="c">
        return sessionSecret.session</span><span class="c">
    }</span><span class="">

    func retrieveAppleCredentials() async throws -&gt; AppleCredentialsSecret </span><span class="nc">{
        do </span><span class="nc">{

            return try await self.awsSDK.retrieveSecret(secretId: AWSSecretsName.appleCredentials)

        }</span><span class="nc"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Error when trying to load session : \(error)"</span><span class="nc">)
            throw error
        }
    }</span><span class="">

    func storeAppleCredentials(_ credentials: AppleCredentialsSecret) async throws </span><span class="c">{
        do </span><span class="c">{

            try await self.awsSDK.updateSecret(
                secretId: AWSSecretsName.appleCredentials,
                newValue: credentials
            )</span><span class="nc">

        }</span><span class="c"> catch </span><span class="c">{
            log.error</span><span class="c">(</span><span class="c">"Error when trying to save credentials : \(error)"</span><span class="c">)
            throw error
        }</span><span class="nc">

    }</span><span class="">

}

</span></pre><pre id="f29" style="display: none"><span>//
//  SecretsStorageFile.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 14/08/2022.
//

import CLIlib
import Foundation
import Logging

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

// store secrets on files in $HOME/.xcodeinstaller
@MainActor
struct SecretsStorageFile: SecretsHandlerProtocol {
    private let log: Logger
    private var fileManager: FileManager
    private var baseDirectory: URL
    private let cookiesPath: URL
    private let sessionPath: URL
    private let newCookiesPath: URL
    private let newSessionPath: URL

    init(log: Logger) </span><span class="c">{
        self.fileManager = FileManager.default
        self.log = log

        baseDirectory = FileHandler(log: self.log).baseFilePath()

        cookiesPath = baseDirectory.appendingPathComponent("cookies")
        sessionPath = baseDirectory.appendingPathComponent("session")

        newCookiesPath = cookiesPath.appendingPathExtension("copy")
        newSessionPath = sessionPath.appendingPathExtension("copy")
    }</span><span class="">

    // used when testing to start from a clean place
    //    func restoreSecrets() {
    //
    //        // remove file
    //        try? fileManager.removeItem(at: sessionPath)
    //
    //        // copy backup to file
    //        try? fileManager.copyItem(at: newSessionPath, to: sessionPath)
    //
    //        // remove backup
    //        try? fileManager.removeItem(at: newSessionPath)
    //
    //        // do it again with cookies file
    //
    //        try? fileManager.removeItem(at: cookiesPath)
    //        try? fileManager.copyItem(at: newCookiesPath, to: cookiesPath)
    //        try? fileManager.removeItem(at: newCookiesPath)
    //
    //    }

    // used when testing to start from a clean place
    //    func clearSecrets(preserve: Bool = false) {
    func clearSecrets() async throws </span><span class="c">{

        //        if preserve {
        //
        //            // move files instead of deleting them (if they exist)
        //            try? fileManager.copyItem(at: cookiesPath, to: newCookiesPath)
        //            try? fileManager.copyItem(at: sessionPath, to: newSessionPath)
        //
        //        }

        try? fileManager.removeItem(at: cookiesPath)
        try? fileManager.removeItem(at: sessionPath)

    }</span><span class="">

    // save cookies in an HTTPUrlResponse
    // save to ~/.xcodeinstall/cookies
    // merge existing cookies into file when file already exists
    func saveCookies(_ cookies: String?) async throws -&gt; String? </span><span class="c">{

        guard let cookieString = cookies else </span><span class="nc">{
            return nil
        }</span><span class="c">

        var result: String? = cookieString

        do </span><span class="c">{

            // if file exists,
            if </span><span class="c">fileManager.fileExists(atPath: cookiesPath.path)</span><span class="c"> </span><span class="c">{

                // load existing cookies as [HTTPCookie]
                let existingCookies = try await self.loadCookies()</span><span class="c">

                // read it, append the new cookies and save the whole new thing
                result = try await mergeCookies(existingCookies: existingCookies, newCookies: cookies)</span><span class="c">
                try result?.data(using: .utf8)!.write(to: cookiesPath)</span><span class="c">

            }</span><span class="c"> else </span><span class="c">{

                // otherwise, just save the cookies
                try cookieString.data(using: .utf8)!.write(to: cookiesPath)</span><span class="c">
            }</span><span class="c">
        }</span><span class="c"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"⚠️ can not write cookies file: \(error)"</span><span class="nc">)
            throw error
        }</span><span class="c">

        return result</span><span class="c">

    }</span><span class="">

    // retrieve cookies
    func loadCookies() async throws -&gt; [HTTPCookie] </span><span class="c">{

        // read the raw file saved on disk
        let cookieLongString = try String(contentsOf: cookiesPath, encoding: .utf8)</span><span class="c">
        let result = cookieLongString.cookies()
        return result</span><span class="c">
    }</span><span class="">

    // save Apple Session values as JSON
    func saveSession(_ session: AppleSession) async throws -&gt; AppleSession </span><span class="c">{

        // save session
        try session.data()</span><span class="c">.write(to: sessionPath)</span><span class="c">

        return session</span><span class="c">
    }</span><span class="">

    // load Apple Session from JSON
    // returns nil when can not read file
    func loadSession() async throws -&gt; AppleSession? </span><span class="c">{

        // read the raw file saved on disk
        let sessionData = try Data(contentsOf: sessionPath)</span><span class="c">
        return try AppleSession(fromData: sessionData)</span><span class="c">
    }</span><span class="">

    //MARK: these operations are only valid on SecretsStorageAWS
    func retrieveAppleCredentials() async throws -&gt; AppleCredentialsSecret </span><span class="nc">{
        throw SecretsStorageAWSError.invalidOperation
    }</span><span class="">
    func storeAppleCredentials(_ credentials: AppleCredentialsSecret) async throws </span><span class="nc">{
        throw SecretsStorageAWSError.invalidOperation
    }</span><span class="">
}

</span></pre><pre id="f30" style="display: none"><span>//
//  File.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 17/05/2025.
//

import Foundation

extension Array {
    func asyncMap&lt;T&gt;(_ transform: @Sendable (Element) async throws -&gt; T) async rethrows -&gt; [T] </span><span class="c">{
        var results = [T]()
        for element in self </span><span class="c">{
            try await results.append(transform(element)</span><span class="c">)
        }</span><span class="c">
        return results</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f31" style="display: none"><span>//
//  FileManagerExtension.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 20/08/2022.
//

import CLIlib
import Foundation
import Logging

// the methods I want to mock for unit testing
protocol FileHandlerProtocol: Sendable {
    func move(from src: URL, to dst: URL) throws
    func fileExists(file: URL, fileSize: Int) -&gt; Bool
    func checkFileSize(file: URL, fileSize: Int) throws -&gt; Bool
    func downloadedFiles() throws -&gt; [String]
    func downloadFilePath(file: DownloadList.File) async -&gt; String
    func downloadFileURL(file: DownloadList.File) async -&gt; URL
    func saveDownloadList(list: DownloadList) throws -&gt; DownloadList
    func loadDownloadList() throws -&gt; DownloadList
    func baseFilePath() -&gt; URL
    func baseFilePath() -&gt; String
    func downloadDirectory() -&gt; URL
}

enum FileHandlerError: Error {
    case fileDoesNotExist
    case noDownloadedList
}

struct FileHandler: FileHandlerProtocol {

    private let log: Logger
    init(log: Logger) </span><span class="c">{
        self.log = log
    }</span><span class="">

    private static let baseDirectory = FileManager.default.homeDirectoryForCurrentUser
        .appendingPathComponent(".xcodeinstall")
    func downloadDirectory() -&gt; URL </span><span class="c">{ FileHandler.baseDirectory.appendingPathComponent("download") }</span><span class="">
    func downloadListPath() -&gt; URL </span><span class="c">{ FileHandler.baseDirectory.appendingPathComponent("downloadList") }</span><span class="">

    func baseFilePath() -&gt; String </span><span class="nc">{
        baseFilePath().path
    }</span><span class="">
    func baseFilePath() -&gt; URL </span><span class="c">{

        // if base directory does not exist, create it
        let fm = FileManager.default  // swiftlint:disable:this identifier_name
        if </span><span class="c">!fm.fileExists(atPath: FileHandler.baseDirectory.path)</span><span class="c"> </span><span class="nc">{
            do </span><span class="nc">{
                try FileManager.default.createDirectory(at: downloadDirectory(), withIntermediateDirectories: true)</span><span class="nc">
            }</span><span class="nc"> catch </span><span class="nc">{
                log.error</span><span class="nc">(</span><span class="nc">"🛑 Can not create base directory : \(FileHandler.baseDirectory.path)\n\(error)"</span><span class="nc">)
            }</span><span class="nc">
        }</span><span class="c">

        return FileHandler.baseDirectory</span><span class="c">
    }</span><span class="">

    func move(from src: URL, to dst: URL) throws </span><span class="c">{
        do </span><span class="c">{
            if </span><span class="c">FileManager.default.fileExists(atPath: dst.path)</span><span class="c"> </span><span class="c">{
                log.debug</span><span class="nc">(</span><span class="nc">"⚠️ File \(dst) exists, I am overwriting it"</span><span class="c">)
                try FileManager.default.removeItem(atPath: dst.path)</span><span class="c">
            }</span><span class="c">

            let dstUrl = URL(fileURLWithPath: dst.path)
            try FileManager.default.moveItem(at: src, to: dstUrl)</span><span class="c">

        }</span><span class="c"> catch </span><span class="c">{
            log.error</span><span class="c">(</span><span class="c">"🛑 Can not move file : \(error)"</span><span class="c">)
            throw error
        }</span><span class="c">
    }</span><span class="">

    func downloadFilePath(file: DownloadList.File) async -&gt; String </span><span class="nc">{
        await downloadFileURL(file: file).path
    }</span><span class="">
    func downloadFileURL(file: DownloadList.File) async -&gt; URL </span><span class="nc">{

        // if download directory does not exist, create it
        if </span><span class="nc">!FileManager.default.fileExists(atPath: downloadDirectory().path)</span><span class="nc"> </span><span class="nc">{
            do </span><span class="nc">{
                try FileManager.default.createDirectory(at: downloadDirectory(), withIntermediateDirectories: true)</span><span class="nc">
            }</span><span class="nc"> catch </span><span class="nc">{
                log.error</span><span class="nc">(</span><span class="nc">
                    </span><span class="nc">"🛑 Can not create base directory : \(downloadDirectory().path)\n\(error)"</span><span class="nc">
                )
            }</span><span class="nc">
        }</span><span class="nc">
        return downloadDirectory().appendingPathComponent(file.filename)</span><span class="nc">

    }</span><span class="">

    /// Check if file exists and has correct size
    ///  - Parameters:
    ///     - filePath the path of the file to verify
    ///     - fileSize the expected size of the file (in bytes).
    ///  - Returns : true when the file exists and has the given size, false otherwise
    ///  - Throws:
    ///     - FileHandlerError.FileDoesNotExist when the file does not exists
    func checkFileSize(file: URL, fileSize: Int) throws -&gt; Bool </span><span class="c">{

        let filePath = file.path

        // file exists ?
        let exists = FileManager.default.fileExists(atPath: filePath)
        if </span><span class="c">!exists</span><span class="c"> </span><span class="c">{ throw FileHandlerError.fileDoesNotExist }</span><span class="c">

        // file size ?
        let attributes = try? FileManager.default.attributesOfItem(atPath: filePath)
        let actualSize = attributes?[.size] as? Int

        // at this stage, we know the file exists, just check size now
        return actualSize == fileSize</span><span class="c">
    }</span><span class="">

    /// Check if file exists and has correct size
    /// - Parameters:
    ///     - filePath the path of the file to verify
    ///     - fileSize the expected size of the file (in bytes).
    ///       when omited, file size is not checked
    func fileExists(file: URL, fileSize: Int = 0) -&gt; Bool </span><span class="c">{

        let filePath = file.path

        let fileExists = FileManager.default.fileExists(atPath: filePath)
        // does the file exists ?
        if </span><span class="c">!fileExists</span><span class="c"> </span><span class="c">{
            return false
        }</span><span class="c">

        // is the file complete ?
        // use try! because I verified if file exists already
        let fileComplete = try? self.checkFileSize(file: file, fileSize: fileSize)

        return (fileSize &gt; 0 ? </span><span class="c">fileComplete ?? </span><span class="nc">false</span><span class="c"> : </span><span class="nc">fileExists</span><span class="c">)</span><span class="c">
    }</span><span class="">

    func downloadedFiles() throws -&gt; [String] </span><span class="nc">{
        do </span><span class="nc">{
            return try FileManager.default.contentsOfDirectory(atPath: downloadDirectory().path)
        }</span><span class="nc"> catch </span><span class="nc">{
            log.debug</span><span class="nc">(</span><span class="nc">"\(error)"</span><span class="nc">)
            throw FileHandlerError.noDownloadedList
        }
    }</span><span class="">

    func saveDownloadList(list: DownloadList) throws -&gt; DownloadList </span><span class="nc">{

        // save list
        let data = try JSONEncoder().encode(list)</span><span class="nc">
        try data.write(to: downloadListPath())</span><span class="nc">

        return list</span><span class="nc">

    }</span><span class="">

    func loadDownloadList() throws -&gt; DownloadList </span><span class="nc">{

        // read the raw file saved on disk
        let listData = try Data(contentsOf: downloadListPath())</span><span class="nc">

        return try JSONDecoder().decode(DownloadList.self, from: listData)</span><span class="nc">
    }</span><span class="">
}

</span></pre><pre id="f32" style="display: none"><span>//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2025 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import protocol Foundation.ContiguousBytes
#endif

@usableFromInline
package struct HexEncoding&lt;Base: Sequence&gt; where Base.Element == UInt8 {
    @usableFromInline
    var base: Base

    @inlinable
    package init(_ base: Base) </span><span class="c">{
        self.base = base
    }</span><span class="">
}

extension HexEncoding: Sequence {
    @usableFromInline
    package typealias Element = UInt8

    @usableFromInline
    package struct Iterator: IteratorProtocol {
        @usableFromInline
        package typealias Element = UInt8

        @usableFromInline
        var base: Base.Iterator
        @usableFromInline
        var _next: UInt8?

        @inlinable
        init(base: Base.Iterator) </span><span class="c">{
            self.base = base
            self._next = nil
        }</span><span class="">

        @inlinable
        package mutating func next() -&gt; UInt8? </span><span class="c">{
            switch </span><span class="c">self._next</span><span class="c"> {
            </span><span class="c">case .none:
                guard let underlying = self.base.next() else </span><span class="c">{
                    return nil
                }</span><span class="c">
                let first = underlying &gt;&gt; 4
                let second = underlying &amp; 0x0F
                self._next = second.makeBase16Ascii()
                return first.makeBase16Ascii()</span><span class="c">

            </span><span class="c">case .some(let next):
                self._next = nil
                return next</span><span class="c">
            }
        }</span><span class="">
    }

    @inlinable
    package func makeIterator() -&gt; Iterator </span><span class="c">{
        Iterator(base: self.base.makeIterator())
    }</span><span class="">
}

extension HexEncoding: Collection where Base: Collection {
    @usableFromInline
    package struct Index: Comparable {
        @inlinable
        init(base: Base.Index, first: Bool) </span><span class="nc">{
            self.base = base
            self.first = first
        }</span><span class="">

        @inlinable
        package static func &lt; (lhs: HexEncoding&lt;Base&gt;.Index, rhs: HexEncoding&lt;Base&gt;.Index) -&gt; Bool </span><span class="nc">{
            if </span><span class="nc">lhs.base &lt; rhs.base</span><span class="nc"> </span><span class="nc">{
                return true
            }</span><span class="nc"> else if </span><span class="nc">lhs.base &gt; rhs.base</span><span class="nc"> </span><span class="nc">{
                return false
            }</span><span class="nc"> else if </span><span class="nc">lhs.first &amp;&amp; </span><span class="nc">!rhs.first</span><span class="nc"> </span><span class="nc">{
                return true
            }</span><span class="nc"> else </span><span class="nc">{
                return false
            }</span><span class="nc">
        }</span><span class="">

        @usableFromInline
        var base: Base.Index
        @usableFromInline
        var first: Bool
    }

    @inlinable
    package var startIndex: Index </span><span class="nc">{
        Index(base: self.base.startIndex, first: true)
    }</span><span class="">

    @inlinable
    package var endIndex: Index </span><span class="nc">{
        Index(base: self.base.endIndex, first: true)
    }</span><span class="">

    @inlinable
    package func index(after i: Index) -&gt; Index </span><span class="nc">{
        if </span><span class="nc">i.first</span><span class="nc"> </span><span class="nc">{
            return Index(base: i.base, first: false)
        }</span><span class="nc"> else </span><span class="nc">{
            return Index(base: self.base.index(after: i.base), first: true)
        }</span><span class="nc">
    }</span><span class="">

    @inlinable
    package subscript(position: Index) -&gt; UInt8 </span><span class="nc">{
        let value = self.base[position.base]
        let base16 = position.first ? </span><span class="nc">value &gt;&gt; 4</span><span class="nc"> : </span><span class="nc">value &amp; 0x0F</span><span class="nc">
        return base16.makeBase16Ascii()
    }</span><span class="">
}

extension UInt8 {
    @inlinable
    func makeBase16Ascii() -&gt; UInt8 </span><span class="c">{
        assert(</span><span class="c">self &lt; 16</span><span class="c">)
        if </span><span class="c">self &lt; 10</span><span class="c"> </span><span class="c">{
            return self + UInt8(ascii: "0")
        }</span><span class="c"> else </span><span class="c">{
            return self - 10 + UInt8(ascii: "a")
        }</span><span class="c">
    }</span><span class="">
}

extension ContiguousBytes {
    /// return a hexEncoded string buffer from an array of bytes
    @_disfavoredOverload
    @inlinable
    public func hexDigest() -&gt; String </span><span class="nc">{
        self.withUnsafeBytes </span><span class="nc">{ ptr in
            ptr.hexDigest()
        }</span><span class="nc">
    }</span><span class="">
}

extension Collection&lt;UInt8&gt; {
    /// return a hexEncoded string buffer from an array of bytes
    @inlinable
    public func hexDigest() -&gt; String </span><span class="c">{
        String(decoding: HexEncoding(self), as: Unicode.UTF8.self)
    }</span><span class="">
}

</span></pre><pre id="f33" style="display: none"><span>//
//  File.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 16/05/2025.
//

import Subprocess

#if canImport(System)
import System
#else
import SystemPackage
#endif

typealias ShellOutput = CollectedResult&lt;StringOutput&lt;Unicode.UTF8&gt;, StringOutput&lt;Unicode.UTF8&gt;&gt;

extension Executable {
    public static func path(_ path: String) -&gt; Self </span><span class="c">{
        Executable.path(FilePath(path))
    }</span><span class="">
}

</span></pre><pre id="f34" style="display: none"><span>//
//  AuthenticateCommand.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 16/08/2022.
//

import Foundation

extension XCodeInstall {

    func authenticate(with authenticationMethod: AuthenticationMethod) async throws </span><span class="nc">{

        let auth = self.env.authenticator

        do </span><span class="nc">{

            // delete previous session, if any
            try await self.env.secrets!.clearSecrets()</span><span class="nc">
            let appleCredentials = try await retrieveAppleCredentials()</span><span class="nc">

            if </span><span class="nc">authenticationMethod == .usernamePassword</span><span class="nc"> </span><span class="nc">{
                display("Authenticating with username and password (likely to fail) ...")
            }</span><span class="nc"> else </span><span class="nc">{
                display("Authenticating...")
            }</span><span class="nc">
            try await auth.startAuthentication(
                with: authenticationMethod,
                username: appleCredentials.username,
                password: appleCredentials.password
            )</span><span class="nc">
            display("✅ Authenticated.")

        }</span><span class="nc"> catch AuthenticationError.invalidUsernamePassword </span><span class="nc">{

            // handle invalid username or password
            display("🛑 Invalid username or password.")

        }</span><span class="nc"> catch AuthenticationError.requires2FA </span><span class="nc">{

            // handle two factors authentication
            try await startMFAFlow()</span><span class="nc">

        }</span><span class="nc"> catch AuthenticationError.serviceUnavailable </span><span class="nc">{

            // service unavailable means that the authentication method requested is not available
            display("🛑 Requested authentication method is not available. Try with SRP.")

        }</span><span class="nc"> catch AuthenticationError.unableToRetrieveAppleServiceKey(let error) </span><span class="nc">{

            // handle connection errors
            display(
                "🛑 Can not connect to Apple Developer Portal.\nOriginal error : \(error?.localizedDescription ?? </span><span class="nc">"nil"</span><span class="nc">)"
            )

        } catch AuthenticationError.notImplemented(let feature) </span><span class="nc">{

            // handle not yet implemented errors
            display(
                "🛑 \(feature) is not yet implemented. Try the next version of xcodeinstall when it will be available."
            )

        }</span><span class="nc"> catch </span><span class="nc">{
            display("🛑 Unexpected Error : \(error)")
        }</span><span class="nc">
    }</span><span class="">

    // retrieve apple developer portal credentials.
    // either from AWS Secrets Manager, either interactively
    private func retrieveAppleCredentials() async throws -&gt; AppleCredentialsSecret </span><span class="nc">{

        var appleCredentials: AppleCredentialsSecret
        do </span><span class="nc">{
            // first try on AWS Secrets Manager
            display("Retrieving Apple Developer Portal credentials...")
            appleCredentials = try await self.env.secrets!.retrieveAppleCredentials()</span><span class="nc">

        }</span><span class="nc"> catch SecretsStorageAWSError.invalidOperation </span><span class="nc">{

            // we have a file secrets handler, prompt for credentials interactively
            appleCredentials = try promptForCredentials()</span><span class="nc">

        }</span><span class="nc"> catch </span><span class="nc">{

            // unexpected errors, do not handle here
            throw error
        }</span><span class="nc">

        return appleCredentials</span><span class="nc">
    }</span><span class="">

    // prompt user for apple developer portal credentials interactively
    private func promptForCredentials() throws -&gt; AppleCredentialsSecret </span><span class="nc">{
        display(
            """
            ⚠️⚠️ We prompt you for your Apple ID username, password, and two factors authentication code.
            These values are not stored anywhere. They are used to get an Apple session ID. ⚠️⚠️

            Alternatively, you may store your credentials on AWS Secrets Manager
            """
        )

        guard
            let username = self.env.readLine.readLine(
                prompt: "⌨️  Enter your Apple ID username: ",
                silent: false
            )
        else </span><span class="nc">{
            throw CLIError.invalidInput
        }</span><span class="nc">

        guard
            let password = self.env.readLine.readLine(
                prompt: "⌨️  Enter your Apple ID password: ",
                silent: true
            )
        else </span><span class="nc">{
            throw CLIError.invalidInput
        }</span><span class="nc">

        return AppleCredentialsSecret(username: username, password: password)</span><span class="nc">
    }</span><span class="">

    // manage the MFA authentication sequence
    private func startMFAFlow() async throws </span><span class="nc">{

        let auth: any AppleAuthenticatorProtocol = self.env.authenticator

        do </span><span class="nc">{

            let codeLength = try await auth.handleTwoFactorAuthentication()</span><span class="nc">
            assert(</span><span class="nc">codeLength &gt; 0</span><span class="nc">)

            let prompt = "🔐 Two factors authentication is enabled, enter your 2FA code: "
            guard let pinCode = self.env.readLine.readLine(prompt: prompt, silent: false) else </span><span class="nc">{
                throw CLIError.invalidInput
            }</span><span class="nc">
            try await auth.twoFactorAuthentication(pin: pinCode)</span><span class="nc">
            display("✅ Authenticated with MFA.")

        }</span><span class="nc"> catch AuthenticationError.requires2FATrustedPhoneNumber </span><span class="nc">{

            display(
                """
                🔐 Two factors authentication is enabled, with 4 digits code and trusted phone numbers.
                This tool does not support SMS MFA at the moment. Please enable 2 factors authentication
                with trusted devices as described here: https://support.apple.com/en-us/HT204915
                """
            )

        }</span><span class="nc">
    }</span><span class="">

}

</span></pre><pre id="f35" style="display: none"><span>//
//  DownloadCommand.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 16/08/2022.
//

import Foundation

extension XCodeInstall {

    // swiftlint:disable: function_parameter_count
    func download(
        fileName: String?,
        force: Bool,
        xCodeOnly: Bool,
        majorVersion: String,
        sortMostRecentFirst: Bool,
        datePublished: Bool
    ) async throws </span><span class="c">{

        let download = self.env.downloader
        var fileToDownload: DownloadList.File
        do </span><span class="c">{

            // when filename was given by user
            if </span><span class="c">fileName != nil</span><span class="c"> </span><span class="c">{

                // search matching filename in the download list cache
                let list = try await download.list(force: force)</span><span class="c">
                if let result = list.find(fileName: fileName!) </span><span class="c">{
                    fileToDownload = result
                }</span><span class="c"> else </span><span class="c">{
                    throw DownloadError.unknownFile(file: fileName!)
                }</span><span class="c">

            }</span><span class="c"> else </span><span class="c">{

                // when no file was given, ask user
                fileToDownload = try await self.askFile(
                    force: force,
                    xCodeOnly: xCodeOnly,
                    majorVersion: majorVersion,
                    sortMostRecentFirst: sortMostRecentFirst,
                    datePublished: datePublished
                )</span><span class="c">
            }</span><span class="c">

            // now we have a filename, let's proceed with download
            let progressBar = self.env.progressBar
            progressBar.define(
                animationType: .percentProgressAnimation,
                message: "Downloading \(fileToDownload.displayName ?? </span><span class="nc">fileToDownload.filename</span><span class="c">)"
            )

            for await progress in try await download.download(file: fileToDownload)</span><span class="c"> </span><span class="nc">{
                var text = "\(progress.bytesWritten/1024/1024) MB"
                text += String(format: " / %.2f MBs", progress.bandwidth)
                progressBar.update(
                    step: Int(progress.bytesWritten / 1024),
                    total: Int(progress.totalBytes / 1024),
                    text: text
                )
            }</span><span class="c">
            progressBar.complete(success: true)

            // check if the downloaded file is complete
            let fh = self.env.fileHandler
            let file: URL = await fh.downloadFileURL(file: fileToDownload)
            let complete = try? self.env.fileHandler.checkFileSize(
                file: file,
                fileSize: fileToDownload.fileSize
            )
            if </span><span class="c">!(complete ?? </span><span class="nc">false</span><span class="c">) </span><span class="nc">{
                display("🛑 Downloaded file has incorrect size, it might be incomplete or corrupted")
            }</span><span class="c"> else </span><span class="c">{
                display("✅ \(fileName ?? </span><span class="c">"file"</span><span class="c">) downloaded")
            }
        }</span><span class="c"> catch DownloadError.zeroOrMoreThanOneFileToDownload(let count) </span><span class="nc">{
            display("🛑 There are \(count) files to download " + "for this component. Not implemented.")
        }</span><span class="c"> catch DownloadError.authenticationRequired </span><span class="nc">{
            display("🛑 Session expired, you neeed to re-authenticate.")
            display("You can authenticate with the command: xcodeinstall authenticate")
        }</span><span class="c"> catch CLIError.invalidInput </span><span class="nc">{
            display("🛑 Invalid input")
        }</span><span class="c"> catch DownloadError.unknownFile(let fileName) </span><span class="c">{
            display("🛑 Unknown file name : \(fileName)")
        }</span><span class="c"> catch </span><span class="nc">{
            display("🛑 Unexpected error : \(error)")
        }</span><span class="c">
    }</span><span class="">

    func askFile(
        force: Bool,
        xCodeOnly: Bool,
        majorVersion: String,
        sortMostRecentFirst: Bool,
        datePublished: Bool
    ) async throws -&gt; DownloadList.File </span><span class="c">{

        let parsedList = try await self.list(
            force: force,
            xCodeOnly: xCodeOnly,
            majorVersion: majorVersion,
            sortMostRecentFirst: sortMostRecentFirst,
            datePublished: datePublished
        )</span><span class="c">

        let response: String? = self.env.readLine.readLine(
            prompt: "⌨️  Which one do you want to download? ",
            silent: false
        )
        guard let number = response,
            let num = Int(number)
        else </span><span class="nc">{

            if </span><span class="nc">(response ?? </span><span class="nc">""</span><span class="nc">) == "" </span><span class="nc">{
                exit(0)
            }</span><span class="nc">
            throw CLIError.invalidInput
        }</span><span class="c">

        if </span><span class="c">parsedList[num].files.count == 1</span><span class="c"> </span><span class="c">{
            return parsedList[num].files[0]
        }</span><span class="c"> else </span><span class="nc">{
            throw DownloadError.zeroOrMoreThanOneFileToDownload(count: parsedList[num].files.count)
        }</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f36" style="display: none"><span>//
//  DownloadListParser.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 24/07/2022.
//

import Foundation

@MainActor
struct DownloadListParser {

    let env: Environment
    let xCodeOnly: Bool
    let majorVersion: String
    let sortMostRecentFirst: Bool

    init(env: Environment, xCodeOnly: Bool = true, majorVersion: String = "13", sortMostRecentFirst: Bool = false) </span><span class="c">{
        self.env = env
        self.xCodeOnly = xCodeOnly
        self.majorVersion = majorVersion
        self.sortMostRecentFirst = sortMostRecentFirst
    }</span><span class="">

    func parse(list: DownloadList?) throws -&gt; [DownloadList.Download] </span><span class="c">{

        guard let list = list?.downloads else </span><span class="nc">{
            throw DownloadError.noDownloadsInDownloadList
        }</span><span class="c">

        // filter on items having Xcode in their name
        let listOfXcode = list.filter </span><span class="c">{ download in
            if </span><span class="c">xCodeOnly</span><span class="c"> </span><span class="c">{
                return download.name.starts(with: "Xcode \(majorVersion)")
            }</span><span class="c"> else </span><span class="c">{
                return download.name.contains("Xcode \(majorVersion)")
            }</span><span class="c">
        }</span><span class="c">

        // sort by date (most recent last)
        let sortedList = listOfXcode.sorted </span><span class="c">{ (downloadA, downloadB) in

            var dateA: String
            var dateB: String

            // select a non nil-date, either Published or Created.
            if let pubDateA = downloadA.datePublished,
                let pubDateB = downloadB.datePublished
            </span><span class="c">{
                dateA = pubDateA
                dateB = pubDateB
            }</span><span class="c"> else </span><span class="nc">{
                dateA = downloadA.dateCreated
                dateB = downloadB.dateCreated
            }</span><span class="c">

            // parse the string and return a date
            if let aAsDate = dateA.toDate(),
                let bAsDate = dateB.toDate()
            </span><span class="c">{
                return self.sortMostRecentFirst ? </span><span class="c">aAsDate &gt; bAsDate</span><span class="c"> : </span><span class="nc">aAsDate &lt; bAsDate</span><span class="c">
            } else </span><span class="nc">{
                // I don't know what to do when we can not parse the date
                return false
            }</span><span class="c">
        }</span><span class="c">

        return sortedList
    }</span><span class="">

    /// Enrich the list of available downloads.
    /// It adds a flag for each file in the list to indicate if the file is already downloaded and available in cache
    func enrich(list: [DownloadList.Download]) async -&gt; [DownloadList.Download] </span><span class="c">{

        await list.asyncMap </span><span class="c">{ download in
            let fileHandler = await self.env.fileHandler

            // swiftlint:disable identifier_name
            let file = download.files[0]

            let fileCopy = file
            let downloadFile: URL = await fileHandler.downloadFileURL(file: fileCopy)
            let exists = fileHandler.fileExists(file: downloadFile, fileSize: file.fileSize)

            // create a copy of the file to be used in the list
            let newFile = DownloadList.File.init(from: file, existInCache: exists)

            // create a copy of the download to be used in the list
            let newDownload = DownloadList.Download(
                from: download,
                replaceWith: newFile
            )

            return newDownload

        }</span><span class="c">
    }</span><span class="">

    func prettyPrint(list: [DownloadList.Download], withDate: Bool = true) -&gt; String </span><span class="c">{

        // var result = ""

        // map returns a [String] each containing a line to display
        let result: String = list.enumerated().map </span><span class="c">{ (index, download) in
            var line: String = ""
            let file = download.files[0]

            // swiftlint:disable line_length
            line +=
                "[\(String(format: "%02d", index))] \(download.name) (\(file.fileSize/1024/1024) Mb) \(file.existInCache ? </span><span class="c">"(*)"</span><span class="c"> : </span><span class="c">""</span><span class="c">)"

            if </span><span class="c">withDate</span><span class="c"> </span><span class="c">{
                if let date = download.datePublished </span><span class="c">{
                    let das = date.toDate()
                    line += " (published on \(das?.formatted(date: .numeric, time: .omitted) ?? </span><span class="nc">""</span><span class="c">))"
                } else </span><span class="nc">{
                    let das = download.dateCreated.toDate()
                    line += " (created on \(das?.formatted(date: .numeric, time: .omitted) ?? </span><span class="nc">""</span><span class="nc">))"
                }</span><span class="c">
            }
            return line
        }</span><span class="c">
        // join all strings in [] with a \n
        .joined(separator: "\n")

        return result
    }</span><span class="">
}

extension String {

    func toDate() -&gt; Date? </span><span class="c">{

        let appleDownloadDateFormatter = DateFormatter()
        appleDownloadDateFormatter.locale = Locale(identifier: "en_US_POSIX")
        appleDownloadDateFormatter.dateFormat = "MM-dd-yy HH:mm"
        //        appleDownloadDateFormatter.timeZone = TimeZone(secondsFromGMT: 0) // assume GMT timezone

        return appleDownloadDateFormatter.date(from: self)
    }</span><span class="">
}

</span></pre><pre id="f37" style="display: none"><span>//
//  InstallCommand.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 22/08/2022.
//

import CLIlib
import Foundation

extension XCodeInstall {

    func install(file: String?) async throws </span><span class="c">{

        let installer = ShellInstaller(env: &amp;self.env, log: self.log)

        // progress bar to report progress feedback
        let progressBar = self.env.progressBar
        progressBar.define(
            animationType: .countingProgressAnimationMultiLine,
            message: "Installing..."
        )

        var fileToInstall: URL?
        do </span><span class="c">{
            // when no file is specified, prompt user to select one
            if </span><span class="c">nil == file</span><span class="c"> </span><span class="nc">{
                fileToInstall = try promptForFile()</span><span class="nc">
            }</span><span class="c"> else </span><span class="c">{
                fileToInstall = FileHandler(log: self.log).downloadDirectory().appendingPathComponent(file!)
            }</span><span class="c">
            log.debug</span><span class="c">(</span><span class="c">"Going to attemp to install \(fileToInstall!.path)"</span><span class="c">)

            try await installer.install(file: fileToInstall!)</span><span class="nc">
            self.env.progressBar.complete(success: true)
            display("✅ \(fileToInstall!) installed")
        }</span><span class="c"> catch CLIError.invalidInput </span><span class="nc">{
            display("🛑 Invalid input")
            self.env.progressBar.complete(success: false)
        }</span><span class="c"> catch FileHandlerError.noDownloadedList </span><span class="nc">{
            display("⚠️ There is no downloaded file to be installed")
            self.env.progressBar.complete(success: false)
        }</span><span class="c"> catch InstallerError.xCodeXIPInstallationError </span><span class="nc">{
            display("🛑 Can not expand XIP file. Is there enough space on / ? (16GiB required)")
            self.env.progressBar.complete(success: false)
        }</span><span class="c"> catch InstallerError.xCodeMoveInstallationError </span><span class="nc">{
            display("🛑 Can not move Xcode to /Applications")
            self.env.progressBar.complete(success: false)
        }</span><span class="c"> catch InstallerError.xCodePKGInstallationError </span><span class="nc">{
            display(
                "🛑 Can not install additional packages."
            )
            self.env.progressBar.complete(success: false)
        }</span><span class="c"> catch InstallerError.unsupportedInstallation </span><span class="c">{
            display(
                "🛑 Unsupported installation type. (We support Xcode XIP files and Command Line Tools PKG)"
            )
            self.env.progressBar.complete(success: false)
        }</span><span class="c"> catch </span><span class="nc">{
            display("🛑 Error while installing \(String(describing: fileToInstall!))")
            log.debug</span><span class="nc">(</span><span class="nc">"\(error)"</span><span class="nc">)
            self.env.progressBar.complete(success: false)
        }</span><span class="c">
    }</span><span class="">

    func promptForFile() throws -&gt; URL </span><span class="c">{

        // list files ready to install
        let installableFiles = try self.env.fileHandler.downloadedFiles()</span><span class="c">.filter(</span><span class="c">{ fileName in
            return fileName.hasSuffix(".xip") || </span><span class="c">fileName.hasSuffix(".dmg")</span><span class="c">
        }</span><span class="c">)

        display("")
        display("👉 Here is the list of available files to install:")
        display("")
        let printableList = installableFiles.enumerated().map(</span><span class="c">{ (index, fileName) in
            return "[\(String(format: "%02d", index))] \(fileName)"
        }</span><span class="c">).joined(separator: "\n")
        display(printableList)
        display("\(installableFiles.count) items")

        let response: String? = self.env.readLine.readLine(
            prompt: "⌨️  Which one do you want to install? ",
            silent: false
        )
        guard let number = response,
            let num = Int(number)
        else </span><span class="nc">{

            if </span><span class="nc">(response ?? </span><span class="nc">""</span><span class="nc">) == "" </span><span class="nc">{
                exit(0)
            }</span><span class="nc">
            throw CLIError.invalidInput
        }</span><span class="c">

        return FileHandler(log: self.log).downloadDirectory().appendingPathComponent(installableFiles[num])</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f38" style="display: none"><span>//
//  ListCommand.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 16/08/2022.
//

import Foundation

extension XCodeInstall {

    func list(
        force: Bool,
        xCodeOnly: Bool,
        majorVersion: String,
        sortMostRecentFirst: Bool,
        datePublished: Bool
    ) async throws -&gt; [DownloadList.Download] </span><span class="c">{

        let download = self.env.downloader

        display("Loading list of available downloads ", terminator: "")
        display(
            "\(force ? </span><span class="nc">"forced download from Apple Developer Portal"</span><span class="c"> : </span><span class="c">"fetched from cache in \(self.env.fileHandler.baseFilePath())"</span><span class="c">)"
        )  // swiftlint:disable:this line_length

        do </span><span class="c">{
            let list = try await download.list(force: force)</span><span class="c">
            display("✅ Done")

            let parser = DownloadListParser(
                env: self.env,
                xCodeOnly: xCodeOnly,
                majorVersion: majorVersion,
                sortMostRecentFirst: sortMostRecentFirst
            )
            let parsedList = try parser.parse(list: list)</span><span class="c">

            // enrich the list to flag files already downloaded
            let enrichedList = await parser.enrich(list: parsedList)

            display("")
            display("👉 Here is the list of available downloads:")
            display("Files marked with (*) are already downloaded in \(self.env.fileHandler.baseFilePath()) ")
            display("")
            let string = parser.prettyPrint(list: enrichedList, withDate: datePublished)
            display(string)
            display("\(enrichedList.count) items")

            return enrichedList</span><span class="c">

        } catch let error as DownloadError </span><span class="nc">{
            switch </span><span class="nc">error</span><span class="nc"> {
            </span><span class="nc">case .authenticationRequired:
                display("🛑 Session expired, you neeed to re-authenticate.")
                display("You can authenticate with the command: xcodeinstall authenticate")
                throw error</span><span class="nc">
            </span><span class="nc">case .accountneedUpgrade(let code, let message):
                display("🛑 \(message) (Apple Portal error code : \(code))")
                throw error</span><span class="nc">
            </span><span class="nc">case .needToAcceptTermsAndCondition:
                display(
                    """
                    🛑 This is a new Apple account, you need first to accept the developer terms of service.
                    Open a session at https://developer.apple.com/register/agree/
                    Read and accept the ToS and try again.
                    """
                )
                throw error</span><span class="nc">
            </span><span class="nc">case .unknownError(let code, let message):
                display("🛑 \(message) (Unhandled download error : \(code))")
                display(
                    "Please file an error report at https://github.com/sebsto/xcodeinstall/issues/new?assignees=&amp;labels=&amp;template=bug_report.md&amp;title="
                )
                throw error</span><span class="nc">
            </span><span class="nc">default:
                display("🛑 Unknown download error : \(error)")
                display(
                    "Please file an error report at https://github.com/sebsto/xcodeinstall/issues/new?assignees=&amp;labels=&amp;template=bug_report.md&amp;title="
                )
                throw error</span><span class="nc">
            }
        }</span><span class="c"> catch </span><span class="nc">{
            display("🛑 Unexpected error : \(error)")
            display(
                "Please file an error repor at https://github.com/sebsto/xcodeinstall/issues/new?assignees=&amp;labels=&amp;template=bug_report.md&amp;title="
            )
            throw error
        }</span><span class="c">

    }</span><span class="">
}

</span></pre><pre id="f39" style="display: none"><span>//
//  SignOutCommand.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 16/08/2022.
//

import Foundation

extension XCodeInstall {

    func signout() async throws </span><span class="nc">{

        let auth = self.env.authenticator

        display("Signing out...")
        try await auth.signout()</span><span class="nc">
        display("✅ Signed out.")

    }</span><span class="">
}

</span></pre><pre id="f40" style="display: none"><span>//
//  StoreSecretsCommand.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 05/09/2022.
//

import Foundation

extension XCodeInstall {

    func storeSecrets() async throws </span><span class="c">{

        let secretsHandler = self.env.secrets!
        do </span><span class="c">{
            // separate func for testability
            let input = try promptForCredentials()</span><span class="c">
            let credentials = AppleCredentialsSecret(username: input[0], password: input[1])

            try await secretsHandler.storeAppleCredentials(credentials)</span><span class="nc">
            display("✅ Credentials are securely stored")

        }</span><span class="c"> catch </span><span class="c">{
            display("🛑 Unexpected error : \(error)")
            throw error
        }</span><span class="nc">

    }</span><span class="">

    func promptForCredentials() throws -&gt; [String] </span><span class="c">{
        display(
            """

            This command captures your Apple ID username and password and store them securely in AWS Secrets Manager.
            It allows this command to authenticate automatically, as long as no MFA is prompted.

            """
        )

        guard
            let username = self.env.readLine.readLine(
                prompt: "⌨️  Enter your Apple ID username: ",
                silent: false
            )
        else </span><span class="nc">{
            throw CLIError.invalidInput
        }</span><span class="c">

        guard
            let password = self.env.readLine.readLine(
                prompt: "⌨️  Enter your Apple ID password: ",
                silent: true
            )
        else </span><span class="nc">{
            throw CLIError.invalidInput
        }</span><span class="c">

        return [username, password]</span><span class="c">
    }</span><span class="">

}

</span></pre><pre id="f41" style="display: none"><span>//
//  XcodeInstall.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 16/08/2022.
//

import CLIlib
import Foundation
import Logging

@MainActor
final class XCodeInstall {

    let log: Logger
    var env: Environment

    public init(log: Logger, env: Environment) </span><span class="c">{
        self.log = log
        self.env = env
    }</span><span class="">

    // display a message to the user
    // avoid having to replicate the \n torough the code
    func display(_ msg: String, terminator: String = "\n") </span><span class="c">{
        self.env.display.display(msg, terminator: terminator)
    }</span><span class="">

}

</span></pre><script>
  (function() {
    var filesEl = document.getElementById('files');
    var selectedEl;
    function select(fileID) {
      if (selectedEl != null) {
        selectedEl.style.display = 'none';
      }
      selectedEl = document.getElementById(fileID);
      if (selectedEl == null) {
        return;
      }
      filesEl.value = fileID;
      selectedEl.style.display = 'block';
      location.hash = fileID;
    }

    if (location.hash !== "") {
      select(location.hash.substr(1));
    }
    if (selectedEl == null) {
      select("f0");
    }

    filesEl.addEventListener('change', function() { 
      select(filesEl.value);
      window.scrollTo(0, 0);
    } , false);
  })();
</script>
</body></html>