<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Coverage</title>
    <style>
      body {
        background: #111;
        color: #888;
        font-family: monospace;
        font-size: 15px;
      }
      nav { position: fixed; top: 0; }
      pre { margin-top: 25px; }
      .c { color: green; }
      .nc { color: red; }
    </style>
  </head>
  <body>
    <nav>
      <select id="files">
        <option value="f0">Sources/xcodeinstall/API/Authentication+Hashcash.swift (78.2%)</option><option value="f1">Sources/xcodeinstall/API/Authentication+MFA.swift (85.6%)</option><option value="f2">Sources/xcodeinstall/API/Authentication+SRP.swift (95.8%)</option><option value="f3">Sources/xcodeinstall/API/Authentication+UsernamePassword.swift (100.0%)</option><option value="f4">Sources/xcodeinstall/API/Authentication.swift (72.3%)</option><option value="f5">Sources/xcodeinstall/API/Download.swift (0.0%)</option><option value="f6">Sources/xcodeinstall/API/DownloadListData.swift (91.3%)</option><option value="f7">Sources/xcodeinstall/API/DownloadManager.swift (36.8%)</option><option value="f8">Sources/xcodeinstall/API/HTTPClient.swift (84.7%)</option><option value="f9">Sources/xcodeinstall/API/Install.swift (79.2%)</option><option value="f10">Sources/xcodeinstall/API/InstallDownloadListExtension.swift (98.2%)</option><option value="f11">Sources/xcodeinstall/API/InstallXcode.swift (11.6%)</option><option value="f12">Sources/xcodeinstall/API/List.swift (0.0%)</option><option value="f13">Sources/xcodeinstall/API/URLLogger.swift (73.0%)</option><option value="f14">Sources/xcodeinstall/API/URLRequestExtension.swift (92.6%)</option><option value="f15">Sources/xcodeinstall/CLI-driver/CLIAuthenticate.swift (79.2%)</option><option value="f16">Sources/xcodeinstall/CLI-driver/CLIDownload.swift (89.7%)</option><option value="f17">Sources/xcodeinstall/CLI-driver/CLIInstall.swift (73.3%)</option><option value="f18">Sources/xcodeinstall/CLI-driver/CLIList.swift (88.9%)</option><option value="f19">Sources/xcodeinstall/CLI-driver/CLIMain.swift (31.9%)</option><option value="f20">Sources/xcodeinstall/CLI-driver/CLIStoreSecrets.swift (77.3%)</option><option value="f21">Sources/xcodeinstall/CLI/NooraDisplay.swift (0.0%)</option><option value="f22">Sources/xcodeinstall/CLI/NooraReadLine.swift (0.0%)</option><option value="f23">Sources/xcodeinstall/CLI/ProgressBar.swift (0.0%)</option><option value="f24">Sources/xcodeinstall/CLI/Protocols.swift (100.0%)</option><option value="f25">Sources/xcodeinstall/Secrets/SecretsHandler.swift (80.3%)</option><option value="f26">Sources/xcodeinstall/Secrets/SecretsStorageAWS+Soto.swift (23.3%)</option><option value="f27">Sources/xcodeinstall/Secrets/SecretsStorageAWS.swift (70.9%)</option><option value="f28">Sources/xcodeinstall/Secrets/SecretsStorageFile.swift (87.4%)</option><option value="f29">Sources/xcodeinstall/Utilities/Array+AsyncMap.swift (100.0%)</option><option value="f30">Sources/xcodeinstall/Utilities/FileHandler.swift (49.2%)</option><option value="f31">Sources/xcodeinstall/Utilities/HexEncoding.swift (57.5%)</option><option value="f32">Sources/xcodeinstall/Utilities/Shell.swift (16.7%)</option><option value="f33">Sources/xcodeinstall/Version.swift (100.0%)</option><option value="f34">Sources/xcodeinstall/xcodeInstall/AuthenticateCommand.swift (55.0%)</option><option value="f35">Sources/xcodeinstall/xcodeInstall/DownloadCommand.swift (65.2%)</option><option value="f36">Sources/xcodeinstall/xcodeInstall/DownloadListParser.swift (88.9%)</option><option value="f37">Sources/xcodeinstall/xcodeInstall/InstallCommand.swift (61.3%)</option><option value="f38">Sources/xcodeinstall/xcodeInstall/ListCommand.swift (46.4%)</option><option value="f39">Sources/xcodeinstall/xcodeInstall/SignOutCommand.swift (70.6%)</option><option value="f40">Sources/xcodeinstall/xcodeInstall/StoreSecretsCommand.swift (83.0%)</option><option value="f41">Sources/xcodeinstall/xcodeInstall/XcodeInstallCommand.swift (100.0%)</option>
      </select>
    </nav><pre id="f0" style="display: none"><span>//
//  Authentication+Hashcash.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 30/10/2024.
//

import Crypto

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension AppleAuthenticator {
    func checkHashcash() async throws -&gt; String </span><span class="c">{

        guard let serviceKey = session.itcServiceKey?.authServiceKey else </span><span class="nc">{
            throw AuthenticationError.unableToRetrieveAppleHashcash(nil)
        }</span><span class="c">

        if </span><span class="c">session.hashcash == nil</span><span class="c"> </span><span class="nc">{
            var hashcash: String

            log.debug</span><span class="nc">(</span><span class="nc">"Requesting data to compute a hashcash"</span><span class="nc">)

            do </span><span class="nc">{
                hashcash = try await getAppleHashcash(itServiceKey: serviceKey)</span><span class="nc">
            }</span><span class="nc"> catch </span><span class="nc">{
                throw AuthenticationError.unableToRetrieveAppleHashcash(error)
            }</span><span class="nc">
            session.hashcash = hashcash
            log.debug</span><span class="nc">(</span><span class="nc">"Got an Apple hashcash : \(hashcash)"</span><span class="nc">)
        }</span><span class="c">

        // hashcash is never nil at this stage
        return session.hashcash!</span><span class="c">
    }</span><span class="">

    internal func getAppleHashcash(itServiceKey: String, date: String? = nil) async throws -&gt; String </span><span class="c">{

        /*
         ‚ûú  ~ curl https://idmsa.apple.com/appleauth/auth/signin?widgetKey=e0b80c3bf78523bfe80974d320935bfa30add02e1bff88ec2166c6bd5a706c42
        
         ...
        
         &lt; X-Apple-HC-Bits: 10
         &lt; X-Apple-HC-Challenge: 0daf59bcaf9d721c0375756c5e404652
        
         ....
         */

        let url =
            "https://idmsa.apple.com/appleauth/auth/signin?widgetKey=\(itServiceKey)"
        let (_, response) = try await apiCall(
            url: url,
            validResponse: .value(200)
        )</span><span class="c">

        guard let hcString = response.allHeaderFields["X-Apple-HC-Bits"] as? String,
            let hcBits = Int(hcString),
            let hcChallenge = response.allHeaderFields["X-Apple-HC-Challenge"] as? String
        else </span><span class="c">{
            throw AuthenticationError.missingHTTPHeaders(
                "Unable to find 'X-Apple-HC-Bits' or 'X-Apple-HC-Challenge' to compute hashcash\n\(response.allHeaderFields)"
            )
        }</span><span class="c">

        log.debug</span><span class="nc">(</span><span class="nc">"Computing hashcash"</span><span class="c">)

        if </span><span class="c">date == nil</span><span class="c"> </span><span class="nc">{
            return Hashcash.make(bits: hcBits, challenge: hcChallenge)
        }</span><span class="c"> else </span><span class="c">{
            // just used for unit tests
            return Hashcash.make(bits: hcBits, challenge: hcChallenge, date: date)
        }</span><span class="c">
    }</span><span class="">
}

/*
 # This App Store Connect hashcash spec was generously donated by...
 #
 #                         __  _
 #    __ _  _ __   _ __   / _|(_)  __ _  _   _  _ __  ___  ___
 #   / _` || '_ \ | '_ \ | |_ | | / _` || | | || '__|/ _ \/ __|
 #  | (_| || |_) || |_) ||  _|| || (_| || |_| || |  |  __/\__ \
 #   \__,_|| .__/ | .__/ |_|  |_| \__, | \__,_||_|   \___||___/
 #         |_|    |_|             |___/
 #
 #
 # &lt;summary&gt;
 #             1:11:20230223170600:4d74fb15eb23f465f1f6fcbf534e5877::6373
 # X-APPLE-HC: 1:11:20230223170600:4d74fb15eb23f465f1f6fcbf534e5877::6373
 #             ^  ^      ^                       ^                     ^
 #             |  |      |                       |                     +-- Counter
 #             |  |      |                       +-- Resource
 #             |  |      +-- Date YYMMDD[hhmm[ss]]
 #             |  +-- Bits (number of leading zeros)
 #             +-- Version
 #
 # We can't use an off-the-shelf Hashcash because Apple's implementation is not quite the same as the spec/convention.
 #  1. The spec calls for a nonce called "Rand" to be inserted between the Ext and Counter. They don't do that at all.
 #  2. The Counter conventionally encoded as base-64 but Apple just uses the decimal number's string representation.
 #
 # Iterate from Counter=0 to Counter=N finding an N that makes the SHA1(X-APPLE-HC) lead with Bits leading zero bits
 #
 #
 # We get the "Resource" from the X-Apple-HC-Challenge header and Bits from X-Apple-HC-Bits
 #
 # &lt;/summary&gt;
 */

struct Hashcash {
    static func make(bits: Int, challenge: String, date d: String? = nil) -&gt; String </span><span class="c">{
        let version = 1

        let date: String
        if </span><span class="c">d != nil</span><span class="c"> </span><span class="c">{
            // we received a date, use it (for testing)
            date = d!
        }</span><span class="c"> else </span><span class="nc">{
            let df = DateFormatter()
            df.dateFormat = "yyyyMMddHHmmss"
            date = df.string(from: Date())
        }</span><span class="c">

        var counter = 0

        while </span><span class="c">true</span><span class="c"> </span><span class="c">{
            let hc = [
                String(version),
                String(bits),
                date,
                challenge,
                ":\(counter)",
            ].joined(separator: ":")

            if let data = hc.data(using: .utf8) </span><span class="c">{
                let hash = Insecure.SHA1.hash(data: data)
                let hashBits = hash.map </span><span class="c">{ String($0, radix: 2).padding(toLength: 8, withPad: "0") }</span><span class="c">.joined()

                if </span><span class="c">hashBits.prefix(bits).allSatisfy(</span><span class="c">{ $0 == "0" }</span><span class="c">) </span><span class="c">{
                    return hc
                }</span><span class="c">
            }</span><span class="c">

            counter += 1
        }</span><span class="nc">
    }</span><span class="">
}

extension String {
    func padding(toLength length: Int, withPad character: Character) -&gt; String </span><span class="c">{
        let paddingCount = length - self.count
        guard paddingCount &gt; 0 else </span><span class="c">{ return self }</span><span class="c">
        return String(repeating: character, count: paddingCount) + self</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f1" style="display: none"><span>//
//  Authentication+MFA.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 22/07/2022.
//


#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

// swiftlint:disable all
/*
 {
 "trustedPhoneNumbers" : [ {
 "numberWithDialCode" : "+33 ‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢ 88",
 "pushMode" : "sms",
 "obfuscatedNumber" : "‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢ 88",
 "lastTwoDigits" : "88",
 "id" : 2
 } ],
 "securityCode" : {
 "length" : 6,
 "tooManyCodesSent" : false,
 "tooManyCodesValidated" : false,
 "securityCodeLocked" : false,
 "securityCodeCooldown" : false
 },
 "authenticationType" : "hsa2",
 "recoveryUrl" : "https://iforgot.apple.com/phone/add?prs_account_nm=sebsto%40mac.com&amp;autoSubmitAccount=true&amp;appId=142",
 "cantUsePhoneNumberUrl" : "https://iforgot.apple.com/iforgot/phone/add?context=cantuse&amp;prs_account_nm=sebsto%40mac.com&amp;autoSubmitAccount=true&amp;appId=142",
 "recoveryWebUrl" : "https://iforgot.apple.com/password/verify/appleid?prs_account_nm=sebsto%40mac.com&amp;autoSubmitAccount=true&amp;appId=142",
 "repairPhoneNumberUrl" : "https://gsa.apple.com/appleid/account/manage/repair/verify/phone",
 "repairPhoneNumberWebUrl" : "https://appleid.apple.com/widget/account/repair?#!repair",
 "aboutTwoFactorAuthenticationUrl" : "https://support.apple.com/kb/HT204921",
 "twoFactorVerificationSupportUrl" : "https://support.apple.com/HT208072",
 "hasRecoveryKey" : true,
 "supportsRecoveryKey" : false,
 "autoVerified" : false,
 "showAutoVerificationUI" : false,
 "supportsCustodianRecovery" : false,
 "hideSendSMSCodeOption" : false,
 "supervisedChangePasswordFlow" : false,
 "supportsRecovery" : true,
 "trustedPhoneNumber" : {
 "numberWithDialCode" : "+33 ‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢ 88",
 "pushMode" : "sms",
 "obfuscatedNumber" : "‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢ 88",
 "lastTwoDigits" : "88",
 "id" : 2
 },
 "hsa2Account" : true,
 "restrictedAccount" : false,
 "managedAccount" : false
 }
 */
// swiftlint:enable all

struct MFAType: Codable {

    struct PhoneNumber: Codable, Sendable {
        let numberWithDialCode: String?
        let pushMode: String?
        let obfuscatedNumber: String?
        let lastTwoDigits: String?
        let id: Int?
    }

    struct SecurityCode: Codable {
        let length: Int?
        let tooManyCodesSent: Bool?
        let tooManyCodesValidated: Bool?
        let securityCodeLocked: Bool?
        let securityCodeCooldown: Bool?
    }

    enum AuthenticationType: String, Codable {
        case hsa
        case hsa2
    }

    let trustedPhoneNumbers: [PhoneNumber]?
    let securityCode: SecurityCode?
    let authenticationType: AuthenticationType?
    let recoveryUrl: String?
    let cantUsePhoneNumberUrl: String?
    let recoveryWebUrl: String?
    let repairPhoneNumberUrl: String?
    let repairPhoneNumberWebUrl: String?
    let aboutTwoFactorAuthenticationUrl: String?
    let twoFactorVerificationSupportUrl: String?
    let hasRecoveryKey: Bool?
    let supportsRecoveryKey: Bool?
    let autoVerified: Bool?
    let showAutoVerificationUI: Bool?
    let supportsCustodianRecovery: Bool?
    let hideSendSMSCodeOption: Bool?
    let supervisedChangePasswordFlow: Bool?
    let supportsRecovery: Bool?
    let trustedPhoneNumber: PhoneNumber?
    let hsa2Account: Bool?
    let restrictedAccount: Bool?
    let managedAccount: Bool?
}

extension AppleAuthenticator {

    // call MFAType API and return the number of digit required for PIN
    func handleTwoFactorAuthentication() async throws -&gt; Int </span><span class="c">{

        let mfaType: MFAType
        do </span><span class="c">{
            mfaType = try await getMFAType()</span><span class="c">
        }</span><span class="c"> catch </span><span class="c">{
            throw AuthenticationError.canNotReadMFATypes
        }</span><span class="c">

        // FIXME: - add support for SMS fallback in case there is no trusted device

        // I should first understand and handle case where there is a 'trustedDevices' in the answer according to
        // https://github.com/fastlane/fastlane/blob/master/spaceship/lib/spaceship/two_step_or_factor_client.rb#L18
        // when there is no 'trustedDevices', we are supposed to fallback to SMS to a phone number
        // but for my account, the API return no 'trustedDevices' but I still receive the code on my mac and iphone

        guard let count = mfaType.trustedPhoneNumbers?.count,
            count &gt; 0,
            let securityCodeLength = mfaType.securityCode?.length
        else </span><span class="c">{
            log.warning</span><span class="c">(</span><span class="c">"‚ö†Ô∏è No Security code length provided in answer"</span><span class="c">)
            throw AuthenticationError.requires2FATrustedPhoneNumber
        }</span><span class="c">

        return securityCodeLength</span><span class="c">

    }</span><span class="">

    /// Parse the MFA type response from Apple and build a list of MFA options
    func buildMFAOptions(from mfaType: MFAType) -&gt; [MFAOption] </span><span class="c">{
        var options: [MFAOption] = []
        let codeLength = mfaType.securityCode?.length ?? </span><span class="c">6</span><span class="c">

        let isThrottled = mfaType.securityCode?.tooManyCodesSent == true
            || </span><span class="c">mfaType.securityCode?.securityCodeCooldown == true</span><span class="c">
            || </span><span class="c">mfaType.securityCode?.securityCodeLocked == true</span><span class="c">

        if </span><span class="c">isThrottled</span><span class="c"> </span><span class="nc">{
            log.warning</span><span class="nc">(</span><span class="nc">
                </span><span class="nc">"‚ö†Ô∏è Apple is throttling verification codes. Trusted device codes may not arrive. Try SMS instead."</span><span class="nc">
            )
        }</span><span class="c">

        // Trusted device is an option unless codes are being throttled
        if </span><span class="c">!isThrottled</span><span class="c">,
           let phoneNumbers = mfaType.trustedPhoneNumbers, !phoneNumbers.isEmpty
        </span><span class="c">{
            options.append(.trustedDevice(codeLength: codeLength))
        }</span><span class="c">

        // Add SMS options for each trusted phone number (unless hidden)
        if </span><span class="c">mfaType.hideSendSMSCodeOption != true</span><span class="c">,
           let phones = mfaType.trustedPhoneNumbers
        </span><span class="c">{
            for phone in phones </span><span class="c">{
                options.append(.sms(phoneNumber: phone, codeLength: codeLength))
            }</span><span class="c">
        }</span><span class="c">

        // If throttled but SMS is also hidden, still offer trusted device as last resort
        if </span><span class="c">options.isEmpty</span><span class="c">,
           let phoneNumbers = mfaType.trustedPhoneNumbers, !phoneNumbers.isEmpty
        </span><span class="nc">{
            options.append(.trustedDevice(codeLength: codeLength))
        }</span><span class="c">

        return options
    }</span><span class="">

    /// Request Apple to send an SMS code to the given phone number
    func requestSMSCode(phoneId: Int) async throws </span><span class="c">{
        struct PhoneId: Codable { let id: Int }
        struct SMSRequest: Codable {
            let phoneNumber: PhoneId
            let mode: String
        }

        let body = SMSRequest(phoneNumber: PhoneId(id: phoneId), mode: "sms")
        let (_, _) = try await apiCall(
            url: "https://idmsa.apple.com/appleauth/auth/verify/phone",
            method: .POST,
            body: try JSONEncoder().encode(body)</span><span class="c">,
            validResponse: .range(200..&lt;300)
        )</span><span class="c">
    }</span><span class="">

    /// Verify an SMS code received on the given phone number
    func verifySMSCode(_ code: String, phoneId: Int) async throws </span><span class="c">{
        struct PhoneId: Codable { let id: Int }
        struct SecurityCode: Codable { let code: String }
        struct SMSVerify: Codable {
            let securityCode: SecurityCode
            let phoneNumber: PhoneId
            let mode: String
        }

        let body = SMSVerify(
            securityCode: SecurityCode(code: code),
            phoneNumber: PhoneId(id: phoneId),
            mode: "sms"
        )
        guard let sessionId = session.xAppleIdSessionId else </span><span class="nc">{
            throw AuthenticationError.missingHTTPHeaders("X-Apple-Id-Session-Id")
        }</span><span class="c">
        let requestHeader = ["X-Apple-Id-Session-Id": sessionId]

        let (_, response) = try await apiCall(
            url: "https://idmsa.apple.com/appleauth/auth/verify/phone/securitycode",
            method: .POST,
            body: try JSONEncoder().encode(body)</span><span class="c">,
            headers: requestHeader,
            validResponse: .range(200..&lt;413)
        )</span><span class="c">

        switch </span><span class="c">response.statusCode</span><span class="c"> {
        </span><span class="c">case 400:
            throw AuthenticationError.invalidPinCode</span><span class="c">
        </span><span class="c">case 412:
            if let location = response.value(forHTTPHeaderField: "Location") </span><span class="c">{
                throw AuthenticationError.accountNeedsRepair(location: location, repairToken: "secret")
            }</span><span class="c"> else </span><span class="nc">{
                throw AuthenticationError.accountNeedsRepair(
                    location: "no location HTTP header",
                    repairToken: "secret"
                )
            }</span><span class="c">
        </span><span class="c">case 200, 204:
            try await self.saveSession(response: response, session: session)</span><span class="c">
        </span><span class="c">default:
            throw AuthenticationError.unexpectedHTTPReturnCode(code: response.statusCode)</span><span class="c">
        }</span><span class="c">
    }</span><span class="">

    func twoFactorAuthentication(pin: String) async throws </span><span class="c">{

        struct TFACode: Codable {
            let code: String
        }
        struct TFABody: Codable {
            let securityCode: TFACode
        }

        let codeType = "trusteddevice"
        let body = TFABody(securityCode: TFACode(code: pin))
        guard let sessionId = session.xAppleIdSessionId else </span><span class="nc">{
            throw AuthenticationError.missingHTTPHeaders("X-Apple-Id-Session-Id")
        }</span><span class="c">
        let requestHeader = ["X-Apple-Id-Session-Id": sessionId]

        let (_, response) = try await apiCall(
            url: "https://idmsa.apple.com/appleauth/auth/verify/\(codeType)/securitycode",  // swiftlint:disable:this line_length
            method: .POST,
            body: try JSONEncoder().encode(body)</span><span class="c">,
            headers: requestHeader,
            validResponse: .range(200..&lt;413)
        )</span><span class="c">

        switch </span><span class="c">response.statusCode</span><span class="c"> {
        </span><span class="nc">case 400:
            // authentication failed
            throw AuthenticationError.invalidPinCode</span><span class="c">

        </span><span class="nc">case 412:
            // upgrade account and repair with repair token
            // see https://my.diffend.io/gems/fastlane/2.170.0/2.175.0/page/9#d2h-629314-4781
            if let location = response.value(forHTTPHeaderField: "Location") </span><span class="nc">{
                throw AuthenticationError.accountNeedsRepair(location: location, repairToken: "secret")  // X-Apple-Repair-Session-Token
            }</span><span class="nc"> else </span><span class="nc">{
                throw AuthenticationError.accountNeedsRepair(
                    location: "no location HTTP header",
                    repairToken: "secret"
                )  // X-Apple-Repair-Session-Token
            }</span><span class="c">

        </span><span class="c">case 200, 204:
            // success
            try await self.saveSession(response: response, session: session)</span><span class="c">

        </span><span class="nc">default:
            // unknown error, fail gracefully
            throw AuthenticationError.unexpectedHTTPReturnCode(code: response.statusCode)</span><span class="c">

        }</span><span class="c">

        // should we save additional cookies ?
        // return (try await getDESCookie(), session)

    }</span><span class="">

    func getMFAType() async throws -&gt; MFAType </span><span class="c">{

        let (data, _) = try await apiCall(
            url: "https://idmsa.apple.com/appleauth/auth",
            validResponse: .range(200..&lt;400)
        )</span><span class="c">

        guard let mfaType = try? JSONDecoder().decode(MFAType.self, from: data) else </span><span class="c">{
            throw AuthenticationError.canNotReadMFATypes
        }</span><span class="c">

        return mfaType</span><span class="c">

    }</span><span class="">
}

</span></pre><pre id="f2" style="display: none"><span>//
//  Authentication+SRP.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 30/10/2024.
//

import Crypto
import SRP
import _CryptoExtras

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension AppleAuthenticator {
    func startSRPAuthentication(username: String, password: String) async throws </span><span class="c">{

        let hashcash = try await self.checkHashcash()</span><span class="c">

        // signification of variables : https://blog.uniauth.com/what-is-secure-remote-password

        let configuration = SRPConfiguration&lt;SHA256&gt;(.N2048)
        let client = SRPClient(configuration: configuration)
        let clientKeys = client.generateKeys()

        let A = clientKeys.public

        let (data, _) =
            try await apiCall(
                url: "https://idmsa.apple.com/appleauth/auth/signin/init",
                method: .POST,
                body: try JSONEncoder().encode(AppleSRPInitRequest(a: A.base64, accountName: username))</span><span class="c">,
                validResponse: .range(0..&lt;506)
            )</span><span class="c">

        //TODO: throw error when statusCode is not 200
        let srpResponse = try JSONDecoder().decode(AppleSRPInitResponse.self, from: data)</span><span class="c">

        let key_length = 32
        let iterations = srpResponse.iteration
        let salt = srpResponse.saltBytes()
        let B = srpResponse.b  // server public key
        let c = srpResponse.c  //what is c ?

        let serverPublicKey = SRPKey(base64: B)!  //TODO: remove !

        let derivedPassword: [UInt8] = try PBKDF2.pbkdf2(
            password: password,
            salt: salt,
            iterations: iterations,
            keyLength: key_length,
            srpProtocol: srpResponse.protocol
        )</span><span class="c">

        let sharedSecret = try client.calculateSharedSecret(
            password: derivedPassword,
            salt: salt,
            clientKeys: clientKeys,
            serverPublicKey: serverPublicKey
        )</span><span class="c">
        let clientProof = client.calculateClientProof(
            username: username,
            salt: salt,
            clientPublicKey: clientKeys.public,
            serverPublicKey: serverPublicKey,
            sharedSecret: sharedSecret
        )

        let m1 = clientProof
        let m2: [UInt8] = client.calculateServerProof(
            clientPublicKey: clientKeys.public,
            clientProof: m1,
            sharedSecret: sharedSecret
        )

        //TODO: I must verify the server proof at some point
        //try client.verifyServerProof(serverProof: ??, clientProof: m1, clientKeys: clientKeys, sharedSecret: sharedSecret)

        let (_, response) =
            try await apiCall(
                url: "https://idmsa.apple.com/appleauth/auth/signin/complete?isRememberMeEnabled=false",
                method: .POST,
                body: try JSONEncoder().encode(
                    AppleSRPCompleteRequest(accountName: username, c: c, m1: m1.base64, m2: m2.base64)
                )</span><span class="c">,
                headers: ["X-Apple-HC": hashcash],
                validResponse: .range(0..&lt;506)
            )</span><span class="c">

        // store the response to keep cookies and HTTP headers
        session.xAppleIdSessionId = response.value(forHTTPHeaderField: "X-Apple-ID-Session-Id")
        session.scnt = response.value(forHTTPHeaderField: "scnt")

        try await handleResponse(response)</span><span class="c">

    }</span><span class="">
}

/*
 {
 "protocols": [
 "s2k",
 "s2k_fo"
 ],
 "a": "5DiL4KfAjhfeVN5dkrPD0Ykc9rhOvbSUlJel9miq8fI=",
 "accountName": "xxx@me.com"
 }
 */
struct AppleSRPInitRequest: Encodable {
    let a: String
    let accountName: String
    let protocols: [String] = </span><span class="nc">["s2k", "s2k_fo"]</span><span class="">
}

/*
 {
 "iteration" : 1160,
 "salt" : "iVGSz0+eXAe5jzBsuSH9Gg==",
 "protocol" : "s2k_fo",
 "b" : "feF9PcfeU6pKeZb27kxM080eOPvg0wZurW6sGglwhIi63VPyQE1FfU1NKdU5bRHpGYcz23AKetaZWX6EqlIUYsmguN7peY9OU74+V16kvPaMFtSvS4LUrl8W+unt2BTlwRoINTYVgoIiLwXFKAowH6dA9HGaOy8TffKw/FskGK1rPqf8TZJ3IKWk6LA8AAvNhQhaH2/rdtdysJpV+T7eLpoMlcILWCOVL1mzAeTr3lMO4UdcnPokjWIoHIEJXDF8XekRbqSeCZvMlZBP1qSeRFwPuxz//doEk0AS2wU2sZFinPmfz4OV2ESQ4j9lfxE+NvapT+fPAmEUysUL61piMw==",
 "c" : "d-74e-7f288e09-93e6-11ef-9a9c-278293010698:PRN"
 }
 */
struct AppleSRPInitResponse: Decodable {
    let iteration: Int
    let salt: String
    let `protocol`: SRPProtocol
    let b: String
    let c: String
    func saltBytes() -&gt; [UInt8] </span><span class="c">{ Array(Data(base64Encoded: salt)!) }</span><span class="">
    func bBytes() -&gt; Data? </span><span class="nc">{ Data(base64Encoded: b) }</span><span class="">
}

public enum SRPProtocol: String, Sendable, Codable {
    case s2k, s2k_fo
}

struct AppleSRPCompleteRequest: Encodable {
    let accountName: String
    let c: String
    let m1: String
    let m2: String
    let rememberMe: Bool = </span><span class="nc">false</span><span class="">
}

extension SRPKey {
    public var base64: String </span><span class="c">{
        Data(self.bytes).base64EncodedString()
    }</span><span class="">
    public init?(base64: String) </span><span class="c">{
        guard let data = Data(base64Encoded: base64) else </span><span class="nc">{ return nil }</span><span class="c">
        self.init(Array(data))
    }</span><span class="">
}

extension Array where Element == UInt8 {
    public var base64: String </span><span class="c">{
        Data(self).base64EncodedString()
    }</span><span class="">
}
extension String {
    public var array: [UInt8] </span><span class="c">{
        Array(self.utf8)
    }</span><span class="">
}

struct PBKDF2 {
    static func pbkdf2(
        password: String,
        salt: [UInt8],
        iterations: Int,
        keyLength: Int,
        srpProtocol: SRPProtocol
    ) throws -&gt; [UInt8] </span><span class="c">{
        if let pwdData = password.data(using: .utf8) </span><span class="c">{
            return try pbkdf2(
                password: [UInt8](pwdData),
                salt: salt,
                iterations: iterations,
                keyLength: keyLength,
                srpProtocol: srpProtocol
            )
        }</span><span class="c"> else </span><span class="nc">{
            fatalError()
        }</span><span class="nc">
    }</span><span class="">
    static func pbkdf2(
        password: [UInt8],
        salt: [UInt8],
        iterations: Int,
        keyLength: Int,
        srpProtocol: SRPProtocol
    ) throws -&gt; [UInt8] </span><span class="c">{

        // when server asks s2k protocol, use a SHA256 hash of the password
        // when server asks s2k_fo protocol, we must use a Hex encoded string of the hash of the password
        let passwordHash: Data
        switch </span><span class="c">srpProtocol</span><span class="c"> {
        </span><span class="c">case .s2k:
            passwordHash = Data(SHA256.hash(data: Data(password)))</span><span class="c">
        </span><span class="c">case .s2k_fo:
            passwordHash = Data(
                Data(SHA256.hash(data: Data(password)))
                    .hexDigest()
                    .lowercased().utf8
            )</span><span class="c">
        }</span><span class="c">

        var result: [UInt8] = []
        try KDF.Insecure.PBKDF2.deriveKey(
            from: passwordHash,
            salt: salt,
            using: .sha256,
            outputByteCount: keyLength,
            // Swift-Crypto recommends 210000 or more rounds.  Apple's SRP uses less
            unsafeUncheckedRounds: iterations
        )</span><span class="c">.withUnsafeBytes </span><span class="c">{
            result.append(contentsOf: $0)
        }</span><span class="c">
        return result
    }</span><span class="">

}

</span></pre><pre id="f3" style="display: none"><span>//
//  Authentication+UsernamePassword.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 30/10/2024.
//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension AppleAuthenticator {
    func startUserPasswordAuthentication(username: String, password: String) async throws </span><span class="c">{

        let _ = try await self.checkHashcash()</span><span class="c">

        let (_, response) =
            try await apiCall(
                url: "https://idmsa.apple.com/appleauth/auth/signin",
                method: .POST,
                body: try JSONEncoder().encode(User(accountName: username, password: password))</span><span class="c">,
                validResponse: .range(0..&lt;506)
            )</span><span class="c">

        // store the response to keep cookies and HTTP headers
        session.xAppleIdSessionId = response.value(forHTTPHeaderField: "X-Apple-ID-Session-Id")
        session.scnt = response.value(forHTTPHeaderField: "scnt")

        // should I save other headers ?
        // X-Apple-Auth-Attributes

        try await handleResponse(response)</span><span class="c">

    }</span><span class="">
}

</span></pre><pre id="f4" style="display: none"><span>//
//  Authentication.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 18/07/2022.
//


#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

// MARK: - Module Internal structures and data

enum AuthenticationMethod {
    case usernamePassword
    case srp

    static func withSRP(_ srp: Bool) -&gt; AuthenticationMethod </span><span class="c">{ srp ? </span><span class="c">.srp</span><span class="c"> : </span><span class="c">.usernamePassword</span><span class="c"> }</span><span class="">
}

struct User: Codable {
    var accountName: String
    var password: String
    var rememberMe = </span><span class="c">false</span><span class="">
}

enum AuthenticationError: Error, Equatable {

    case invalidUsernamePassword
    case requires2FA
    //    case requires2FATrustedDevice
    case requires2FATrustedPhoneNumber
    case invalidPinCode
    case unableToRetrieveAppleServiceKey(Error?)
    case unableToRetrieveAppleHashcash(Error?)
    case missingHTTPHeaders(String)
    case canNotReadMFATypes
    case accountNeedsRepair(location: String, repairToken: String)
    case serviceUnavailable  //503
    case notImplemented(featureName: String)  // temporray while I'm working on a feature
    case unexpectedHTTPReturnCode(code: Int)
    case other(error: Error)

    static func == (lhs: AuthenticationError, rhs: AuthenticationError) -&gt; Bool </span><span class="c">{
        switch </span><span class="c">(lhs, rhs)</span><span class="c"> {
        </span><span class="c">case (.invalidUsernamePassword, .invalidUsernamePassword):
            return true</span><span class="c">
        </span><span class="c">case (.requires2FA, .requires2FA):
            return true</span><span class="c">
        </span><span class="c">case (.requires2FATrustedPhoneNumber, .requires2FATrustedPhoneNumber):
            return true</span><span class="c">
        </span><span class="c">case (.invalidPinCode, .invalidPinCode):
            return true</span><span class="c">
        </span><span class="c">case (.unableToRetrieveAppleServiceKey, .unableToRetrieveAppleServiceKey):
            return true</span><span class="c">  // Can't compare errors, so just check the case
        </span><span class="nc">case (.unableToRetrieveAppleHashcash, .unableToRetrieveAppleHashcash):
            return true</span><span class="c">  // Can't compare errors, so just check the case
        </span><span class="nc">case let (.missingHTTPHeaders(a), .missingHTTPHeaders(b)):
            return a == b</span><span class="c">
        </span><span class="c">case (.canNotReadMFATypes, .canNotReadMFATypes):
            return true</span><span class="c">
        </span><span class="c">case let (.accountNeedsRepair(locationA, repairTokenA), .accountNeedsRepair(locationB, repairTokenB)):
            return locationA == locationB &amp;&amp; </span><span class="c">repairTokenA == repairTokenB</span><span class="c">
        </span><span class="nc">case (.serviceUnavailable, .serviceUnavailable):
            return true</span><span class="c">
        </span><span class="nc">case let (.notImplemented(featureNameA), .notImplemented(featureNameB)):
            return featureNameA == featureNameB</span><span class="c">
        </span><span class="c">case let (.unexpectedHTTPReturnCode(codeA), .unexpectedHTTPReturnCode(codeB)):
            return codeA == codeB</span><span class="c">
        </span><span class="nc">case (.other, .other):
            return true</span><span class="c">  // Can't compare errors, so just check the case
        </span><span class="c">default:
            return false</span><span class="c">
        }
    }</span><span class="">
}

struct AppleServiceKey: Codable, Equatable {
    let authServiceUrl: String
    let authServiceKey: String

    static func == (lhs: AppleServiceKey, rhs: AppleServiceKey) -&gt; Bool </span><span class="c">{
        lhs.authServiceKey == rhs.authServiceKey &amp;&amp; </span><span class="c">lhs.authServiceUrl == rhs.authServiceUrl</span><span class="c">
    }</span><span class="">
}

struct AppleSession: Codable, Equatable {
    var itcServiceKey: AppleServiceKey?
    var xAppleIdSessionId: String? = </span><span class="c">nil</span><span class="">
    var scnt: String? = </span><span class="c">nil</span><span class="">
    var hashcash: String? = </span><span class="c">nil</span><span class="">

    static func == (lhs: AppleSession, rhs: AppleSession) -&gt; Bool </span><span class="c">{
        lhs.itcServiceKey == rhs.itcServiceKey &amp;&amp; </span><span class="c">lhs.xAppleIdSessionId == rhs.xAppleIdSessionId</span><span class="c">
            &amp;&amp; </span><span class="c">lhs.scnt == rhs.scnt</span><span class="c"> &amp;&amp; </span><span class="c">lhs.hashcash == rhs.hashcash</span><span class="c">
    }</span><span class="">

    func data() throws -&gt; Data </span><span class="c">{
        try JSONEncoder().encode(self)</span><span class="c">
    }</span><span class="">

    func string() throws -&gt; String? </span><span class="nc">{
        String(data: try self.data()</span><span class="nc">, encoding: .utf8)
    }</span><span class="">

    init(fromData data: Data) throws </span><span class="c">{
        self = try JSONDecoder().decode(AppleSession.self, from: data)</span><span class="c">
    }</span><span class="">

    init(
        itcServiceKey: AppleServiceKey? = nil,
        xAppleIdSessionId: String? = nil,
        scnt: String? = nil,
        hashcash: String? = nil
    ) </span><span class="c">{
        self.itcServiceKey = itcServiceKey
        self.xAppleIdSessionId = xAppleIdSessionId
        self.scnt = scnt
        self.hashcash = hashcash
    }</span><span class="">
}

// MARK: - AuthenticationDelegate

/// Verification methods the user can choose from
enum MFAOption: Sendable {
    case trustedDevice(codeLength: Int)
    case sms(phoneNumber: MFAType.PhoneNumber, codeLength: Int)
}

/// Delegate that the authenticator calls when it needs user interaction
protocol AuthenticationDelegate: Sendable {
    /// Called when credentials are needed (username/password)
    func requestCredentials() async throws -&gt; (username: String, password: String)

    /// Called when MFA is required. Presents available options and returns the chosen option + code.
    func requestMFACode(options: [MFAOption]) async throws -&gt; (option: MFAOption, code: String)
}

/**
 Manage authentication with an Apple ID
 */

protocol AppleAuthenticatorProtocol: Sendable {

    /// Runs the full authentication flow, including MFA if needed.
    /// Uses the delegate for any user interaction.
    func authenticate(
        with method: AuthenticationMethod,
        delegate: AuthenticationDelegate
    ) async throws

    // legacy methods ‚Äî kept for backward compatibility
    func startAuthentication(
        with: AuthenticationMethod,
        username: String,
        password: String
    )
        async throws
    func signout() async throws

    // multi-factor authentication
    func handleTwoFactorAuthentication() async throws -&gt; Int
    func twoFactorAuthentication(pin: String) async throws
}

//FIXME: TODO: split into two classes : UsernamePasswordAuthenticator and SRPAuthenticator
class AppleAuthenticator: HTTPClient, AppleAuthenticatorProtocol {

    func authenticate(
        with method: AuthenticationMethod,
        delegate: AuthenticationDelegate
    ) async throws </span><span class="nc">{
        let (username, password) = try await delegate.requestCredentials()</span><span class="nc">

        do </span><span class="nc">{
            try await startAuthentication(with: method, username: username, password: password)</span><span class="nc">
        }</span><span class="nc"> catch AuthenticationError.requires2FA </span><span class="nc">{
            try await performMFA(delegate: delegate)</span><span class="nc">
        }</span><span class="nc">
    }</span><span class="">

    private func performMFA(delegate: AuthenticationDelegate) async throws </span><span class="nc">{
        let mfaType = try await getMFAType()</span><span class="nc">
        let options = buildMFAOptions(from: mfaType)

        guard !options.isEmpty else </span><span class="nc">{
            throw AuthenticationError.requires2FATrustedPhoneNumber
        }</span><span class="nc">

        let (chosen, code) = try await delegate.requestMFACode(options: options)</span><span class="nc">

        switch </span><span class="nc">chosen</span><span class="nc"> {
        </span><span class="nc">case .trustedDevice:
            try await twoFactorAuthentication(pin: code)</span><span class="nc">
        </span><span class="nc">case .sms(let phone, let codeLength):
            guard let phoneId = phone.id else </span><span class="nc">{
                throw AuthenticationError.requires2FATrustedPhoneNumber
            }</span><span class="nc">
            // Send the SMS
            try await requestSMSCode(phoneId: phoneId)</span><span class="nc">
            // Ask for the code (the delegate will prompt the user for the code they received)
            let (_, smsCode) = try await delegate.requestMFACode(options: [.sms(phoneNumber: phone, codeLength: codeLength)])</span><span class="nc">
            try await verifySMSCode(smsCode, phoneId: phoneId)</span><span class="nc">
        }</span><span class="nc">
    }</span><span class="">

    func startAuthentication(
        with authenticationMethod: AuthenticationMethod,
        username: String,
        password: String
    ) async throws </span><span class="c">{
        try await checkServiceKey()</span><span class="c">

        switch </span><span class="c">authenticationMethod</span><span class="c"> {
        </span><span class="c">case .usernamePassword:
            try await self.startUserPasswordAuthentication(username: username, password: password)</span><span class="c">
        </span><span class="c">case .srp:
            try await self.startSRPAuthentication(username: username, password: password)</span><span class="c">
        }</span><span class="c">
    }</span><span class="">

    // this is mainly for functional testing, it invalidates the session and force a full re-auth aftewards
    func signout() async throws </span><span class="c">{

        let (_, _) = try await apiCall(
            url: "https://idmsa.apple.com/appleauth/signout",
            validResponse: .range(0..&lt;500)
        )</span><span class="c">

        try await self.secrets.clearSecrets()</span><span class="c">

    }</span><span class="">

    // MARK: - Private structures and data

    func checkServiceKey() async throws </span><span class="c">{
        if </span><span class="c">session.itcServiceKey == nil</span><span class="c"> </span><span class="c">{
            var appServiceKey: AppleServiceKey
            do </span><span class="c">{
                appServiceKey = try await getAppleServicekey()</span><span class="nc">
            }</span><span class="c"> catch </span><span class="c">{
                throw AuthenticationError.unableToRetrieveAppleServiceKey(error)
            }</span><span class="nc">
            session.itcServiceKey = appServiceKey
            log.debug</span><span class="nc">(</span><span class="nc">"Got an Apple Service key : \(String(describing: session.itcServiceKey))"</span><span class="nc">)
        }</span><span class="c">
    }</span><span class="">

    // by OOP design it should be private.
    internal func getAppleServicekey() async throws -&gt; AppleServiceKey </span><span class="c">{

        /*
         ‚ûú  ~ curl https://appstoreconnect.apple.com/olympus/v1/app/config\?hostname\=itunesconnect.apple.com
         {
         "authServiceUrl" : "https://idmsa.apple.com/appleauth",
         "authServiceKey" : "e0b80c3bf78523bfe80974d320935bfa30add02e1bff88ec2166c6bd5a706c42"
         }
         */

        let url =
            "https://appstoreconnect.apple.com/olympus/v1/app/config?hostname=itunesconnect.apple.com"
        let (data, _) = try await apiCall(
            url: url,
            validResponse: .range(200..&lt;400)  //FIXME: should this be .value(200) ?
        )</span><span class="c">

        return try JSONDecoder().decode(AppleServiceKey.self, from: data)</span><span class="c">
    }</span><span class="">

    func handleResponse(_ response: HTTPURLResponse) async throws </span><span class="c">{
        switch </span><span class="c">response.statusCode</span><span class="c"> {

        </span><span class="c">case 200:
            // we were already authenticated
            try await self.saveSession(response: response, session: session)</span><span class="c">

        </span><span class="c">case 401, 403:
            // invalid username or password
            throw AuthenticationError.invalidUsernamePassword</span><span class="c">

        </span><span class="nc">case 409:
            // requires two-factors authentication
            throw AuthenticationError.requires2FA</span><span class="c">

        </span><span class="nc">case 503:
            // service unavailable. Most probably teh requested Authentication method is not supported
            throw AuthenticationError.serviceUnavailable</span><span class="c">

        </span><span class="c">default:
            log.critical</span><span class="c">(</span><span class="c">"üí£ Unexpected return code : \(response.statusCode)"</span><span class="c">)
            log.debug</span><span class="nc">(</span><span class="nc">"URLResponse = \(response)"</span><span class="c">)
            throw AuthenticationError.unexpectedHTTPReturnCode(code: response.statusCode)</span><span class="c">
        }</span><span class="c">
    }</span><span class="">

    func saveSession(response: HTTPURLResponse, session: AppleSession) async throws </span><span class="c">{
        guard let cookies = response.value(forHTTPHeaderField: "Set-Cookie") else </span><span class="c">{
            log.debug</span><span class="nc">(</span><span class="nc">"No cookies set, just saving the session"</span><span class="c">)
            _ = try await self.secrets.saveSession(session)</span><span class="c">
            return</span><span class="c">
        }</span><span class="c">

        // save session data to reuse in future invocation
        _ = try await self.secrets.saveCookies(cookies)</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f5" style="display: none"><span>//
//  Download.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 19/07/2022.
//

import Logging

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

enum ListSource {
    case cache
    case network
}

protocol AppleDownloaderProtocol: Sendable {
    func list(force: Bool) async throws -&gt; (DownloadList, ListSource)
    func download(file: DownloadList.File) async throws -&gt; AsyncThrowingStream&lt;DownloadProgress, Error&gt;
}

class AppleDownloader: HTTPClient, AppleDownloaderProtocol {

    let fileHandler: FileHandlerProtocol

    init(
        secrets: SecretsHandlerProtocol,
        urlSession: URLSessionProtocol,
        fileHandler: FileHandlerProtocol,
        log: Logger
    ) </span><span class="nc">{
        self.fileHandler = fileHandler
        super.init(secrets: secrets, urlSession: urlSession, log: log)
    }</span><span class="">

    func download(file: DownloadList.File) async throws -&gt; AsyncThrowingStream&lt;DownloadProgress, Error&gt; </span><span class="nc">{

        guard !file.remotePath.isEmpty,
            !file.filename.isEmpty,
            file.fileSize &gt; 0
        else </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"üõë Invalid file specification : \(file)"</span><span class="nc">)
            throw DownloadError.invalidFileSpec
        }</span><span class="nc">

        let fileURL = "https://developer.apple.com/services-account/download?path=\(file.remotePath)"

        let filePath = await URL(fileURLWithPath: fileHandler.downloadFilePath(file: file))
        let downloadTarget = DownloadTarget(totalFileSize: file.fileSize, dstFilePath: filePath, startTime: Date.now)

        let downloadManager = DownloadManager(logger: log)
        return try await downloadManager.download(
            from: fileURL,
            target: downloadTarget,
            secrets: self.secrets,
            fileHandler: self.fileHandler
        )</span><span class="nc">
    }</span><span class="">

}

</span></pre><pre id="f6" style="display: none"><span>//
//  DownloadListData.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 21/08/2022.
//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

enum DownloadError: Error, Equatable {
    case authenticationRequired
    case unknownError(errorCode: Int, errorMessage: String)
    case parsingError(error: Error?)
    case noDownloadsInDownloadList
    case invalidFileSpec
    case invalidResponse
    case unknownFile(file: String)
    case needToAcceptTermsAndCondition
    case accountNeedUpgrade(errorCode: Int, errorMessage: String)

    static func == (lhs: DownloadError, rhs: DownloadError) -&gt; Bool </span><span class="c">{
        switch </span><span class="c">(lhs, rhs)</span><span class="c"> {
        </span><span class="c">case (.authenticationRequired, .authenticationRequired):
            return true</span><span class="c">
        </span><span class="c">case let (.unknownError(code1, _), .unknownError(code2, _)):
            return code1 == code2</span><span class="c">
        </span><span class="c">case let (.parsingError(error1), .parsingError(error2)):
            if </span><span class="c">error1 == nil || </span><span class="nc">error2 == nil</span><span class="c"> </span><span class="c">{
                return true
            }</span><span class="c"> else </span><span class="nc">{
                // Compare error descriptions since Error is not Equatable
                return String(describing: error1) == String(describing: error2)
            }</span><span class="c">
        </span><span class="nc">case (.noDownloadsInDownloadList, .noDownloadsInDownloadList):
            return true</span><span class="c">
        </span><span class="nc">case (.invalidFileSpec, .invalidFileSpec):
            return true</span><span class="c">
        </span><span class="c">case (.invalidResponse, .invalidResponse):
            return true</span><span class="c">
        </span><span class="nc">case let (.unknownFile(file1), .unknownFile(file2)):
            return file1 == file2</span><span class="c">
        </span><span class="nc">case (.needToAcceptTermsAndCondition, .needToAcceptTermsAndCondition):
            return true</span><span class="c">
        </span><span class="c">case let (.accountNeedUpgrade(code1, _), .accountNeedUpgrade(code2, _)):
            return code1 == code2</span><span class="c">
        </span><span class="nc">default:
            return false</span><span class="c">
        }
    }</span><span class="">
}

struct DownloadList: Sendable, Codable {

    struct DownloadCategory: Sendable, Codable {
        let id: Int
        let name: String
        let sortOrder: Int
    }

    struct FileFormat: Sendable, Codable {
        let fileExtension: String
        let description: String

        // real JSON name for fileExtension is extension
        // but this is a Swift reserved keyword
        // this allows to map internal name with JSON name

        enum CodingKeys: String, Sendable, CodingKey {  // swiftlint:disable:this nesting
            case fileExtension = "extension"
            case description
        }
    }

    struct File: Sendable, Codable {
        let filename: String
        let displayName: String?
        let remotePath: String
        let fileSize: Int
        let sortOrder: Int
        let dateCreated: String
        let dateModified: String
        let fileFormat: FileFormat
        let existInCache: Bool

        init(
            filename: String,
            displayName: String?,
            remotePath: String,
            fileSize: Int,
            sortOrder: Int,
            dateCreated: String,
            dateModified: String,
            fileFormat: FileFormat,
            existInCache: Bool = false
        ) </span><span class="c">{
            self.filename = filename
            self.displayName = displayName
            self.remotePath = remotePath
            self.fileSize = fileSize
            self.sortOrder = sortOrder
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.fileFormat = fileFormat
            self.existInCache = existInCache
        }</span><span class="">

        init(from: File, existInCache: Bool) </span><span class="c">{
            self.filename = from.filename
            self.displayName = from.displayName
            self.remotePath = from.remotePath
            self.fileSize = from.fileSize
            self.sortOrder = from.sortOrder
            self.dateCreated = from.dateCreated
            self.dateModified = from.dateModified
            self.fileFormat = from.fileFormat
            self.existInCache = existInCache
        }</span><span class="">
        // add coding keys to bypass decoding of existIncache
        init(from decoder: Decoder) throws </span><span class="c">{
            let values = try decoder.container(keyedBy: CodingKeys.self)</span><span class="c">
            filename = try values.decode(String.self, forKey: .filename)</span><span class="c">
            displayName = try values.decodeIfPresent(String.self, forKey: .displayName)</span><span class="c">
            remotePath = try values.decode(String.self, forKey: .remotePath)</span><span class="c">
            fileSize = try values.decode(Int.self, forKey: .fileSize)</span><span class="c">
            sortOrder = try values.decode(Int.self, forKey: .sortOrder)</span><span class="c">
            dateCreated = try values.decode(String.self, forKey: .dateCreated)</span><span class="c">
            dateModified = try values.decode(String.self, forKey: .dateModified)</span><span class="c">
            fileFormat = try values.decode(FileFormat.self, forKey: .fileFormat)</span><span class="c">
            existInCache = false
        }</span><span class="">
        enum CodingKeys: String, Sendable, CodingKey {  // swiftlint:disable:this nesting
            case filename
            case displayName
            case remotePath
            case fileSize
            case sortOrder
            case dateCreated
            case dateModified
            case fileFormat
        }
    }

    struct Download: Sendable, Codable {
        let id: String
        let name: String
        let description: String
        let isReleased: Int
        let datePublished: String?
        let dateCreated: String
        let dateModified: String
        let categories: [DownloadCategory]
        let files: [File]
        let isRelatedSeed: Bool
        init(
            id: String,
            name: String,
            description: String,
            isReleased: Int,
            datePublished: String?,
            dateCreated: String,
            dateModified: String,
            categories: [DownloadCategory],
            files: [File],
            isRelatedSeed: Bool
        ) </span><span class="c">{
            self.id = id
            self.name = name
            self.description = description
            self.isReleased = isReleased
            self.datePublished = datePublished
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.categories = categories
            self.files = files
            self.isRelatedSeed = isRelatedSeed
        }</span><span class="">
        init(from: Download, replaceWith newFile: File) </span><span class="c">{
            self.id = from.id
            self.name = from.name
            self.description = from.description
            self.isReleased = from.isReleased
            self.datePublished = from.datePublished
            self.dateCreated = from.dateCreated
            self.dateModified = from.dateModified
            self.categories = from.categories
            // replace the file list with the new file
            self.files = from.files.map </span><span class="c">{ $0.filename == newFile.filename ? </span><span class="c">newFile</span><span class="c"> : </span><span class="c">$0</span><span class="c"> }</span><span class="c">
            self.isRelatedSeed = from.isRelatedSeed
        }</span><span class="">
        init(from: Download, appendFile newFile: File) </span><span class="c">{
            self.id = from.id
            self.name = from.name
            self.description = from.description
            self.isReleased = from.isReleased
            self.datePublished = from.datePublished
            self.dateCreated = from.dateCreated
            self.dateModified = from.dateModified
            self.categories = from.categories
            // append the file to the list
            self.files = from.files + [newFile]
            self.isRelatedSeed = from.isRelatedSeed
        }</span><span class="">

    }

    let creationTimestamp: String
    let resultCode: Int
    let resultString: String?
    let userString: String?
    let userLocale: String
    let protocolVersion: String
    let requestUrl: String
    let responseId: String
    let httpCode: Int?
    let httpResponseHeaders: [String: String]?
    let downloadHost: String?
    let downloads: [Download]?

}

</span></pre><pre id="f7" style="display: none"><span>import Logging

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

struct DownloadTarget: Sendable {
    let totalFileSize: Int
    let dstFilePath: URL
    let startTime: Date

    init(totalFileSize: Int, dstFilePath: URL, startTime: Date = Date.now) </span><span class="c">{
        self.totalFileSize = totalFileSize
        self.dstFilePath = dstFilePath
        self.startTime = startTime
    }</span><span class="">
}

struct DownloadProgress: Sendable {
    let bytesWritten: Int64
    let totalBytes: Int64
    let startTime: Date
    var percentage: Double </span><span class="c">{ Double(bytesWritten) / Double(totalBytes) }</span><span class="">
    var bandwidth: Double </span><span class="nc">{
        let elapsed = 0 - startTime.timeIntervalSinceNow
        return elapsed &gt; 0 ? </span><span class="nc">Double(bytesWritten) / Double(elapsed) / 1024 / 1024</span><span class="nc"> : </span><span class="nc">0</span><span class="nc">
    }</span><span class="">
}

struct DownloadManager {

    private let log: Logger

    public init(logger: Logger) </span><span class="c">{
        self.log = logger
    }</span><span class="">

    /// Downloads a file, returning a stream of progress updates.
    ///
    /// Uses URLSession's optimized download task (not byte-by-byte streaming)
    /// for pure structured concurrency ‚Äî no Task, no Task.detached.
    /// Progress is observed via KVO on the task's Progress object.
    /// The consumer's `for try await` drives the stream: each iteration
    /// receives a progress update from the KVO observer. The main actor
    /// suspends cooperatively at each await.
    func download(
        from url: String,
        target downloadTarget: DownloadTarget,
        secrets: SecretsHandlerProtocol,
        fileHandler: FileHandlerProtocol
    ) async throws -&gt; AsyncThrowingStream&lt;DownloadProgress, Error&gt; </span><span class="nc">{

        var headers: [String: String] = ["Accept": "*/*"]

        let cookies = try? await secrets.loadCookies()
        if let cookies </span><span class="nc">{
            headers.merge(HTTPCookie.requestHeaderFields(with: cookies)) </span><span class="nc">{ (current, _) in current }</span><span class="nc">
        } else </span><span class="nc">{
            log.debug</span><span class="nc">(</span><span class="nc">"‚ö†Ô∏è I could not load cookies"</span><span class="nc">)
            throw DownloadError.authenticationRequired
        }</span><span class="nc">

        let request = self.request(for: url, withHeaders: headers)
        _log(request: request, to: log)

        let totalBytes = Int64(downloadTarget.totalFileSize)
        let dstPath = downloadTarget.dstFilePath
        let startTime = downloadTarget.startTime
        let capturedLog = self.log

        // The continuation-based stream: KVO progress callbacks and delegate
        // completion drive the stream. No Task needed ‚Äî the URLSession download
        // task runs on its own background queue and feeds progress into the
        // continuation. The consumer pulls progress via `for try await`.
        return AsyncThrowingStream </span><span class="nc">{ continuation in

            let handler = DownloadDelegate(
                continuation: continuation,
                totalBytes: totalBytes,
                startTime: startTime,
                dstPath: dstPath,
                fileHandler: fileHandler,
                log: capturedLog
            )

            // Create a dedicated session with our delegate.
            // The session retains the delegate for its lifetime.
            let session = URLSession(
                configuration: .default,
                delegate: handler,
                delegateQueue: nil  // URLSession creates its own serial queue
            )

            let task = session.downloadTask(with: request)
            task.resume()

            continuation.onTermination = </span><span class="nc">{ _ in
                task.cancel()
                session.invalidateAndCancel()
            }</span><span class="nc">
        }
    }</span><span class="">

    internal func request(
        for url: String,
        method: HTTPVerb = .GET,
        withBody body: Data? = nil,
        withHeaders headers: [String: String]? = nil
    ) -&gt; URLRequest </span><span class="c">{
        buildURLRequest(for: url, method: method, withBody: body, withHeaders: headers)
    }</span><span class="">
}

/// Handles URLSessionDownloadTask completion and progress observation.
/// Bridges the delegate callbacks into an AsyncThrowingStream continuation.
///
/// The download is started via `downloadTask(with:)` which returns immediately.
/// Progress is observed via KVO (synchronous, no isolation issues).
/// Completion is handled via `urlSession(_:task:didCompleteWithError:)`.
/// File move is handled via `urlSession(_:downloadTask:didFinishDownloadingTo:)`.
///
/// All delegate methods are `nonisolated` ‚Äî they run on URLSession's background
/// serial queue, not on MainActor. No async callbacks, no isolation conflicts.
final class DownloadDelegate: NSObject,
    URLSessionDownloadDelegate 
{
    // Safety invariant: all properties are either:
    // - set once in init and never mutated (continuation, totalBytes, startTime, dstPath, fileHandler, log)
    // - only accessed from URLSession's serial delegate queue (progressObservation, tempFileURL)
    private let continuation: AsyncThrowingStream&lt;DownloadProgress, Error&gt;.Continuation
    private let totalBytes: Int64
    private let startTime: Date
    private let dstPath: URL
    private let fileHandler: FileHandlerProtocol
    private let log: Logger
    // Only accessed from URLSession's serial delegate queue ‚Äî no data race.
    nonisolated(unsafe) private var progressObservation: NSKeyValueObservation?

    init(
        continuation: AsyncThrowingStream&lt;DownloadProgress, Error&gt;.Continuation,
        totalBytes: Int64,
        startTime: Date,
        dstPath: URL,
        fileHandler: FileHandlerProtocol,
        log: Logger
    ) </span><span class="c">{
        self.continuation = continuation
        self.totalBytes = totalBytes
        self.startTime = startTime
        self.dstPath = dstPath
        self.fileHandler = fileHandler
        self.log = log
        super.init()
    }</span><span class="">

    // Called synchronously when the task is created ‚Äî sets up KVO progress observation.
    func urlSession(_ session: URLSession, didCreateTask task: URLSessionTask) </span><span class="nc">{
        let cont = continuation
        let total = totalBytes
        let start = startTime
        progressObservation = task.progress.observe(\.fractionCompleted, options: [.new]) </span><span class="nc">{ _, change in
            if let fraction = change.newValue </span><span class="nc">{
                let written = Int64(fraction * Double(total))
                cont.yield(
                    DownloadProgress(bytesWritten: written, totalBytes: total, startTime: start)
                )
            }</span><span class="nc">
        }
    }</span><span class="">

    // Called when the download file is ready ‚Äî save the temp URL for moving.
    func urlSession(
        _ session: URLSession,
        downloadTask: URLSessionDownloadTask,
        didFinishDownloadingTo location: URL
    ) </span><span class="c">{
        log.debug</span><span class="nc">(</span><span class="nc">"HTTP response: \(downloadTask.response.map </span><span class="nc">{ ($0 as? HTTPURLResponse)?.statusCode ?? </span><span class="nc">-1</span><span class="nc"> } ?? </span><span class="nc">-1</span><span class="nc">)"</span><span class="c">)

        // Check for error pages in small downloads
        let attrs = try? FileManager.default.attributesOfItem(atPath: location.path)
        let fileSize = (attrs?[.size] as? Int64) ?? </span><span class="nc">0</span><span class="c">
        if </span><span class="c">fileSize &lt; 10_000</span><span class="c"> </span><span class="c">{
            if let data = try? Data(contentsOf: location),
                let content = String(data: data, encoding: .utf8),
                content.contains("&lt;Error&gt;") || </span><span class="c">content.contains("AccessDenied")</span><span class="c">
                    || </span><span class="c">content.contains("Sign in to your Apple Account")</span><span class="c">
            </span><span class="c">{
                try? FileManager.default.removeItem(at: location)
                continuation.finish(throwing: DownloadError.authenticationRequired)
                return
            }</span><span class="nc">
        }</span><span class="c">

        // Move the file to the destination
        do </span><span class="c">{
            try fileHandler.move(from: location, to: dstPath)</span><span class="c">
        }</span><span class="c"> catch </span><span class="c">{
            log.error</span><span class="c">(</span><span class="c">"üõë Failed to move downloaded file: \(error)"</span><span class="c">)
            continuation.finish(throwing: error)
            return
        }</span><span class="c">

        // No need to yield final progress here ‚Äî KVO already emitted the 100% update.
        // Yielding again would cause the progress bar to render the final line twice.
        continuation.finish()
    }</span><span class="">

    // Called when the task completes (success or failure).
    func urlSession(
        _ session: URLSession,
        task: URLSessionTask,
        didCompleteWithError error: (any Error)?
    ) </span><span class="c">{
        progressObservation?.invalidate()
        progressObservation = nil

        if let error </span><span class="c">{
            log.error</span><span class="c">(</span><span class="c">"üõë Download error: \(error)"</span><span class="c">)
            continuation.finish(throwing: error)
        }</span><span class="c">
        // If no error, didFinishDownloadingTo already handled completion.
    }</span><span class="">
}

</span></pre><pre id="f8" style="display: none"><span>//
//  HTTPClient.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 21/07/2022.
//

import Foundation
import Logging

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

/*
    This file contains code to make our APICall testable.

    Inspired from https://masilotti.com/testing-nsurlsession-input/
 */

// make URLSession testable by abstracting its protocol
// it allows to use the real URLSession or a mock interchangably
protocol URLSessionProtocol: Sendable {
    func data(
        for request: URLRequest,
        delegate: URLSessionTaskDelegate?
    ) async throws -&gt; (
        Data, URLResponse
    )
}

// make the real URLSession implements our new protocol to make the compiler happy
extension URLSession: URLSessionProtocol {}

// callers can express expected HTTP Response code either as range, either as specific value
enum ExpectedResponseCode {
    case range(Range&lt;Int&gt;)
    case value(Int)

    func isValid(response: Int) -&gt; Bool </span><span class="c">{
        switch </span><span class="c">self</span><span class="c"> {
        </span><span class="c">case .range(let range):
            return range.contains(response)</span><span class="c">
        </span><span class="c">case .value(let value):
            return value == response</span><span class="c">
        }
    }</span><span class="">
}

enum HTTPVerb: String {
    case GET
    case POST
}

// provide common code for all network clients
class HTTPClient {

    let secrets: SecretsHandlerProtocol
    let urlSession: URLSessionProtocol
    let log: Logger

    public init(secrets: SecretsHandlerProtocol, urlSession: URLSessionProtocol, log: Logger) </span><span class="c">{
        self.secrets = secrets
        self.urlSession = urlSession
        self.log = log
    }</span><span class="">

    // some ID returned by Apple API to authenticate us
    var session = </span><span class="c">AppleSession()</span><span class="">

    // to be shared between apiCall and download methods
    // prepare headers with correct cookies and X- value for Apple authentication
    func prepareAuthenticationHeaders() async -&gt; [String: String] </span><span class="c">{

        var requestHeaders: [String: String] = [
            "Content-Type": "application/json",
            "Accept": "application/json, text/javascript",
            "X-Requested-With": "XMLHttpRequest",
            "User-Agent": "curl/7.79.1",
        ]

        // reload previous session if it exists
        let session = try? await self.secrets.loadSession()
        if let session </span><span class="nc">{

            // session is loaded
            log.debug(</span><span class="nc">"Session data loaded"</span><span class="nc">, metadata: </span><span class="nc">["data": "\(session)"]</span><span class="nc">)
            self.session = session

        }</span><span class="c"> else </span><span class="c">{
            log.debug</span><span class="nc">(</span><span class="nc">"‚ö†Ô∏è I could not load session (this is normal the first time you authenticate)"</span><span class="c">)
        }

        // populate HTTP request with headers from session (either from self or the one just loaded)
        if let isk = self.session.itcServiceKey </span><span class="c">{
            requestHeaders["X-Apple-Widget-Key"] = isk.authServiceKey
        }</span><span class="c">
        if let aisi = self.session.xAppleIdSessionId </span><span class="c">{
            requestHeaders["X-Apple-ID-Session-Id"] = aisi
        }</span><span class="c">
        if let scnt = self.session.scnt </span><span class="c">{
            requestHeaders["scnt"] = scnt
        }</span><span class="c">

        // reload cookies if they exist
        let cookies = try? await self.secrets.loadCookies()
        if let cookies </span><span class="c">{
            // cookies existed, let's add them to our HTTPHeaders
            requestHeaders.merge(HTTPCookie.requestHeaderFields(with: cookies)) </span><span class="nc">{ (current, _) in current
            }</span><span class="c">
        } else </span><span class="nc">{
            // swiftlint:disable line_length
            log.debug</span><span class="nc">(</span><span class="nc">"‚ö†Ô∏è I could not load cookies (this is normal the first time you authenticate)"</span><span class="nc">)
        }</span><span class="c">

        return requestHeaders
    }</span><span class="">

    // generic API CALL method
    // this is used by authentication API calls
    func apiCall(
        url: String,
        method: HTTPVerb = .GET,
        body: Data? = nil,
        headers: [String: String] = [:],
        validResponse: ExpectedResponseCode = .value(0)
    ) async throws -&gt; (Data, HTTPURLResponse) </span><span class="c">{

        let request: URLRequest

        // let's add provided headers to our request (keeping new value in case of conflicts)
        var requestHeaders = await prepareAuthenticationHeaders()

        // add the headers our callers want in this request
        requestHeaders.merge(headers, uniquingKeysWith: </span><span class="nc">{ (_, new) in new }</span><span class="c">)

        // and build the request
        request = self.request(
            for: url,
            method: method,
            withBody: body,
            withHeaders: requestHeaders
        )

        _log(request: request, to: log)

        // send request with that session
        let (data, response) = try await self.urlSession.data(for: request, delegate: nil)</span><span class="c">
        guard let httpResponse = response as? HTTPURLResponse,
            validResponse.isValid(response: httpResponse.statusCode)
        else </span><span class="c">{
            log.error</span><span class="c">(</span><span class="c">
                </span><span class="c">"=== HTTP ERROR. Status code \((response as? HTTPURLResponse)!.statusCode) not in range \(validResponse) ==="</span><span class="c">
            )
            log.debug</span><span class="nc">(</span><span class="nc">"URLResponse : \(response)"</span><span class="c">)
            throw URLError(.badServerResponse)
        }</span><span class="c">

        _log(response: httpResponse, data: data, error: nil, to: log)

        return (data, httpResponse)</span><span class="c">
    }</span><span class="">

    // prepare an URLRequest for a given url, method, body, and headers
    // https://softwareengineering.stackexchange.com/questions/100959/how-do-you-unit-test-private-methods
    internal func request(
        for url: String,
        method: HTTPVerb = .GET,
        withBody body: Data? = nil,
        withHeaders headers: [String: String]? = nil
    ) -&gt; URLRequest </span><span class="c">{
        buildURLRequest(for: url, method: method, withBody: body, withHeaders: headers)
    }</span><span class="">
}

// Shared URL request builder used by both HTTPClient and DownloadManager.
internal func buildURLRequest(
    for url: String,
    method: HTTPVerb = .GET,
    withBody body: Data? = nil,
    withHeaders headers: [String: String]? = nil
) -&gt; URLRequest </span><span class="c">{

    // create the request
    guard let url = URL(string: url) else </span><span class="nc">{
        fatalError(</span><span class="nc">"Invalid URL: \(url)"</span><span class="nc">)
    }</span><span class="c">
    var request = URLRequest(url: url)

    // add HTTP verb
    request.httpMethod = method.rawValue

    // add body
    if let body </span><span class="c">{
        request.httpBody = body
    }</span><span class="c">

    // add headers
    if let headers </span><span class="c">{
        for (key, value) in headers </span><span class="c">{
            request.addValue(value, forHTTPHeaderField: key)
        }</span><span class="c">
    }</span><span class="c">

    return request
}</span><span class="">

</span></pre><pre id="f9" style="display: none"><span>//
//  Install.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 22/08/2022.
//

import Logging
import Subprocess

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

enum InstallerError: Error {
    case unsupportedInstallation
    case fileDoesNotExistOrIncorrect
    case xCodeUnxipDirectoryDoesntExist
    case xCodeXIPInstallationError
    case xCodeMoveInstallationError
    case xCodePKGInstallationError
    case CLToolsInstallationError
}

enum SupportedInstallation {
    case xCode
    case xCodeCommandLineTools
    case unsupported

    static func supported(_ file: String) -&gt; SupportedInstallation </span><span class="c">{
        if </span><span class="c">file.hasPrefix("Command Line Tools for Xcode") &amp;&amp; </span><span class="c">file.hasSuffix(".dmg")</span><span class="c"> </span><span class="c">{
            return .xCodeCommandLineTools
        }</span><span class="c"> else if </span><span class="c">file.hasPrefix("Xcode") &amp;&amp; </span><span class="c">file.hasSuffix(".xip")</span><span class="c"> </span><span class="c">{
            return .xCode
        }</span><span class="c"> else </span><span class="c">{
            return .unsupported
        }</span><span class="c">
    }</span><span class="">
}

class ShellInstaller {

    let log: Logger
    let fileHandler: FileHandlerProtocol
    let progressBar: CLIProgressBarProtocol
    let shellExecutor: any ShellExecuting
    public init(fileHandler: FileHandlerProtocol, progressBar: CLIProgressBarProtocol, shellExecutor: any ShellExecuting, log: Logger) </span><span class="c">{
        self.fileHandler = fileHandler
        self.progressBar = progressBar
        self.shellExecutor = shellExecutor
        self.log = log
    }</span><span class="">

    // the shell commands we need to install XCode and its command line tools
    let SUDOCOMMAND = </span><span class="c">"/usr/bin/sudo"</span><span class="">
    let HDIUTILCOMMAND = </span><span class="c">"/usr/bin/hdiutil"</span><span class="">
    let INSTALLERCOMMAND = </span><span class="c">"/usr/sbin/installer"</span><span class="">

    // the pkg provided by Xcode to install
    let PKGTOINSTALL = </span><span class="c">[
        "XcodeSystemResources.pkg",
        "CoreTypes.pkg",
        "MobileDevice.pkg",
        "MobileDeviceDevelopment.pkg",
    ]</span><span class="">

    /// Install Xcode or Xcode Command Line Tools
    ///  At this stage, we do support only these two installation.
    ///
    ///   **Xcode** is provided as a XIP file. The installation procedure is as follow:
    ///   - It is uncompressed
    ///   - It is moved to /Applications
    ///   - Four packages are installed
    ///         - `/Applications/Xcode.app/Contents/Resources/Packages/XcodeSystemResources.pkg`
    ///         - `/Applications/Xcode.app/Contents/Resources/Packages/CoreTypes.pkg`
    ///         - `/Applications/Xcode.app/Contents/Resources/Packages/MobileDevice.pkg`
    ///         - `/Applications/Xcode.app/Contents/Resources/Packages/MobileDeviceDevelopment.pkg`
    ///
    ///   **Command_Line_Tools_for_Xcode** is provided as a DMG file. The installation procedure is as follow:
    ///   - the DMG file is mounted
    ///   - Package `/Volumes/Command\ Line\ Developer\ Tools/Command\ Line\ Tools.pkg` is installed.
    func install(file: URL) async throws </span><span class="c">{

        // verify this is one the files we do support
        let installationType = SupportedInstallation.supported(file.lastPathComponent)
        guard installationType != .unsupported else </span><span class="c">{
            log.debug</span><span class="c">(</span><span class="c">"Unsupported installation type"</span><span class="c">)
            throw InstallerError.unsupportedInstallation
        }</span><span class="c">

        // find matching File in DownloadList (if there is one)
        // and compare existing filesize vs expected filesize
        guard fileMatch(file: file) else </span><span class="c">{
            log.debug</span><span class="nc">(</span><span class="nc">"File does not exist or has incorrect size"</span><span class="c">)
            throw InstallerError.fileDoesNotExistOrIncorrect
        }</span><span class="nc">

        // Dispatch installation between DMG and XIP
        switch </span><span class="nc">installationType</span><span class="nc"> {
        </span><span class="nc">case .xCode:
            try await self.installXcode(at: file)</span><span class="nc">
        </span><span class="nc">case .xCodeCommandLineTools:
            try await self.installCommandLineTools(atPath: file)</span><span class="nc">
        </span><span class="nc">case .unsupported:
            throw InstallerError.unsupportedInstallation</span><span class="nc">
        }</span><span class="nc">
    }</span><span class="">

    // swiftlint:disable line_length
    ///
    ///  Verifies if file exists on disk. Also check if file exists in cached download list,
    ///  in that case, it verifies the actuali file size is the same as the one from the cached list
    ///
    /// - Parameters
    ///     - file  : the full path of the file to test
    /// - Returns
    ///     - true when file exists and, when download list cache exists too, if file size matches the one mentioned in the cached download list
    ///
    // swiftlint:enable line_length
    func fileMatch(file: URL) -&gt; Bool </span><span class="c">{

        // File exist on disk ?
        // no =&gt; return FALSE
        // yes - do an additional check
        //    if there is a download list cache AND file is present in list AND size DOES NOT match =&gt; False
        // all other cases return true (we can try to install even if their is no cached download list)

        var match = self.fileHandler.fileExists(file: file, fileSize: 0)

        if </span><span class="c">!match</span><span class="c"> </span><span class="c">{
            return false
        }</span><span class="c">

        // find file in downloadlist (if the cached download list exists)
        if let dll = try? self.fileHandler.loadDownloadList() </span><span class="c">{
            if let dlFile = dll.find(fileName: file.lastPathComponent) </span><span class="nc">{
                // compare download list cached sized with actual size
                match = self.fileHandler.fileExists(file: file, fileSize: dlFile.fileSize)
            }</span><span class="c">
        }
        return match</span><span class="c">
    }</span><span class="">

    // MARK: PKG
    // generic PKG installation function

    func installPkg(atURL pkg: URL) async throws -&gt; ShellOutput </span><span class="c">{

        let pkgPath = pkg.path

        // check if file exists
        guard self.fileHandler.fileExists(file: pkg, fileSize: 0) else </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Package does not exist : \(pkgPath)"</span><span class="nc">)
            throw InstallerError.fileDoesNotExistOrIncorrect
        }</span><span class="c">

        return try await self.shellExecutor.run(
            .path(SUDOCOMMAND),
            arguments: [INSTALLERCOMMAND, "-pkg", pkgPath, "-target", "/"]
        )</span><span class="c">
    }</span><span class="">

}

</span></pre><pre id="f10" style="display: none"><span>//
//  InstallDownloadListExtension.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 29/08/2022.
//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

// MARK: Extensions - DownloadList
// not fileprivate to allow testing
extension DownloadList {

    /// Check an entire list for files matching the given filename
    /// This generic function avoids repeating code in the two `find(...)` below
    /// - Parameters
    ///     - fileName: the file name to check (without full path)
    ///     - inList: either a [Download] or a [File]
    ///     - comparison: a function that receives either a `Download` either a `File`
    ///                and returns a `File` when there is a file name match, nil otherwise
    /// - Returns
    ///     a File struct if a file matches, nil otherwise

    private func _find&lt;T: Sequence&gt;(
        fileName: String,
        inList list: T,
        comparison: (T.Element) -&gt; File?
    ) -&gt; File? </span><span class="c">{

        // first returns an array of File? with nil when filename does not match
        // or file otherwise.
        // for example : [nil, file, nil, nil]
        let result: [File?] = list.compactMap </span><span class="c">{ element -&gt; File? in
            comparison(element)
        }</span><span class="c">

        // we should have 0 or 1 element
        if </span><span class="c">result.count &gt; 0</span><span class="c"> </span><span class="c">{
            assert(</span><span class="c">result.count == 1</span><span class="c">)
            return result[0]
        }</span><span class="c"> else </span><span class="c">{
            return nil
        }</span><span class="c">

    }</span><span class="">

    /// check the entire list of downloads for files matching the given filename
    /// - Parameters
    ///     - fileName: the file name to check (without full path)
    /// - Returns
    ///     a File struct if a file matches, nil otherwise
    func find(fileName: String) -&gt; File? </span><span class="c">{

        guard let listOfDownloads = self.downloads else </span><span class="nc">{
            return nil
        }</span><span class="c">

        return _find(
            fileName: fileName,
            inList: listOfDownloads,
            comparison: </span><span class="c">{ element in
                let download = element as Download
                return find(fileName: fileName, inDownload: download)
            }</span><span class="c">
        )
    }</span><span class="">

    // search the list of files ([File]) for an individual file match
    func find(fileName: String, inDownload download: Download) -&gt; File? </span><span class="c">{

        _find(
            fileName: fileName,
            inList: download.files,
            comparison: </span><span class="c">{ element in
                let file = element as File
                return file.filename == fileName ? </span><span class="c">file</span><span class="c"> : </span><span class="c">nil</span><span class="c">
            }</span><span class="c">
        )

    }</span><span class="">
}

</span></pre><pre id="f11" style="display: none"><span>//
//  InstallXcode.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 29/08/2022.
//

import Subprocess
import libunxip

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

// MARK: XCODE
// XCode installation functions
extension ShellInstaller {

    func installXcode(at src: URL) async throws </span><span class="nc">{

        // unXIP, mv, 4 PKG to install
        let totalSteps = 2 + PKGTOINSTALL.count
        var currentStep: Int = 0

        var result: ShellOutput

        // first uncompress file
        log.debug</span><span class="nc">(</span><span class="nc">"Decompressing files"</span><span class="nc">)
        // run synchronously as there is no output for this operation
        currentStep += 1
        self.progressBar.update(
            step: currentStep,
            total: totalSteps,
            text: "Expanding Xcode xip (this might take a while)"
        )

        do </span><span class="nc">{
            try await self.uncompressXIP(atURL: src)</span><span class="nc">
        }</span><span class="nc"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Failed to extract XIP file: \(error)"</span><span class="nc">)
            throw InstallerError.xCodeXIPInstallationError
        }</span><span class="nc">

        // second move file to /Applications
        log.debug</span><span class="nc">(</span><span class="nc">"Moving app to destination"</span><span class="nc">)
        currentStep += 1
        self.progressBar.update(
            step: currentStep,
            total: totalSteps,
            text: "Moving Xcode to /Applications"
        )
        // find .app file
        let appFile = try fileHandler.downloadedFiles()</span><span class="nc">.filter(</span><span class="nc">{ fileName in
            fileName.hasSuffix(".app")
        }</span><span class="nc">)
        if </span><span class="nc">appFile.count != 1</span><span class="nc"> </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">
                </span><span class="nc">"Zero or several app file to install in \(appFile), not sure which one is the correct one"</span><span class="nc">
            )
            throw InstallerError.xCodeMoveInstallationError
        }</span><span class="nc">

        let installedFile =
            try await self.moveApp(at: self.fileHandler.downloadDirectory().appendingPathComponent(appFile[0]))</span><span class="nc">

        // /Applications/Xcode.app/Contents/Resources/Packages/

        // third install packages provided with Xcode app
        for pkg in PKGTOINSTALL </span><span class="nc">{
            log.debug</span><span class="nc">(</span><span class="nc">"Installing package \(pkg)"</span><span class="nc">)
            currentStep += 1
            self.progressBar.update(
                step: currentStep,
                total: totalSteps,
                text: "Installing additional packages... \(pkg)"
            )
            result = try await self.installPkg(
                atURL: URL(fileURLWithPath: "\(installedFile)/Contents/resources/Packages/\(pkg)")
            )</span><span class="nc">
            if </span><span class="nc">!result.terminationStatus.isSuccess</span><span class="nc"> </span><span class="nc">{
                log.error</span><span class="nc">(</span><span class="nc">"Can not install pkg at : \(pkg)\n\(result)"</span><span class="nc">)
                throw InstallerError.xCodePKGInstallationError
            }</span><span class="nc">
        }</span><span class="nc">

    }</span><span class="">

    // expand a XIP file.  There is no way to create XIP file.
    // This code can not be tested without a valid, signed,  Xcode archive
    // https://en.wikipedia.org/wiki/.XIP
    func uncompressXIP(atURL file: URL) async throws </span><span class="c">{

        let filePath = file.path

        // not necessary, file existence has been checked before
        guard self.fileHandler.fileExists(file: file, fileSize: 0) else </span><span class="c">{
            log.error</span><span class="c">(</span><span class="c">"File to unXip does not exist : \(filePath)"</span><span class="c">)
            throw InstallerError.fileDoesNotExistOrIncorrect
        }</span><span class="nc">

        let output = file.deletingLastPathComponent()
        guard chdir(output.path) == 0 else </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Failed to access output directory at \(output): \(String(cString: strerror(errno)))"</span><span class="nc">)
            throw InstallerError.xCodeUnxipDirectoryDoesntExist
        }</span><span class="nc">

        // Use unxip library to decompress the XIP file
        let handle = try FileHandle(forReadingFrom: file)</span><span class="nc">
        let data = DataReader(descriptor: handle.fileDescriptor)
        for</span><span class="nc"> try await file in Unxip.makeStream(from: .xip(), to: .disk(), input: data) </span><span class="nc">{
            log.trace</span><span class="nc">(</span><span class="nc">"Uncompressing XIP file at \(file.name)"</span><span class="nc">)
            // do nothing at the moment
            // a future version might report progress to the UI
        }</span><span class="nc">
    }</span><span class="">

    func moveApp(at src: URL) async throws -&gt; String </span><span class="c">{

        // extract file name
        let fileName = src.lastPathComponent

        // create source and destination URL
        let appURL = URL(fileURLWithPath: "/Applications/\(fileName)")

        log.debug</span><span class="nc">(</span><span class="nc">"Going to move \n \(src) to \n \(appURL)"</span><span class="c">)
        // move synchronously
        try self.fileHandler.move(from: src, to: appURL)</span><span class="c">

        return appURL.path</span><span class="c">
    }</span><span class="">

    // MARK: Command Line Tools
    // Command Line Tools installation functions

    func installCommandLineTools(atPath file: URL) async throws </span><span class="nc">{

        let filePath = file.path

        // check if file exists
        guard self.fileHandler.fileExists(file: file, fileSize: 0) else </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Command line disk image does not exist : \(filePath)"</span><span class="nc">)
            throw InstallerError.fileDoesNotExistOrIncorrect
        }</span><span class="nc">

        // mount, install, unmount
        let totalSteps = 3
        var currentStep: Int = 0

        var result: ShellOutput

        // first mount the disk image
        log.debug</span><span class="nc">(</span><span class="nc">"Mounting disk image \(file.lastPathComponent)"</span><span class="nc">)
        currentStep += 1
        self.progressBar.update(step: currentStep, total: totalSteps, text: "Mounting disk image...")
        result = try await self.mountDMG(atURL: file)</span><span class="nc">
        if </span><span class="nc">!result.terminationStatus.isSuccess</span><span class="nc"> </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Can not mount disk image : \(filePath)\n\(String(describing: result))"</span><span class="nc">)
            throw InstallerError.CLToolsInstallationError
        }</span><span class="nc">

        // second install the package
        // find the name of the package ?
        let pkg = URL(fileURLWithPath: "/Volumes/Command Line Developer Tools/Command Line Tools.pkg")
        let pkgPath = pkg.path
        log.debug</span><span class="nc">(</span><span class="nc">"Installing pkg \(pkgPath)"</span><span class="nc">)
        currentStep += 1
        self.progressBar.update(step: currentStep, total: totalSteps, text: "Installing package...")
        result = try await self.installPkg(atURL: pkg)</span><span class="nc">
        if </span><span class="nc">!result.terminationStatus.isSuccess</span><span class="nc"> </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Can not install package : \(pkgPath)\n\(String(describing: result))"</span><span class="nc">)
            throw InstallerError.CLToolsInstallationError
        }</span><span class="nc">

        // third unmount the disk image
        let mountedDiskImage = URL(fileURLWithPath: "/Volumes/Command Line Developer Tools")
        log.debug</span><span class="nc">(</span><span class="nc">"Unmounting volume \(mountedDiskImage)"</span><span class="nc">)
        currentStep += 1
        self.progressBar.update(step: currentStep, total: totalSteps, text: "Unmounting volume...")
        result = try await self.unmountDMG(volume: mountedDiskImage)</span><span class="nc">
        if </span><span class="nc">!result.terminationStatus.isSuccess</span><span class="nc"> </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">
                </span><span class="nc">"Can not unmount volume : \(mountedDiskImage)\n\(String(describing: result))"</span><span class="nc">
            )
            throw InstallerError.CLToolsInstallationError
        }</span><span class="nc">
    }</span><span class="">

    private func mountDMG(atURL dmg: URL) async throws -&gt; ShellOutput </span><span class="nc">{

        let dmgPath = dmg.path

        // check if file exists
        guard self.fileHandler.fileExists(file: dmg, fileSize: 0) else </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Disk Image does not exist : \(dmgPath)"</span><span class="nc">)
            throw InstallerError.fileDoesNotExistOrIncorrect
        }</span><span class="nc">

        // hdiutil mount ./xcode-cli.dmg
        return try await self.shellExecutor.run(.path(HDIUTILCOMMAND), arguments: ["mount", dmgPath])</span><span class="nc">
    }</span><span class="">

    private func unmountDMG(volume: URL) async throws -&gt; ShellOutput </span><span class="nc">{

        // hdiutil unmount /Volumes/Command\ Line\ Developer\ Tools/
        try await self.shellExecutor.run(.path(HDIUTILCOMMAND), arguments: ["unmount", volume.path])</span><span class="nc">
    }</span><span class="">
}

</span></pre><pre id="f12" style="display: none"><span>//
//  List.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 21/08/2022.
//

import Foundation

extension AppleDownloader {

    // load the list of available downloads
    // when force is true, dowload from Apple even when there is a cache on disk
    // https://developer.apple.com
    // POST /services-account/QH65B2/downloadws/listDownloads.action
    //
    func list(force: Bool) async throws -&gt; (DownloadList, ListSource) </span><span class="nc">{

        var downloadList: DownloadList?

        if </span><span class="nc">!force</span><span class="nc"> </span><span class="nc">{
            // load the list from file if we have it
            downloadList = try? self.fileHandler.loadDownloadList()
        }</span><span class="nc">

        if let cachedList = downloadList </span><span class="nc">{
            return (cachedList, .cache)
        }</span><span class="nc">

        // need to download the list from Apple
        do </span><span class="nc">{
            log.debug</span><span class="nc">(</span><span class="nc">"Downloading list from Apple..."</span><span class="nc">)
            let url =
                "https://developer.apple.com/services-account/QH65B2/downloadws/listDownloads.action"
            let (data, response) = try await apiCall(
                url: url,
                method: .POST,
                validResponse: .range(200..&lt;400)
            )</span><span class="nc">

            guard response.statusCode == 200 else </span><span class="nc">{
                log.error</span><span class="nc">(</span><span class="nc">"üõë Download List response is not 200, something is incorrect"</span><span class="nc">)
                log.debug</span><span class="nc">(</span><span class="nc">"URLResponse = \(response)"</span><span class="nc">)
                throw DownloadError.invalidResponse
            }</span><span class="nc">

            do </span><span class="nc">{
                downloadList = try JSONDecoder().decode(DownloadList.self, from: data)</span><span class="nc">
            }</span><span class="nc"> catch </span><span class="nc">{
                throw DownloadError.parsingError(error: error)
            }</span><span class="nc">

            if </span><span class="nc">downloadList!.resultCode == 0</span><span class="nc"> </span><span class="nc">{

                // grab authentication cookie for later download
                if let cookies = response.value(forHTTPHeaderField: "Set-Cookie") </span><span class="nc">{
                    // save the new cookies we received (ADCDownloadAuth)
                    _ = try await self.secrets.saveCookies(cookies)</span><span class="nc">
                }</span><span class="nc"> else </span><span class="nc">{
                    // swiftlint:disable line_length
                    log.error</span><span class="nc">(</span><span class="nc">
                        </span><span class="nc">"üõë Download List response does not contain authentication cookie, something is incorrect"</span><span class="nc">
                    )
                    log.debug</span><span class="nc">(</span><span class="nc">"URLResponse = \(response)"</span><span class="nc">)
                    throw DownloadError.invalidResponse
                }</span><span class="nc">

                // success, save the list for reuse
                _ = try self.fileHandler.saveDownloadList(list: downloadList!)</span><span class="nc">

            }</span><span class="nc"> else </span><span class="nc">{

                switch </span><span class="nc">downloadList!.resultCode</span><span class="nc"> {
                </span><span class="nc">case 1100:  // authentication expired
                    throw DownloadError.authenticationRequired</span><span class="nc">
                </span><span class="nc">case 2100:  // needs to accept ToC
                    throw DownloadError.needToAcceptTermsAndCondition</span><span class="nc">
                </span><span class="nc">case 2170:  // accounts need upgrade
                    log.error</span><span class="nc">(</span><span class="nc">
                        </span><span class="nc">"Error \(downloadList!.resultCode) : \(downloadList!.userString ?? </span><span class="nc">"no user string"</span><span class="nc">)"
                    )
                    throw DownloadError.accountNeedUpgrade(
                        errorCode: downloadList!.resultCode,
                        errorMessage: downloadList!.userString ?? </span><span class="nc">"Your developer account needs to be updated"</span><span class="nc">
                    )
                </span><span class="nc">default:
                    // is there other error cases that I need to handle explicitly ?
                    throw DownloadError.unknownError(
                        errorCode: downloadList!.resultCode,
                        errorMessage: downloadList!.userString ?? </span><span class="nc">"Unknown error"</span><span class="nc">
                    )
                }
            }</span><span class="nc">
        }</span><span class="nc">

        guard let dList = downloadList else </span><span class="nc">{
            throw DownloadError.noDownloadsInDownloadList
        }</span><span class="nc">
        return (dList, .network)</span><span class="nc">

    }</span><span class="">
}

</span></pre><pre id="f13" style="display: none"><span>//
//  URLLogger.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 18/07/2022.
//

import Foundation
import Logging

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

// Using Swift's modern regex syntax
func _filterPassword(_ input: String) -&gt; String </span><span class="c">{
    let regex = /("password":").*?("[\,\}])/
    return input.replacing(regex) </span><span class="c">{ match in
        "\(match.1)*****\(match.2)"
    }</span><span class="c">
}</span><span class="">

func _log(request: URLRequest, to logger: Logger) </span><span class="c">{

    logger.debug</span><span class="nc">(</span><span class="nc">"\n - - - - - - - - - - OUTGOING - - - - - - - - - - \n"</span><span class="c">)
    defer { logger.debug</span><span class="nc">(</span><span class="nc">"\n - - - - - - - - - -  END - - - - - - - - - - \n"</span><span class="c">) }
    let urlAsString = request.url?.absoluteString ?? </span><span class="nc">""</span><span class="c">
    let urlComponents = URLComponents(string: urlAsString)
    let method = request.httpMethod != nil ? </span><span class="c">"\(request.httpMethod ?? </span><span class="nc">""</span><span class="c">)" : </span><span class="nc">""</span><span class="c">
    let path = "\(urlComponents?.path ?? </span><span class="nc">""</span><span class="c">)"
    let query = "\(urlComponents?.query ?? </span><span class="c">""</span><span class="c">)"
    let host = "\(urlComponents?.host ?? </span><span class="nc">""</span><span class="c">)"
    var output = """
        \(urlAsString) \n\n
        \(method) \(path)?\(query) HTTP/1.1 \n
        HOST: \(host)\n
        """

    for (key, value) in request.allHTTPHeaderFields ?? </span><span class="nc">[:]</span><span class="c"> </span><span class="c">{
        output += "\(key): \(value)\n"

    }</span><span class="c">

    if let body = request.httpBody </span><span class="c">{
        output += "\n \(String(data: body, encoding: .utf8) ?? </span><span class="nc">""</span><span class="c">)"
    }</span><span class="c">
    logger.debug</span><span class="nc">(</span><span class="nc">"\(_filterPassword(output))"</span><span class="c">)
}</span><span class="">

func _log(response: HTTPURLResponse?, data: Data?, error: Error?, to logger: Logger) </span><span class="c">{

    logger.debug</span><span class="nc">(</span><span class="nc">"\n - - - - - - - - - - INCOMING - - - - - - - - - - \n"</span><span class="c">)
    defer { logger.debug</span><span class="nc">(</span><span class="nc">"\n - - - - - - - - - -  END - - - - - - - - - - \n"</span><span class="c">) }
    let urlString = response?.url?.absoluteString
    let components = NSURLComponents(string: urlString ?? </span><span class="nc">""</span><span class="c">)
    let path = "\(components?.path ?? </span><span class="nc">""</span><span class="c">)"
    let query = "\(components?.query ?? </span><span class="c">""</span><span class="c">)"
    var output = ""
    if let urlString </span><span class="c">{
        output += "\(urlString)"
        output += "\n\n"
    }</span><span class="c">
    if let statusCode = response?.statusCode </span><span class="c">{
        output += "HTTP \(statusCode) \(path)?\(query)\n"
    }</span><span class="c">
    if let host = components?.host </span><span class="c">{
        output += "Host: \(host)\n"
    }</span><span class="c">
    for (key, value) in response?.allHeaderFields ?? </span><span class="nc">[:]</span><span class="c"> </span><span class="c">{
        output += "\(key): \(value)\n"
    }</span><span class="c">
    if let data </span><span class="c">{
        output += "\n\(String(data: data, encoding: .utf8) ?? </span><span class="nc">""</span><span class="c">)\n"
    }
    if </span><span class="c">error != nil</span><span class="c"> </span><span class="nc">{
        output += "\nError: \(error!.localizedDescription)\n"
    }</span><span class="c">
    logger.debug</span><span class="nc">(</span><span class="nc">"\(_filterPassword(output))"</span><span class="c">)
}</span><span class="">

</span></pre><pre id="f14" style="display: none"><span>//
//  URLRequestExtension.swift
//
//  Created by Abhishek Maurya on 16/07/20.
//  Copyright ¬© 2020. All rights reserved.
//
import Foundation

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

extension URLRequest {
    public func cURL(pretty: Bool = false) -&gt; String </span><span class="c">{
        let newLine = pretty ? </span><span class="c">"\\\n"</span><span class="c"> : </span><span class="c">""</span><span class="c">
        let method = (pretty ? </span><span class="c">"--request "</span><span class="c"> : </span><span class="c">"-X "</span><span class="c">) + "\(self.httpMethod ?? </span><span class="nc">"GET"</span><span class="c">) \(newLine)"
        let url: String = (pretty ? </span><span class="c">"--url "</span><span class="c"> : </span><span class="c">""</span><span class="c">) + "\'\(self.url?.absoluteString ?? </span><span class="nc">""</span><span class="c">)\' \(newLine)"

        var cURL = (pretty ? </span><span class="c">"curl -v --disable "</span><span class="c"> : </span><span class="c">"curl -q "</span><span class="c">)
        var header = ""
        var data: String = ""

        if let httpHeaders = self.allHTTPHeaderFields, httpHeaders.keys.count &gt; 0 </span><span class="c">{
            for (key, value) in httpHeaders </span><span class="c">{
                header += (pretty ? </span><span class="c">"--header "</span><span class="c"> : </span><span class="c">"-H "</span><span class="c">) + "\'\(key): \(value)\' \(newLine)"
            }</span><span class="c">
        }</span><span class="c">

        if let bodyData = self.httpBody, let bodyString = String(data: bodyData, encoding: .utf8),
            !bodyString.isEmpty
        </span><span class="c">{
            data = "--data '\(bodyString)'"
        }</span><span class="c">

        cURL += method + url + header + data

        return cURL
    }</span><span class="">
}

</span></pre><pre id="f15" style="display: none"><span>//
//  CLIAuthenticate.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 23/07/2022.
//

import ArgumentParser
import Logging

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension MainCommand {

    struct Authenticate: AsyncParsableCommand {
        nonisolated static let configuration =
            CommandConfiguration(abstract: "Authenticate yourself against Apple Developer Portal")

        @OptionGroup var globalOptions: GlobalOptions
        @OptionGroup var cloudOption: CloudOptions

        @</span><span class="c">Option(name: .long, help: "Use SRP authentication")</span><span class="">
        var srp = </span><span class="c">true</span><span class="">

        func run() async throws </span><span class="nc">{
            try await run(with: nil)</span><span class="nc">
        }</span><span class="">

        func run(with deps: AppDependencies?) async throws </span><span class="c">{

            let xci = try await MainCommand.XCodeInstaller(
                with: deps,
                for: cloudOption.secretManagerRegion,
                profileName: cloudOption.profileName,
                verbose: globalOptions.verbose,
            )</span><span class="c">

            do </span><span class="c">{
                try await xci.authenticate(with: AuthenticationMethod.withSRP(srp))</span><span class="c">
            }</span><span class="c"> catch </span><span class="nc">{
                try? await xci.deps.secrets?.shutdown()
                throw ExitCode.failure
            }</span><span class="c">

            // Gracefully shut down AWS client before process exits
            // to avoid RotatingCredentialProvider crash during deallocation
            try? await xci.deps.secrets?.shutdown()
        }</span><span class="">
    }

    struct Signout: AsyncParsableCommand {
        nonisolated static let configuration = CommandConfiguration(abstract: "Signout from Apple Developer Portal")

        @OptionGroup var globalOptions: GlobalOptions
        @OptionGroup var cloudOption: CloudOptions

        func run() async throws </span><span class="nc">{
            try await run(with: nil)</span><span class="nc">
        }</span><span class="">

        func run(with deps: AppDependencies?) async throws </span><span class="c">{

            let xci = try await MainCommand.XCodeInstaller(
                with: deps,
                for: cloudOption.secretManagerRegion,
                profileName: cloudOption.profileName,
                verbose: globalOptions.verbose
            )</span><span class="c">

            do </span><span class="c">{
                try await xci.signout()</span><span class="c">
            }</span><span class="c"> catch </span><span class="nc">{
                try? await xci.deps.secrets?.shutdown()
                throw ExitCode.failure
            }</span><span class="c">

            // Gracefully shut down AWS client before process exits
            // to avoid RotatingCredentialProvider crash during deallocation
            try? await xci.deps.secrets?.shutdown()
        }</span><span class="">
    }

}

</span></pre><pre id="f16" style="display: none"><span>//
//  CLIDownload.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 23/07/2022.
//

import ArgumentParser
import Logging

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

// download implementation
extension MainCommand {

    struct Download: AsyncParsableCommand {
        nonisolated static let configuration = CommandConfiguration(
            abstract: "Download the specified version of Xcode"
        )

        @OptionGroup var globalOptions: GlobalOptions
        @OptionGroup var downloadListOptions: DownloadListOptions
        @OptionGroup var cloudOption: CloudOptions

        @Option(
            name: .shortAndLong,
            help: "The exact package name to downloads. When omitted, it asks interactively"
        )
        var name: String?

        func run() async throws </span><span class="nc">{
            try await run(with: nil)</span><span class="nc">
        }</span><span class="">

        func run(with deps: AppDependencies?) async throws </span><span class="c">{
            let xci = try await MainCommand.XCodeInstaller(
                with: deps,
                for: cloudOption.secretManagerRegion,
                profileName: cloudOption.profileName,
                verbose: globalOptions.verbose
            )</span><span class="c">

            do </span><span class="c">{
                try await xci.download(
                    fileName: name,
                    force: downloadListOptions.force,
                    xCodeOnly: downloadListOptions.onlyXcode,
                    majorVersion: downloadListOptions.xCodeVersion,
                    sortMostRecentFirst: downloadListOptions.mostRecentFirst,
                    datePublished: downloadListOptions.datePublished
                )</span><span class="c">
            }</span><span class="c"> catch </span><span class="c">{
                try? await xci.deps.secrets?.shutdown()
                throw ExitCode.failure
            }</span><span class="c">

            // Gracefully shut down AWS client before process exits
            // to avoid RotatingCredentialProvider crash during deallocation
            try? await xci.deps.secrets?.shutdown()
        }</span><span class="">
    }

}

</span></pre><pre id="f17" style="display: none"><span>//
//  CLIInstall.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 22/08/2022.
//

import ArgumentParser
import Logging

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

// Install implementation
extension MainCommand {

    struct Install: AsyncParsableCommand {

        nonisolated static let configuration =
            CommandConfiguration(abstract: "Install a specific XCode version or addon package")

        @OptionGroup var globalOptions: GlobalOptions

        @Option(
            name: .shortAndLong,
            help: "The exact package name to install. When omitted, it asks interactively"
        )
        var name: String?

        func run() async throws </span><span class="nc">{
            try await run(with: nil)</span><span class="nc">
        }</span><span class="">

        func run(with deps: AppDependencies?) async throws </span><span class="c">{
            let xci = try await MainCommand.XCodeInstaller(
                with: deps,
                verbose: globalOptions.verbose
            )</span><span class="c">

            do </span><span class="c">{
                try await xci.install(file: name)</span><span class="nc">
            }</span><span class="c"> catch </span><span class="c">{
                throw ExitCode.failure
            }</span><span class="nc">
        }</span><span class="">
    }
}

</span></pre><pre id="f18" style="display: none"><span>//
//  CLIList.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 23/07/2022.
//

import ArgumentParser
import Logging

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

// list implementation
extension MainCommand {

    struct DownloadListOptions: ParsableArguments {

        nonisolated static let configuration =
            CommandConfiguration(
                abstract: "Common options for list and download commands",
                shouldDisplay: false
            )

        @</span><span class="c">Flag(
            name: .shortAndLong,
            help:
                "Force to download the list from Apple Developer Portal, even if we have it in the cache"
        )</span><span class="">
        var force: Bool = </span><span class="c">false</span><span class="">

        @</span><span class="c">Flag(name: .shortAndLong, help: "Filter on Xcode package only")</span><span class="">
        var onlyXcode: Bool = </span><span class="c">false</span><span class="">

        @</span><span class="c">Option(
            name: [.customLong("xcode-version"), .short],
            help: "Filter on provided Xcode version number"
        )</span><span class="">
        var xCodeVersion: String = </span><span class="c">"26"</span><span class="">

        @</span><span class="c">Flag(name: .shortAndLong, help: "Sort by most recent releases first")</span><span class="">
        var mostRecentFirst: Bool = </span><span class="c">false</span><span class="">

        @</span><span class="c">Flag(name: .shortAndLong, help: "Show publication date")</span><span class="">
        var datePublished: Bool = </span><span class="c">false</span><span class="">

    }

    struct List: AsyncParsableCommand {

        nonisolated static let configuration =
            CommandConfiguration(abstract: "List available versions of Xcode and development tools")

        @OptionGroup var globalOptions: GlobalOptions
        @OptionGroup var downloadListOptions: DownloadListOptions
        @OptionGroup var cloudOption: CloudOptions

        func run() async throws </span><span class="nc">{
            try await run(with: nil)</span><span class="nc">
        }</span><span class="">

        func run(with deps: AppDependencies?) async throws </span><span class="c">{
            let xci = try await MainCommand.XCodeInstaller(
                with: deps,
                for: cloudOption.secretManagerRegion,
                profileName: cloudOption.profileName,
                verbose: globalOptions.verbose
            )</span><span class="c">

            do </span><span class="c">{
                _ = try await xci.list(
                    force: downloadListOptions.force,
                    xCodeOnly: downloadListOptions.onlyXcode,
                    majorVersion: downloadListOptions.xCodeVersion,
                    sortMostRecentFirst: downloadListOptions.mostRecentFirst,
                    datePublished: downloadListOptions.datePublished
                )</span><span class="c">
            }</span><span class="c"> catch </span><span class="nc">{
                try? await xci.deps.secrets?.shutdown()
                throw ExitCode.failure
            }</span><span class="c">

            // Gracefully shut down AWS client before process exits
            // to avoid RotatingCredentialProvider crash during deallocation
            try? await xci.deps.secrets?.shutdown()
        }</span><span class="">
    }
}

</span></pre><pre id="f19" style="display: none"><span>//
//  CLIMain.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 18/07/2022.
//

import ArgumentParser
import Logging

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

enum CLIError: Error {
    case invalidInput
    case userCancelled
}

@main
struct MainCommand: AsyncParsableCommand {

    // arguments that are global to all commands
    struct GlobalOptions: ParsableArguments {

        @</span><span class="c">Flag(name: .shortAndLong, help: "Produce verbose output for debugging")</span><span class="">
        var verbose = </span><span class="c">false</span><span class="">
    }

    // arguments for Authenticate, Signout, List, and Download
    struct CloudOptions: ParsableArguments {

        @Option(
            name: [.customLong("secretmanager-region"), .short],
            help: "Instructs to use AWS Secrets Manager to store and read secrets in the given AWS Region"
        )
        var secretManagerRegion: String?

        @Option(
            name: [.customLong("profile"), .customShort("p")],
            help: "The AWS profile name to use for authentication (from ~/.aws/credentials and ~/.aws/config)"
        )
        var profileName: String?
    }

    @OptionGroup var globalOptions: GlobalOptions

    // Customize the command's help and subcommands by implementing the
    // `configuration` property.
    nonisolated static let configuration = CommandConfiguration(
        commandName: "xcodeinstall",

        // Optional abstracts and discussions are used for help output.
        abstract: "A utility to download and install Xcode",

        // Commands can define a version for automatic '--version' support.
        version: Version().current,  // generated by scripts/deploy/version.sh

        // Pass an array to `subcommands` to set up a nested tree of subcommands.
        // With language support for type-level introspection, this could be
        // provided by automatically finding nested `ParsableCommand` types.
        subcommands: [
            Authenticate.self, Signout.self, List.self,
            Download.self, Install.self, StoreSecrets.self,
        ]

        // A default subcommand, when provided, is automatically selected if a
        // subcommand is not given on the command line.
        // defaultSubcommand: List.self)
    )

    public static func XCodeInstaller(
        with deps: AppDependencies? = nil,
        for region: String? = nil,
        profileName: String? = nil,
        verbose: Bool
    ) async throws -&gt; XCodeInstall </span><span class="c">{

        var logger = Logger(label: "xcodeinstall")
        if </span><span class="c">verbose</span><span class="c"> </span><span class="c">{
            logger.logLevel = .debug
        }</span><span class="c"> else </span><span class="c">{
            logger.logLevel = .error
        }</span><span class="c">

        if let deps </span><span class="c">{
            return await XCodeInstall(log: logger, deps: deps)
        }</span><span class="nc">

        let fileHandler = await FileHandler(log: logger)
        let urlSession = URLSession.shared

        var secrets: SecretsHandlerProtocol
        var authenticator: AppleAuthenticatorProtocol
        var downloader: AppleDownloaderProtocol

        if let region </span><span class="nc">{
            let awsSecrets = try await SecretsStorageAWS(region: region, profileName: profileName, log: logger)</span><span class="nc">
            secrets = awsSecrets
        }</span><span class="nc"> else </span><span class="nc">{
            secrets = await SecretsStorageFile(log: logger)
        }</span><span class="nc">

        authenticator = await AppleAuthenticator(secrets: secrets, urlSession: urlSession, log: logger)
        downloader = await AppleDownloader(secrets: secrets, urlSession: urlSession, fileHandler: fileHandler, log: logger)

        let deps = await AppDependencies(
            fileHandler: fileHandler,
            display: NooraDisplay(),
            readLine: NooraReadLine(),
            progressBar: CLIProgressBar(),
            secrets: secrets,
            authenticator: authenticator,
            downloader: downloader,
            urlSessionData: urlSession,
            shell: SystemShell(),
            log: logger
        )

        return await XCodeInstall(log: logger, deps: deps)</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f20" style="display: none"><span>//
//  CLIStoreSecrets.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 01/09/2022.
//

import ArgumentParser
import Logging

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension MainCommand {

    struct StoreSecrets: AsyncParsableCommand {
        nonisolated static let configuration =
            CommandConfiguration(
                commandName: "storesecrets",
                abstract: "Store your Apple Developer Portal username and password in AWS Secrets Manager"
            )

        @OptionGroup var globalOptions: GlobalOptions

        // repeat of CloudOption but this time mandatory
        @Option(
            name: [.customLong("secretmanager-region"), .short],
            help: "Instructs to use AWS Secrets Manager to store and read secrets in the given AWS Region"
        )
        var secretManagerRegion: String

        @Option(
            name: [.customLong("profile"), .customShort("p")],
            help: "The AWS profile name to use for authentication (from ~/.aws/credentials and ~/.aws/config)"
        )
        var profileName: String?

        func run() async throws </span><span class="nc">{
            try await run(with: nil)</span><span class="nc">
        }</span><span class="">

        func run(with deps: AppDependencies?) async throws </span><span class="c">{
            let xci = try await MainCommand.XCodeInstaller(
                with: deps,
                for: secretManagerRegion,
                profileName: profileName,
                verbose: globalOptions.verbose
            )</span><span class="c">

            do </span><span class="c">{
                _ = try await xci.storeSecrets()</span><span class="c">
            }</span><span class="c"> catch </span><span class="nc">{
                try? await xci.deps.secrets?.shutdown()
                throw ExitCode.failure
            }</span><span class="c">

            // Gracefully shut down AWS client before process exits
            // to avoid RotatingCredentialProvider crash during deallocation
            try? await xci.deps.secrets?.shutdown()
        }</span><span class="">
    }

}

</span></pre><pre id="f21" style="display: none"><span>//
//  NooraDisplay.swift
//  xcodeinstall
//
//  Noora-backed DisplayProtocol implementation
//

import Noora

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

final class NooraDisplay: DisplayProtocol {
    private let noora = </span><span class="nc">Noora()</span><span class="">

    func display(_ msg: String, terminator: String, style: DisplayStyle) </span><span class="nc">{
        switch </span><span class="nc">style</span><span class="nc"> {
        </span><span class="nc">case .normal:
            let styledText: TerminalText = TerminalText("\(msg)\(terminator)")
            noora.passthrough(styledText, pipeline: .output)</span><span class="nc">            
        </span><span class="nc">case .success:
            noora.success(SuccessAlert(stringLiteral: msg))</span><span class="nc">
        </span><span class="nc">case .error(let nextSteps):
            if </span><span class="nc">nextSteps.isEmpty</span><span class="nc"> </span><span class="nc">{
                noora.error(ErrorAlert(stringLiteral: msg))
            }</span><span class="nc"> else </span><span class="nc">{
                let takeaways = nextSteps.map </span><span class="nc">{ TerminalText(stringLiteral: $0) }</span><span class="nc">
                noora.error(.alert(TerminalText(stringLiteral: msg), takeaways: takeaways))
            }
        </span><span class="nc">case .warning:
            noora.warning(WarningAlert(stringLiteral: msg))</span><span class="nc">
        </span><span class="nc">case .info:
            noora.info(InfoAlert(stringLiteral: msg))</span><span class="nc">
        </span><span class="nc">case .security:
            let styledText: TerminalText = TerminalText("üîê \(msg)\(terminator)")
            noora.passthrough(styledText, pipeline: .output)</span><span class="nc">            
        }</span><span class="nc">
    }</span><span class="">
}

</span></pre><pre id="f22" style="display: none"><span>//
//  NooraReadLine.swift
//  xcodeinstall
//
//  Noora-backed ReadLineProtocol implementation
//

import Noora

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

final class NooraReadLine: ReadLineProtocol {
    func readLine(prompt: String, silent: Bool) -&gt; String? </span><span class="nc">{
        if </span><span class="nc">silent</span><span class="nc"> </span><span class="nc">{
            guard let password = getpass(prompt) else </span><span class="nc">{
                return nil
            }</span><span class="nc">
            return String(cString: password)</span><span class="nc">
        } else </span><span class="nc">{
            print(prompt, terminator: "")
            return Swift.readLine()
        }</span><span class="nc">
    }</span><span class="">
}

</span></pre><pre id="f23" style="display: none"><span>//
//  ProgressBar.swift
//  xcodeinstall
//
//  Internalized from CLIlib ‚Äî progress bar infrastructure
//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

// MARK: - OutputBuffer (from CLIlib/progressbar/OutputBuffer.swift)

protocol OutputBuffer {
    func write(_ text: String)
    func clear()
}

class StringBuffer: OutputBuffer {
    private(set) var string: String = </span><span class="nc">""</span><span class="">

    func write(_ text: String) </span><span class="nc">{
        string.append(text)
    }</span><span class="">

    func clear() </span><span class="nc">{
        string = ""
    }</span><span class="">
}

extension FileHandle: OutputBuffer {

    func write(_ text: String) </span><span class="nc">{
        guard let textData = text.data(using: .utf8) else </span><span class="nc">{ return }</span><span class="nc">

        // Combine \r + text into a single write to avoid recursive calls
        var payload = Data()
        payload.append(0x0D)  // \r ‚Äî carriage return to beginning of line
        payload.append(textData)
        self.write(payload)
    }</span><span class="">

    func clear() </span><span class="nc">{
        guard let data = "\u{001B}[2K\r".data(using: .utf8) else </span><span class="nc">{ return }</span><span class="nc">
        self.write(data)
    }</span><span class="">
}

// MARK: - ProgressUpdateProtocol &amp; ProgressBarType (from CLIlib/progressbar/ProgressBar.swift)

@MainActor
protocol ProgressUpdateProtocol {
    /// Update the animation with a new step.
    func update(step: Int, total: Int, text: String)

    /// Complete the animation.
    func complete(success: Bool)

    /// Clear the animation.
    func clear()
}

enum ProgressBarType {
    // 30% [============--------------------]
    case percentProgressAnimation

    // [ 1/2 ]
    case countingProgressAnimation

    // [ 1/2 ]
    // [ 2/2 ]
    case countingProgressAnimationMultiLine
}

// MARK: - ProgressBar (from CLIlib/progressbar/ProgressBar.swift)

@MainActor
class ProgressBar: ProgressUpdateProtocol {

    private let progressBarType: ProgressBarType
    private var output: OutputBuffer
    private let title: String?
    private var titlePrinted = </span><span class="nc">false</span><span class="">

    private let bold = </span><span class="nc">"\u{001B}[1m"</span><span class="">
    private let blue = </span><span class="nc">"\u{001B}[0;34m"</span><span class="">
    private let reset = </span><span class="nc">"\u{001B}[0;0m"</span><span class="">

    var width: Int = </span><span class="nc">60</span><span class="">
    var fullSign: String = </span><span class="nc">"="</span><span class="">
    var emptySign: String = </span><span class="nc">"-"</span><span class="">

    init(output: OutputBuffer, progressBarType: ProgressBarType, title: String? = nil) </span><span class="nc">{
        self.output = output
        self.progressBarType = progressBarType
        self.title = title
    }</span><span class="">

    func update(step: Int, total: Int, text: String = "") </span><span class="nc">{

        if </span><span class="nc">(!titlePrinted)</span><span class="nc">, let title </span><span class="nc">{
            printTitle(title)
        }</span><span class="nc">

        switch </span><span class="nc">self.progressBarType</span><span class="nc"> {
        </span><span class="nc">case .percentProgressAnimation:
            percentProgress(step: step, total: total, text: text)</span><span class="nc">

        </span><span class="nc">case .countingProgressAnimation:
            countingProgress(step: step, total: total, text: text)</span><span class="nc">

        </span><span class="nc">case .countingProgressAnimationMultiLine:
            countingProgressMultiLine(step: step, total: total, text: text)</span><span class="nc">
        }</span><span class="nc">
    }</span><span class="">

    func clear() </span><span class="nc">{
        output.clear()

        if </span><span class="nc">titlePrinted</span><span class="nc"> </span><span class="nc">{
            output.write("\u{001B}[1A")
            output.clear()
        }</span><span class="nc">
    }</span><span class="">

    func complete(success: Bool) </span><span class="nc">{
        if </span><span class="nc">success</span><span class="nc"> </span><span class="nc">{
            output.write("[ OK ]\n")
        }</span><span class="nc"> else </span><span class="nc">{
            output.write("[ Error ]\n")
        }</span><span class="nc">
    }</span><span class="">

    private func percentProgress(step: Int, total: Int, text: String = "") </span><span class="nc">{
        let progress = Float(step) / Float(total)
        let numberOfBars = Int(floor(progress * Float(width)))
        let numberOfTicks = width - numberOfBars
        let bars = fullSign * numberOfBars
        let ticks = emptySign * numberOfTicks

        let percentage = Int(floor(progress * 100))
        var string = ""
        string += "\(percentage)% "
        string += "[\(bars)\(ticks)]"
        if </span><span class="nc">text.count &gt; 0</span><span class="nc"> </span><span class="nc">{
            string += " \(text)"
        }</span><span class="nc">
        output.write(string)

        if </span><span class="nc">step &gt;= total</span><span class="nc"> </span><span class="nc">{
            output.write("\n")
        }</span><span class="nc">
    }</span><span class="">

    private func countingProgress(step: Int, total: Int, text: String = "") </span><span class="nc">{
        output.clear()
        output.write("[\(step)/\(total)] \(text)")
        if </span><span class="nc">step &gt;= total</span><span class="nc"> </span><span class="nc">{
            output.write("\n")
        }</span><span class="nc">
    }</span><span class="">

    private func countingProgressMultiLine(step: Int, total: Int, text: String = "") </span><span class="nc">{
        output.write("[\(step)/\(total)] \(text)\n")
    }</span><span class="">

    private func printTitle(_ title: String) </span><span class="nc">{

        switch </span><span class="nc">self.progressBarType</span><span class="nc"> {
        </span><span class="nc">case .percentProgressAnimation:
            let numberOfSpaces = self.width - title.count
            let prefix = " " * ((numberOfSpaces / 2) + "99% [".count)
            output.write("\(prefix)\(blue)\(bold)\(title)\(reset)\n")</span><span class="nc">

        </span><span class="nc">default:
            output.write("\(blue)\(bold)\(title)\(reset)\n")</span><span class="nc">
        }</span><span class="nc">

        self.titlePrinted = true
    }</span><span class="">
}

extension String {
    static func * (char: String, count: Int) -&gt; String </span><span class="nc">{
        var str = ""
        for _ in 0..&lt;count </span><span class="nc">{
            str.append(char)
        }</span><span class="nc">
        return str</span><span class="nc">
    }</span><span class="">
}

// MARK: - CLIProgressBar (moved from CLI-driver/CLIProgressBar.swift)

protocol CLIProgressBarProtocol: ProgressUpdateProtocol {
    func define(animationType: ProgressBarType, message: String)
}

class CLIProgressBar: CLIProgressBarProtocol {

    private var progressAnimation: ProgressUpdateProtocol?
    private var message: String?
    private let stream: OutputBuffer = </span><span class="nc">FileHandle.standardOutput</span><span class="">

    func define(animationType: ProgressBarType, message: String) </span><span class="nc">{
        self.message = message
        self.progressAnimation = ProgressBar(
            output: stream,
            progressBarType: animationType,
            title: self.message
        )
    }</span><span class="">

    func update(step: Int, total: Int, text: String) </span><span class="nc">{
        self.progressAnimation?.update(step: step, total: total, text: text)
    }</span><span class="">

    func complete(success: Bool) </span><span class="nc">{
        self.progressAnimation?.complete(success: success)
    }</span><span class="">

    func clear() </span><span class="nc">{
        self.progressAnimation?.clear()
    }</span><span class="">
}

</span></pre><pre id="f24" style="display: none"><span>//
//  Protocols.swift
//  xcodeinstall
//
//  Migrated from CLIlib ‚Äî local protocol definitions
//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

// MARK: - Display

enum DisplayStyle {
    case normal
    case success
    case error(nextSteps: [String] = [])
    case warning
    case info
    case security
}

@MainActor
protocol DisplayProtocol: Sendable {
    func display(_ msg: String, terminator: String, style: DisplayStyle)
}

extension DisplayProtocol {
    func display(_ msg: String, terminator: String = "\n") </span><span class="c">{
        display(msg, terminator: terminator, style: .normal)
    }</span><span class="">
    func display(_ msg: String, style: DisplayStyle) </span><span class="c">{
        display(msg, terminator: "\n", style: style)
    }</span><span class="">
}

// MARK: - ReadLine

@MainActor
protocol ReadLineProtocol: Sendable {
    func readLine(prompt: String, silent: Bool) -&gt; String?
}

</span></pre><pre id="f25" style="display: none"><span>//
//  SecretsHandler.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 19/07/2022.
//

import Foundation

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

protocol Secrets {
    func data() throws -&gt; Data
    func string() throws -&gt; String?
}

// Generic error type for secrets storage operations shared across all backends
enum SecretsStorageError: Error, LocalizedError {
    case invalidOperation  // when an operation is not supported by the current backend

    var errorDescription: String? </span><span class="nc">{
        switch </span><span class="nc">self</span><span class="nc"> {
        </span><span class="nc">case .invalidOperation:
            return "Invalid operation for the current secrets storage backend"</span><span class="nc">
        }
    }</span><span class="">
}

// the data to be stored in Secrets Manager as JSON
struct AppleCredentialsSecret: Codable, Secrets {

    let username: String
    let password: String

    func data() throws -&gt; Data </span><span class="nc">{
        try JSONEncoder().encode(self)</span><span class="nc">
    }</span><span class="">

    func string() throws -&gt; String? </span><span class="nc">{
        String(data: try self.data()</span><span class="nc">, encoding: .utf8)
    }</span><span class="">

    init(fromData data: Data) throws </span><span class="nc">{
        self = try JSONDecoder().decode(AppleCredentialsSecret.self, from: data)</span><span class="nc">
    }</span><span class="">

    init(fromString string: String) throws </span><span class="nc">{
        if let data = string.data(using: .utf8) </span><span class="nc">{
            try self.init(fromData: data)</span><span class="nc">
        }</span><span class="nc"> else </span><span class="nc">{
            fatalError(</span><span class="nc">"Can not create data from string : \(string)"</span><span class="nc">)
        }</span><span class="nc">
    }</span><span class="">

    init(username: String = "", password: String = "") </span><span class="c">{
        self.username = username
        self.password = password
    }</span><span class="">

}

protocol SecretsHandlerProtocol: Sendable {

    func clearSecrets() async throws

    //    func clearSecrets(preserve: Bool)
    //    func restoreSecrets()

    func saveCookies(_ cookies: String?) async throws -&gt; String?
    func loadCookies() async throws -&gt; [HTTPCookie]

    func saveSession(_ session: AppleSession) async throws -&gt; AppleSession
    func loadSession() async throws -&gt; AppleSession?

    func retrieveAppleCredentials() async throws -&gt; AppleCredentialsSecret
    func storeAppleCredentials(_ credentials: AppleCredentialsSecret) async throws

    /// Gracefully shut down any underlying resources (e.g. AWS clients).
    /// Default implementation is a no-op for backends that don't need it.
    func shutdown() async throws
}

extension SecretsHandlerProtocol {

    // Default no-op for backends that don't need cleanup
    func shutdown() async throws </span><span class="nc">{}</span><span class="">

    ///
    /// Merge given cookies with the one stored already
    ///
    /// - Parameters
    ///     - cookies : the new cookies to store (or to append)
    ///
    /// - Returns : the new string with all cookies
    ///
    func mergeCookies(existingCookies: [HTTPCookie], newCookies: String?) async throws -&gt; String? </span><span class="c">{

        guard let cookieString = newCookies else </span><span class="nc">{
            return nil
        }</span><span class="c">

        var result = existingCookies

        // transform received cookie string into [HTTPCookie]
        let newCookies = cookieString.cookies()

        // merge cookies, new values have priority

        // browse new cookies
        for newCookie in newCookies </span><span class="c">{

            // if a newCookie match an existing one
            if </span><span class="c">(existingCookies.contains </span><span class="c">{ cookie in cookie.name == newCookie.name }</span><span class="c">) </span><span class="c">{

                // replace old with new
                // assuming there is only one !!
                result.removeAll </span><span class="c">{ cookie in cookie.name == newCookie.name }</span><span class="c">
                result.append(newCookie)
            }</span><span class="c"> else </span><span class="c">{
                // add new to existing
                result.append(newCookie)
            }</span><span class="c">

        }</span><span class="c">

        // save new set of cookie as string
        return result.string()</span><span class="c">

    }</span><span class="">
}

extension String {

    func cookies() -&gt; [HTTPCookie] </span><span class="c">{
        var fakeHttpHeader = [String: String]()
        fakeHttpHeader["Set-Cookie"] = self
        // only cookies from this domain or subdomains are going to be created
        return HTTPCookie.cookies(
            withResponseHeaderFields: fakeHttpHeader,
            for: URL(string: "https://apple.com")!
        )

    }</span><span class="">

}

extension Array where Element == HTTPCookie {

    func string() -&gt; String? </span><span class="c">{

        var cookieString = ""

        // for each cookie
        for cookie in self </span><span class="c">{

            if let props = cookie.properties </span><span class="c">{

                // return all properties as an array of strings with key=value
                var cookieAsString = props.map </span><span class="c">{ (key: HTTPCookiePropertyKey, value: Any) -&gt; String in
                    switch </span><span class="c">key.rawValue</span><span class="c"> {
                    // boolean values are handled separately
                    </span><span class="c">case "Secure": return "Secure"</span><span class="c">
                    </span><span class="c">case "HttpOnly": return "HttpOnly"</span><span class="c">
                    </span><span class="c">case "Discard": return ""</span><span class="c">

                    // name and value are handled separately to produce name=value
                    // (and not Name=name and Value=value)
                    </span><span class="c">case "Name": return ""</span><span class="c">
                    </span><span class="c">case "Value": return ""</span><span class="c">

                    </span><span class="c">default: return "\(key.rawValue)=\(value)"</span><span class="c">
                    }
                }</span><span class="c">

                // remove empty strings
                cookieAsString.removeAll </span><span class="c">{ string in string == "" }</span><span class="c">

                // add a coma in between cookies
                if </span><span class="c">cookieString != ""</span><span class="c"> </span><span class="c">{
                    cookieString += ", "
                }</span><span class="c">

                // add name=value
                if let name = props[HTTPCookiePropertyKey.name] as? String,
                    let value = props[HTTPCookiePropertyKey.value] as? String
                </span><span class="c">{
                    cookieString += "\(name)=\(value); "
                }</span><span class="c"> else </span><span class="nc">{
                    fatalError(</span><span class="nc">"Cookie string has no name or value values"</span><span class="nc">)
                }</span><span class="c">

                // concatenate all strings, spearated by a coma
                cookieString += cookieAsString.joined(separator: "; ")
            }
        }</span><span class="c">

        // remove last
        return cookieString</span><span class="c">
    }</span><span class="">

}

</span></pre><pre id="f26" style="display: none"><span>//
//  SecretsStorageAWS+Soto.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 04/09/2022.
//

import Logging
import SotoSecretsManager

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

// use a class to have a chance to call client.shutdown() at deinit
final class SecretsStorageAWSSoto: SecretsStorageAWSSDKProtocol {

    let log: Logger
    let maxRetries = </span><span class="c">3</span><span class="">
    let profileName: String?

    let awsClient: AWSClient?  // var for injection
    let smClient: SecretsManager?  // var for injection

    private init(awsClient: AWSClient? = nil, smClient: SecretsManager? = nil, profileName: String? = nil, log: Logger) </span><span class="c">{
        self.awsClient = awsClient
        self.smClient = smClient
        self.profileName = profileName
        self.log = log
    }</span><span class="">

    static func forRegion(_ region: String, profileName: String? = nil, log: Logger) throws -&gt; SecretsStorageAWSSDKProtocol </span><span class="c">{
        try SecretsStorageAWSSoto.forRegion(region, profileName: profileName, awsClient: nil, smClient: nil, log: log)</span><span class="c">
    }</span><span class="">
    static func forRegion(
        _ region: String,
        profileName: String? = nil,
        awsClient: AWSClient? = nil,
        smClient: SecretsManager? = nil,
        log: Logger
    ) throws -&gt; SecretsStorageAWSSDKProtocol </span><span class="c">{
        guard let awsRegion = Region(awsRegionName: region) else </span><span class="c">{
            throw SecretsStorageAWSError.invalidRegion(region: region)
        }</span><span class="c">
        var newAwsClient: AWSClient? = nil
        if </span><span class="c">awsClient == nil</span><span class="c"> </span><span class="c">{
            newAwsClient = AWSClient(
                credentialProvider: .selector(
                    .environment,
                    .ec2,
                    .configFile(profile: profileName),
                    .login(profileName: profileName)
                ),
                retryPolicy: .jitter()
            )
        }</span><span class="c">
        var newSMClient: SecretsManager?
        if </span><span class="c">smClient == nil</span><span class="c"> </span><span class="c">{
            newSMClient = SecretsManager(
                client: awsClient ?? </span><span class="c">newAwsClient!</span><span class="c">,
                region: awsRegion
            )
        }</span><span class="c">
        return SecretsStorageAWSSoto(
            awsClient: awsClient ?? </span><span class="c">newAwsClient!</span><span class="c">,
            smClient: smClient ?? </span><span class="c">newSMClient!</span><span class="c">,
            profileName: profileName,
            log: log
        )</span><span class="c">
    }</span><span class="">

    /// Wraps CredentialProviderError with profile context for better diagnostics
    private func wrapCredentialError(_ error: Error) -&gt; Error </span><span class="nc">{
        if </span><span class="nc">error is CredentialProviderError</span><span class="nc"> </span><span class="nc">{
            return SecretsStorageAWSError.noCredentialProvider(
                profileName: profileName,
                underlyingError: error
            )
        }</span><span class="nc">
        return error</span><span class="nc">
    }</span><span class="">

    private var isShutdown = </span><span class="c">false</span><span class="">

    func shutdown() async throws </span><span class="nc">{
        guard !isShutdown else </span><span class="nc">{ return }</span><span class="nc">
        isShutdown = true
        try await self.awsClient?.shutdown()</span><span class="nc">
    }</span><span class="">

    deinit </span><span class="c">{
        // Async shutdown should have been called already.
        // syncShutdown here is a last-resort safety net ‚Äî silently ignore failures.
        if </span><span class="c">!isShutdown</span><span class="c"> </span><span class="c">{
            try? self.awsClient?.syncShutdown()
        }</span><span class="c">
    }</span><span class="">

    // MARK: private functions - AWS SecretsManager Call using Soto SDK

    //    func list() async throws {
    //        print("calling list secrets")
    //        let request = SecretsManager.ListSecretsRequest()
    //        _ = try await smClient.listSecrets(request)
    //    }

    ///
    /// Create a secret in AWS SecretsManager
    /// - Parameters:
    ///     - secretId : the name of the secret
    ///     - secretValue : a string to store as a secret
    /// - Throws:
    ///         This function throws error from the underlying SDK
    ///
    private func createSecret(secretId: String, secretValue: Secrets) async throws </span><span class="nc">{
        do </span><span class="nc">{
            let secretString = try secretValue.string()</span><span class="nc">
            let createSecretRequest = SecretsManager.CreateSecretRequest(
                description: "xcodeinstall secret",
                name: secretId,
                secretString: secretString
            )
            _ = try await smClient?.createSecret(createSecretRequest)</span><span class="nc">
        }</span><span class="nc"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Can not create secret \(secretId) : \(error)"</span><span class="nc">)
            throw error
        }</span><span class="nc">
    }</span><span class="">

    ///
    ///  Execute an API call AWS SecretsManager and create the secret when the secret name does not exist.
    ///  Aftre creating the secret, the API call is attempted again.  The function tries 3 times before abording
    ///
    /// - Parameters:
    ///     - secretId : the name of the secret
    ///     - secretValue : a string to store as a secret,
    ///     - step: the current retry step (start at 1)
    ///     - block: the block of code to execute (contains the call to SecretsManager)
    /// - Throws:
    ///         This function throws error from the underlying SDK
    ///

    private func executeRequestAndCreateWhenNotExist(
        secretId: String,
        secretValue: Secrets,
        step: Int,
        block: () async throws -&gt; Void
    ) async throws </span><span class="nc">{

        do </span><span class="nc">{
            // try to execute the supplied block
            try await block()</span><span class="nc">

            // if it fails with a resource not found error,
        }</span><span class="nc"> catch let error as SotoSecretsManager.SecretsManagerErrorType </span><span class="nc">{

            // create the resource and try again
            if </span><span class="nc">error == .resourceNotFoundException</span><span class="nc"> </span><span class="nc">{
                log.debug</span><span class="nc">(</span><span class="nc">"Secrets \(secretId) does not exist, creating it"</span><span class="nc">)
                try await self.createSecret(secretId: secretId, secretValue: secretValue)</span><span class="nc">

                if </span><span class="nc">step &lt;= maxRetries</span><span class="nc"> </span><span class="nc">{
                    // recursive call to ourselevs
                    log.debug</span><span class="nc">(</span><span class="nc">"Re-trying the block call (attempt #\(step + 1))"</span><span class="nc">)
                    try await self.executeRequestAndCreateWhenNotExist(
                        secretId: secretId,
                        secretValue: secretValue,
                        step: step + 1,
                        block: block
                    )</span><span class="nc">
                }</span><span class="nc"> else </span><span class="nc">{
                    log.error</span><span class="nc">(</span><span class="nc">"Max attempt to call Secrets Manager"</span><span class="nc">)
                }</span><span class="nc">

            }</span><span class="nc"> else </span><span class="nc">{
                log.error</span><span class="nc">(</span><span class="nc">"AWS API Error\n\(error)"</span><span class="nc">)
                throw error
            }</span><span class="nc">

        }</span><span class="nc">
    }</span><span class="">

    ///
    ///  Update an existing secret
    ///
    ///  - Parameters
    ///     - secretId : the name of the secret
    ///     - newValue : the updated value
    /// - Throws:
    ///         This function throws error from the underlying SDK
    ///
    func updateSecret&lt;T: Secrets&gt;(secretId: AWSSecretsName, newValue: T) async throws </span><span class="nc">{
        do </span><span class="nc">{

            // maybe the secret does not exist yet - so wrap our call with
            // a function hat will create it in case it does not exist
            try await executeRequestAndCreateWhenNotExist(
                secretId: secretId.rawValue,
                secretValue: newValue,
                step: 1,
                block: </span><span class="nc">{

                    let secretString = try newValue.string()</span><span class="nc">
                    let putSecretRequest = SecretsManager.PutSecretValueRequest(
                        secretId: secretId.rawValue,
                        secretString: secretString
                    )

                    log.debug</span><span class="nc">(</span><span class="nc">"Updating secret \(secretId) with \(newValue)"</span><span class="nc">)
                    let putSecretResponse = try await smClient?.putSecretValue(putSecretRequest)</span><span class="nc">
                    log.debug</span><span class="nc">(</span><span class="nc">
                        </span><span class="nc">"\(putSecretResponse?.name ?? </span><span class="nc">""</span><span class="nc">) has version \(putSecretResponse?.versionId ?? </span><span class="nc">""</span><span class="nc">)"
                    )
                }
            )</span><span class="nc">

        }</span><span class="nc"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Unexpected error while updating secrets\n\(error)"</span><span class="nc">)
            throw wrapCredentialError(error)
        }</span><span class="nc">
    }</span><span class="">

    // FIXME: improve error handling when secret is not retrieved
    // swiftlint:disable force_cast
    func retrieveSecret&lt;T: Secrets&gt;(secretId: AWSSecretsName) async throws -&gt; T </span><span class="nc">{
        do </span><span class="nc">{
            let getSecretRequest = SecretsManager.GetSecretValueRequest(secretId: secretId.rawValue)
            log.debug</span><span class="nc">(</span><span class="nc">"Retrieving secret \(secretId)"</span><span class="nc">)
            let getSecretResponse = try await smClient?.getSecretValue(getSecretRequest)</span><span class="nc">
            log.debug</span><span class="nc">(</span><span class="nc">"Secret \(getSecretResponse?.name ?? </span><span class="nc">"nil"</span><span class="nc">) retrieved")

            guard let secret = getSecretResponse?.secretString else </span><span class="nc">{
                log.error</span><span class="nc">(</span><span class="nc">"‚ö†Ô∏è no value returned by AWS Secrets Manager secret \(secretId)"</span><span class="nc">)
                return secretId == .appleCredentials
                    ? </span><span class="nc">AppleCredentialsSecret() as! T</span><span class="nc"> : </span><span class="nc">AppleSessionSecret() as! T</span><span class="nc">
            }</span><span class="nc">

            switch </span><span class="nc">secretId</span><span class="nc"> {
            </span><span class="nc">case .appleCredentials:
                return try AppleCredentialsSecret(fromString: secret)</span><span class="nc"> as! T</span><span class="nc">
            </span><span class="nc">case .appleSessionToken:
                return try AppleSessionSecret(fromString: secret)</span><span class="nc"> as! T</span><span class="nc">
            }

        } catch let error as SotoSecretsManager.SecretsManagerErrorType
            where error == .resourceNotFoundException
        </span><span class="nc">{
            log.debug</span><span class="nc">(</span><span class="nc">"Secret \(secretId.rawValue) does not exist in AWS Secrets Manager"</span><span class="nc">)
            throw error

        } catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Unexpected error while retrieving secrets\n\(error)"</span><span class="nc">)
            throw wrapCredentialError(error)

        }

    }</span><span class="">
    // swiftlint:enable force_cast

}

</span></pre><pre id="f27" style="display: none"><span>//
//  SecretsStorageAWS.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 01/09/2022.
//

import Logging

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

// the errors thrown by the SecretsManager class
enum SecretsStorageAWSError: Error, LocalizedError {
    case invalidRegion(region: String)
    case secretDoesNotExist(secretname: String)
    case noCredentialProvider(profileName: String?, underlyingError: Error)

    var errorDescription: String? </span><span class="nc">{
        switch </span><span class="nc">self</span><span class="nc"> {
        </span><span class="nc">case .invalidRegion(let region):
            return "Invalid AWS region: '\(region)'"</span><span class="nc">
        </span><span class="nc">case .secretDoesNotExist(let secretname):
            return "AWS secret '\(secretname)' does not exist"</span><span class="nc">
        </span><span class="nc">case .noCredentialProvider(let profileName, let underlyingError):
            if let profileName </span><span class="nc">{
                return "No AWS credentials found for profile '\(profileName)'. "
                    + "Verify the profile exists in ~/.aws/credentials or ~/.aws/config. "
                    + "Underlying error: \(underlyingError)"
            }</span><span class="nc"> else </span><span class="nc">{
                return "No AWS credential provider found. "
                    + "Configure credentials via environment variables, ~/.aws/credentials, or an EC2 instance profile. "
                    + "Underlying error: \(underlyingError)"
            }</span><span class="nc">
        }
    }</span><span class="">
}

// the names we are using to store the secrets
enum AWSSecretsName: String {
    case appleCredentials = "xcodeinstall-apple-credentials"
    case appleSessionToken = "xcodeinstall-apple-session-token"
}

// the data to be stored in Secrets Manager as JSON
struct AppleSessionSecret: Codable, Secrets {
    var rawCookies: String?
    var session: AppleSession?

    func data() throws -&gt; Data </span><span class="c">{
        try JSONEncoder().encode(self)</span><span class="c">
    }</span><span class="">

    func string() throws -&gt; String? </span><span class="c">{
        String(data: try self.data()</span><span class="c">, encoding: .utf8)
    }</span><span class="">

    func cookies() -&gt; [HTTPCookie] </span><span class="c">{
        rawCookies != nil ? </span><span class="c">rawCookies!.cookies()</span><span class="c"> : </span><span class="c">[]</span><span class="c">
    }</span><span class="">

    init(fromData data: Data) throws </span><span class="c">{
        self = try JSONDecoder().decode(AppleSessionSecret.self, from: data)</span><span class="c">
    }</span><span class="">

    init(fromString string: String) throws </span><span class="c">{
        if let data = string.data(using: .utf8) </span><span class="c">{
            try self.init(fromData: data)</span><span class="c">
        }</span><span class="c"> else </span><span class="nc">{
            fatalError(</span><span class="nc">"Can not create data from string : \(string)"</span><span class="nc">)
        }</span><span class="c">
    }</span><span class="">

    init(cookies: String? = nil, session: AppleSession? = nil) </span><span class="c">{
        self.rawCookies = cookies
        self.session = session
    }</span><span class="">

}

// the methods that must be implemented by the class encapsulating the SDK we are using
protocol SecretsStorageAWSSDKProtocol {
    static func forRegion(_ region: String, profileName: String?, log: Logger) throws -&gt; SecretsStorageAWSSDKProtocol
    func updateSecret&lt;T: Secrets&gt;(secretId: AWSSecretsName, newValue: T) async throws
    func retrieveSecret&lt;T: Secrets&gt;(secretId: AWSSecretsName) async throws -&gt; T
    func shutdown() async throws
}

// permissions needed
// secretsmanager:CreateSecret
// secretsmanager:TagResource ?
// secretsmanager:GetSecretValue
// secretsmanager:PutSecretValue

class SecretsStorageAWS: SecretsHandlerProtocol {
    let log: Logger
    let awsSDK: SecretsStorageAWSSDKProtocol
    public init(sdk: SecretsStorageAWSSDKProtocol? = nil, region: String = "us-east-1", profileName: String? = nil, log: Logger) throws </span><span class="c">{
        self.log = log
        if let sdk </span><span class="c">{
            self.awsSDK = sdk
        }</span><span class="c"> else </span><span class="nc">{
            self.awsSDK = try SecretsStorageAWSSoto.forRegion(region, profileName: profileName, log: self.log)</span><span class="nc">
        }</span><span class="c">
    }</span><span class="">

    // MARK: protocol implementation

    func shutdown() async throws </span><span class="c">{
        try await awsSDK.shutdown()</span><span class="c">
    }</span><span class="">

    // I do not delete the secrets because there is a 30 days deletion policy
    // https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html
    // Instead, I update the secret value with an empty secret
    func clearSecrets() async throws </span><span class="c">{

        let emptySession = AppleSessionSecret()
        try await self.awsSDK.updateSecret(
            secretId: AWSSecretsName.appleSessionToken,
            newValue: emptySession
        )</span><span class="c">

    }</span><span class="">

    func saveCookies(_ cookies: String?) async throws -&gt; String? </span><span class="c">{
        guard let cookieString = cookies else </span><span class="nc">{
            return nil
        }</span><span class="c">

        var result: String? = cookieString

        do </span><span class="c">{

            // read existing cookies and session
            let existingSession: AppleSessionSecret =
                try await self.awsSDK.retrieveSecret(secretId: AWSSecretsName.appleSessionToken)</span><span class="c">

            // append the new cookies and return the whole new thing
            result = try await mergeCookies(
                existingCookies: existingSession.cookies(),
                newCookies: cookies
            )</span><span class="c">

            // create a new session secret object with merged cookies and existing session
            let newSession = AppleSessionSecret(cookies: result, session: existingSession.session)

            // save this new session secret object
            try await self.awsSDK.updateSecret(
                secretId: AWSSecretsName.appleSessionToken,
                newValue: newSession
            )</span><span class="c">

        }</span><span class="c"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"‚ö†Ô∏è can not save cookies file in AWS Secret Manager: \(error)"</span><span class="nc">)
            throw error
        }</span><span class="c">

        return result</span><span class="c">

    }</span><span class="">

    func loadCookies() async throws -&gt; [HTTPCookie] </span><span class="c">{
        do </span><span class="c">{
            let session: AppleSessionSecret = try await self.awsSDK.retrieveSecret(
                secretId: AWSSecretsName.appleSessionToken
            )</span><span class="c">
            let result = session.cookies()
            return result</span><span class="c">
        } catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Error when trying to load session : \(error)"</span><span class="nc">)
            throw error
        }</span><span class="c">
    }</span><span class="">

    func saveSession(_ newSession: AppleSession) async throws -&gt; AppleSession </span><span class="c">{

        do </span><span class="c">{

            // read existing cookies and session
            let existingSession: AppleSessionSecret =
                try await self.awsSDK.retrieveSecret(secretId: AWSSecretsName.appleSessionToken)</span><span class="c">

            // create a new session secret object with existing cookies and new session
            let newSessionSecret = AppleSessionSecret(
                cookies: existingSession.rawCookies,
                session: newSession
            )

            try await self.awsSDK.updateSecret(
                secretId: AWSSecretsName.appleSessionToken,
                newValue: newSessionSecret
            )</span><span class="c">
        }</span><span class="c"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Error when trying to save session : \(error)"</span><span class="nc">)
            throw error
        }</span><span class="c">

        return newSession</span><span class="c">
    }</span><span class="">

    func loadSession() async throws -&gt; AppleSession? </span><span class="c">{

        let sessionSecret: AppleSessionSecret =
            try await self.awsSDK.retrieveSecret(secretId: AWSSecretsName.appleSessionToken)</span><span class="c">
        return sessionSecret.session</span><span class="c">
    }</span><span class="">

    func retrieveAppleCredentials() async throws -&gt; AppleCredentialsSecret </span><span class="nc">{
        do </span><span class="nc">{

            return try await self.awsSDK.retrieveSecret(secretId: AWSSecretsName.appleCredentials)

        }</span><span class="nc"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Error when trying to load session : \(error)"</span><span class="nc">)
            throw error
        }
    }</span><span class="">

    func storeAppleCredentials(_ credentials: AppleCredentialsSecret) async throws </span><span class="c">{
        do </span><span class="c">{

            try await self.awsSDK.updateSecret(
                secretId: AWSSecretsName.appleCredentials,
                newValue: credentials
            )</span><span class="c">

        }</span><span class="c"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"Error when trying to save credentials : \(error)"</span><span class="nc">)
            throw error
        }</span><span class="c">

    }</span><span class="">

}

</span></pre><pre id="f28" style="display: none"><span>//
//  SecretsStorageFile.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 14/08/2022.
//

import Logging

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

// store secrets on files in $HOME/.xcodeinstaller
struct SecretsStorageFile: SecretsHandlerProtocol {
    private let log: Logger
    private var fileManager: FileManager
    private var baseDirectory: URL
    private let cookiesPath: URL
    private let sessionPath: URL
    private let newCookiesPath: URL
    private let newSessionPath: URL

    init(log: Logger) </span><span class="c">{
        self.fileManager = FileManager.default
        self.log = log

        baseDirectory = FileHandler(log: self.log).baseFilePath()

        cookiesPath = baseDirectory.appendingPathComponent("cookies")
        sessionPath = baseDirectory.appendingPathComponent("session")

        newCookiesPath = cookiesPath.appendingPathExtension("copy")
        newSessionPath = sessionPath.appendingPathExtension("copy")
    }</span><span class="">

    // used when testing to start from a clean place
    //    func restoreSecrets() {
    //
    //        // remove file
    //        try? fileManager.removeItem(at: sessionPath)
    //
    //        // copy backup to file
    //        try? fileManager.copyItem(at: newSessionPath, to: sessionPath)
    //
    //        // remove backup
    //        try? fileManager.removeItem(at: newSessionPath)
    //
    //        // do it again with cookies file
    //
    //        try? fileManager.removeItem(at: cookiesPath)
    //        try? fileManager.copyItem(at: newCookiesPath, to: cookiesPath)
    //        try? fileManager.removeItem(at: newCookiesPath)
    //
    //    }

    // used when testing to start from a clean place
    //    func clearSecrets(preserve: Bool = false) {
    func clearSecrets() async throws </span><span class="c">{

        //        if preserve {
        //
        //            // move files instead of deleting them (if they exist)
        //            try? fileManager.copyItem(at: cookiesPath, to: newCookiesPath)
        //            try? fileManager.copyItem(at: sessionPath, to: newSessionPath)
        //
        //        }

        try? fileManager.removeItem(at: cookiesPath)
        try? fileManager.removeItem(at: sessionPath)

    }</span><span class="">

    // save cookies in an HTTPUrlResponse
    // save to ~/.xcodeinstall/cookies
    // merge existing cookies into file when file already exists
    func saveCookies(_ cookies: String?) async throws -&gt; String? </span><span class="c">{

        guard let cookieString = cookies else </span><span class="nc">{
            return nil
        }</span><span class="c">

        var result: String? = cookieString

        do </span><span class="c">{

            // if file exists,
            if </span><span class="c">fileManager.fileExists(atPath: cookiesPath.path)</span><span class="c"> </span><span class="c">{

                // load existing cookies as [HTTPCookie]
                let existingCookies = try await self.loadCookies()</span><span class="c">

                // read it, append the new cookies and save the whole new thing
                result = try await mergeCookies(existingCookies: existingCookies, newCookies: cookies)</span><span class="c">
                try result?.data(using: .utf8)!.write(to: cookiesPath)</span><span class="c">

            }</span><span class="c"> else </span><span class="c">{

                // otherwise, just save the cookies
                try cookieString.data(using: .utf8)!.write(to: cookiesPath)</span><span class="c">
            }</span><span class="c">
        }</span><span class="c"> catch </span><span class="nc">{
            log.error</span><span class="nc">(</span><span class="nc">"‚ö†Ô∏è can not write cookies file: \(error)"</span><span class="nc">)
            throw error
        }</span><span class="c">

        return result</span><span class="c">

    }</span><span class="">

    // retrieve cookies
    func loadCookies() async throws -&gt; [HTTPCookie] </span><span class="c">{

        // read the raw file saved on disk
        let cookieLongString = try String(contentsOf: cookiesPath, encoding: .utf8)</span><span class="c">
        let result = cookieLongString.cookies()
        return result</span><span class="c">
    }</span><span class="">

    // save Apple Session values as JSON
    func saveSession(_ session: AppleSession) async throws -&gt; AppleSession </span><span class="c">{

        // save session
        try session.data()</span><span class="c">.write(to: sessionPath)</span><span class="c">

        return session</span><span class="c">
    }</span><span class="">

    // load Apple Session from JSON
    // returns nil when can not read file
    func loadSession() async throws -&gt; AppleSession? </span><span class="c">{

        // read the raw file saved on disk
        let sessionData = try Data(contentsOf: sessionPath)</span><span class="c">
        return try AppleSession(fromData: sessionData)</span><span class="c">
    }</span><span class="">

    //MARK: these operations are only valid on SecretsStorageAWS
    func retrieveAppleCredentials() async throws -&gt; AppleCredentialsSecret </span><span class="nc">{
        throw SecretsStorageError.invalidOperation
    }</span><span class="">
    func storeAppleCredentials(_ credentials: AppleCredentialsSecret) async throws </span><span class="nc">{
        throw SecretsStorageError.invalidOperation
    }</span><span class="">
}

</span></pre><pre id="f29" style="display: none"><span>//
//  Array+AsyncMap.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 17/05/2025.
//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension Collection where Element: Sendable {
    func asyncMap&lt;T: Sendable&gt;(
        _ transform: @Sendable @escaping (Element) async throws -&gt; T
    ) async rethrows -&gt; [T] </span><span class="c">{
        try await withThrowingTaskGroup(of: (Int, T).self) </span><span class="c">{ group in
            for (index, element) in enumerated() </span><span class="c">{
                group.addTask </span><span class="c">{
                    (index, try await transform(element)</span><span class="c">)
                }</span><span class="c">
            }</span><span class="c">

            var results = [T?](repeating: nil, count: count)
            for</span><span class="c"> try await (index, value) in group </span><span class="c">{
                results[index] = value
            }</span><span class="c">

            return results.compactMap </span><span class="c">{ $0 }</span><span class="c">
        }</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f30" style="display: none"><span>//
//  FileHandler.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 20/08/2022.
//

import Logging

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

// the methods I want to mock for unit testing
protocol FileHandlerProtocol: Sendable {
    nonisolated func move(from src: URL, to dst: URL) throws
    func fileExists(file: URL, fileSize: Int) -&gt; Bool
    func checkFileSize(file: URL, fileSize: Int) throws -&gt; Bool
    func downloadedFiles() throws -&gt; [String]
    func downloadFilePath(file: DownloadList.File) async -&gt; String
    func downloadFileURL(file: DownloadList.File) async -&gt; URL
    func saveDownloadList(list: DownloadList) throws -&gt; DownloadList
    func loadDownloadList() throws -&gt; DownloadList
    func baseFilePath() -&gt; URL
    func baseFilePath() -&gt; String
    func downloadDirectory() -&gt; URL
}

enum FileHandlerError: Error {
    case fileDoesNotExist
    case noDownloadedList
}

struct FileHandler: FileHandlerProtocol {

    private let log: Logger
    init(log: Logger) </span><span class="c">{
        self.log = log
    }</span><span class="">

    private static let baseDirectory = FileManager.default.homeDirectoryForCurrentUser
        .appendingPathComponent(".xcodeinstall")
    func downloadDirectory() -&gt; URL </span><span class="nc">{ FileHandler.baseDirectory.appendingPathComponent("download") }</span><span class="">
    func downloadListPath() -&gt; URL </span><span class="c">{ FileHandler.baseDirectory.appendingPathComponent("downloadList") }</span><span class="">

    func baseFilePath() -&gt; String </span><span class="nc">{
        baseFilePath().path
    }</span><span class="">
    func baseFilePath() -&gt; URL </span><span class="c">{

        // if base directory does not exist, create it
        let fm = FileManager.default  // swiftlint:disable:this identifier_name
        if </span><span class="c">!fm.fileExists(atPath: FileHandler.baseDirectory.path)</span><span class="c"> </span><span class="nc">{
            do </span><span class="nc">{
                try FileManager.default.createDirectory(at: downloadDirectory(), withIntermediateDirectories: true)</span><span class="nc">
            }</span><span class="nc"> catch </span><span class="nc">{
                log.error</span><span class="nc">(</span><span class="nc">"üõë Can not create base directory : \(FileHandler.baseDirectory.path)\n\(error)"</span><span class="nc">)
            }</span><span class="nc">
        }</span><span class="c">

        return FileHandler.baseDirectory</span><span class="c">
    }</span><span class="">

    nonisolated func move(from src: URL, to dst: URL) throws </span><span class="c">{
        do </span><span class="c">{
            if </span><span class="c">FileManager.default.fileExists(atPath: dst.path)</span><span class="c"> </span><span class="c">{
                log.debug</span><span class="nc">(</span><span class="nc">"‚ö†Ô∏è File \(dst) exists, I am overwriting it"</span><span class="c">)
                try FileManager.default.removeItem(atPath: dst.path)</span><span class="c">
            }</span><span class="c">

            let dstUrl = URL(fileURLWithPath: dst.path)
            try FileManager.default.moveItem(at: src, to: dstUrl)</span><span class="c">

        }</span><span class="c"> catch </span><span class="c">{
            log.error</span><span class="c">(</span><span class="c">"üõë Can not move file : \(error)"</span><span class="c">)
            throw error
        }</span><span class="c">
    }</span><span class="">

    func downloadFilePath(file: DownloadList.File) async -&gt; String </span><span class="nc">{
        await downloadFileURL(file: file).path
    }</span><span class="">
    func downloadFileURL(file: DownloadList.File) async -&gt; URL </span><span class="nc">{

        // if download directory does not exist, create it
        if </span><span class="nc">!FileManager.default.fileExists(atPath: downloadDirectory().path)</span><span class="nc"> </span><span class="nc">{
            do </span><span class="nc">{
                try FileManager.default.createDirectory(at: downloadDirectory(), withIntermediateDirectories: true)</span><span class="nc">
            }</span><span class="nc"> catch </span><span class="nc">{
                log.error</span><span class="nc">(</span><span class="nc">
                    </span><span class="nc">"üõë Can not create base directory : \(downloadDirectory().path)\n\(error)"</span><span class="nc">
                )
            }</span><span class="nc">
        }</span><span class="nc">
        return downloadDirectory().appendingPathComponent(file.filename)</span><span class="nc">

    }</span><span class="">

    /// Check if file exists and has correct size
    ///  - Parameters:
    ///     - filePath the path of the file to verify
    ///     - fileSize the expected size of the file (in bytes).
    ///  - Returns : true when the file exists and has the given size, false otherwise
    ///  - Throws:
    ///     - FileHandlerError.FileDoesNotExist when the file does not exists
    func checkFileSize(file: URL, fileSize: Int) throws -&gt; Bool </span><span class="c">{

        let filePath = file.path

        // file exists ?
        let exists = FileManager.default.fileExists(atPath: filePath)
        if </span><span class="c">!exists</span><span class="c"> </span><span class="c">{ throw FileHandlerError.fileDoesNotExist }</span><span class="c">

        // file size ?
        let attributes = try? FileManager.default.attributesOfItem(atPath: filePath)
        let actualSize = attributes?[.size] as? Int

        // at this stage, we know the file exists, just check size now
        return actualSize == fileSize</span><span class="c">
    }</span><span class="">

    /// Check if file exists and has correct size
    /// - Parameters:
    ///     - filePath the path of the file to verify
    ///     - fileSize the expected size of the file (in bytes).
    ///       when omitted, file size is not checked
    func fileExists(file: URL, fileSize: Int = 0) -&gt; Bool </span><span class="c">{

        let filePath = file.path

        let fileExists = FileManager.default.fileExists(atPath: filePath)
        // does the file exists ?
        if </span><span class="c">!fileExists</span><span class="c"> </span><span class="c">{
            return false
        }</span><span class="c">

        // is the file complete ?
        // use try! because I verified if file exists already
        let fileComplete = try? self.checkFileSize(file: file, fileSize: fileSize)

        return (fileSize &gt; 0 ? </span><span class="c">fileComplete ?? </span><span class="nc">false</span><span class="c"> : </span><span class="nc">fileExists</span><span class="c">)</span><span class="c">
    }</span><span class="">

    func downloadedFiles() throws -&gt; [String] </span><span class="nc">{
        do </span><span class="nc">{
            return try FileManager.default.contentsOfDirectory(atPath: downloadDirectory().path)
        }</span><span class="nc"> catch </span><span class="nc">{
            log.debug</span><span class="nc">(</span><span class="nc">"\(error)"</span><span class="nc">)
            throw FileHandlerError.noDownloadedList
        }
    }</span><span class="">

    func saveDownloadList(list: DownloadList) throws -&gt; DownloadList </span><span class="nc">{

        // ensure base directory exists before saving
        let _: URL = baseFilePath()

        // save list
        let data = try JSONEncoder().encode(list)</span><span class="nc">
        try data.write(to: downloadListPath())</span><span class="nc">

        return list</span><span class="nc">

    }</span><span class="">

    func loadDownloadList() throws -&gt; DownloadList </span><span class="nc">{

        // read the raw file saved on disk
        let listData = try Data(contentsOf: downloadListPath())</span><span class="nc">

        return try JSONDecoder().decode(DownloadList.self, from: listData)</span><span class="nc">
    }</span><span class="">
}

</span></pre><pre id="f31" style="display: none"><span>//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2025 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import protocol Foundation.ContiguousBytes
#endif

@usableFromInline
package struct HexEncoding&lt;Base: Sequence&gt; where Base.Element == UInt8 {
    @usableFromInline
    var base: Base

    @inlinable
    package init(_ base: Base) </span><span class="c">{
        self.base = base
    }</span><span class="">
}

extension HexEncoding: Sequence {
    @usableFromInline
    package typealias Element = UInt8

    @usableFromInline
    package struct Iterator: IteratorProtocol {
        @usableFromInline
        package typealias Element = UInt8

        @usableFromInline
        var base: Base.Iterator
        @usableFromInline
        var _next: UInt8?

        @inlinable
        init(base: Base.Iterator) </span><span class="c">{
            self.base = base
            self._next = nil
        }</span><span class="">

        @inlinable
        package mutating func next() -&gt; UInt8? </span><span class="c">{
            switch </span><span class="c">self._next</span><span class="c"> {
            </span><span class="c">case .none:
                guard let underlying = self.base.next() else </span><span class="c">{
                    return nil
                }</span><span class="c">
                let first = underlying &gt;&gt; 4
                let second = underlying &amp; 0x0F
                self._next = second.makeBase16Ascii()
                return first.makeBase16Ascii()</span><span class="c">

            </span><span class="c">case .some(let next):
                self._next = nil
                return next</span><span class="c">
            }
        }</span><span class="">
    }

    @inlinable
    package func makeIterator() -&gt; Iterator </span><span class="c">{
        Iterator(base: self.base.makeIterator())
    }</span><span class="">
}

extension HexEncoding: Collection where Base: Collection {
    @usableFromInline
    package struct Index: Comparable {
        @inlinable
        init(base: Base.Index, first: Bool) </span><span class="nc">{
            self.base = base
            self.first = first
        }</span><span class="">

        @inlinable
        package static func &lt; (lhs: HexEncoding&lt;Base&gt;.Index, rhs: HexEncoding&lt;Base&gt;.Index) -&gt; Bool </span><span class="nc">{
            if </span><span class="nc">lhs.base &lt; rhs.base</span><span class="nc"> </span><span class="nc">{
                return true
            }</span><span class="nc"> else if </span><span class="nc">lhs.base &gt; rhs.base</span><span class="nc"> </span><span class="nc">{
                return false
            }</span><span class="nc"> else if </span><span class="nc">lhs.first &amp;&amp; </span><span class="nc">!rhs.first</span><span class="nc"> </span><span class="nc">{
                return true
            }</span><span class="nc"> else </span><span class="nc">{
                return false
            }</span><span class="nc">
        }</span><span class="">

        @usableFromInline
        var base: Base.Index
        @usableFromInline
        var first: Bool
    }

    @inlinable
    package var startIndex: Index </span><span class="nc">{
        Index(base: self.base.startIndex, first: true)
    }</span><span class="">

    @inlinable
    package var endIndex: Index </span><span class="nc">{
        Index(base: self.base.endIndex, first: true)
    }</span><span class="">

    @inlinable
    package func index(after i: Index) -&gt; Index </span><span class="nc">{
        if </span><span class="nc">i.first</span><span class="nc"> </span><span class="nc">{
            return Index(base: i.base, first: false)
        }</span><span class="nc"> else </span><span class="nc">{
            return Index(base: self.base.index(after: i.base), first: true)
        }</span><span class="nc">
    }</span><span class="">

    @inlinable
    package subscript(position: Index) -&gt; UInt8 </span><span class="nc">{
        let value = self.base[position.base]
        let base16 = position.first ? </span><span class="nc">value &gt;&gt; 4</span><span class="nc"> : </span><span class="nc">value &amp; 0x0F</span><span class="nc">
        return base16.makeBase16Ascii()
    }</span><span class="">
}

extension UInt8 {
    @inlinable
    func makeBase16Ascii() -&gt; UInt8 </span><span class="c">{
        assert(</span><span class="c">self &lt; 16</span><span class="c">)
        if </span><span class="c">self &lt; 10</span><span class="c"> </span><span class="c">{
            return self + UInt8(ascii: "0")
        }</span><span class="c"> else </span><span class="c">{
            return self - 10 + UInt8(ascii: "a")
        }</span><span class="c">
    }</span><span class="">
}

extension ContiguousBytes {
    /// return a hexEncoded string buffer from an array of bytes
    @_disfavoredOverload
    @inlinable
    public func hexDigest() -&gt; String </span><span class="c">{
        self.withUnsafeBytes </span><span class="c">{ ptr in
            ptr.hexDigest()
        }</span><span class="c">
    }</span><span class="">
}

extension Collection&lt;UInt8&gt; {
    /// return a hexEncoded string buffer from an array of bytes
    @inlinable
    public func hexDigest() -&gt; String </span><span class="c">{
        String(decoding: HexEncoding(self), as: Unicode.UTF8.self)
    }</span><span class="">
}

</span></pre><pre id="f32" style="display: none"><span>//
//  ShellOutput.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 16/05/2025.
//

import Subprocess

#if canImport(System)
import System
#else
import SystemPackage
#endif

/// Shell command execution
protocol ShellExecuting: Sendable {
    func run(
        _ executable: Executable,
        arguments: Arguments,
        workingDirectory: FilePath?
    ) async throws -&gt; ShellOutput
    func run(
        _ executable: Executable,
        arguments: Arguments
    ) async throws -&gt; ShellOutput
}

// MARK: - Production shell executor

struct SystemShell: ShellExecuting, Sendable {
    func run(
        _ executable: Executable,
        arguments: Arguments,
        workingDirectory: FilePath?
    ) async throws -&gt; ShellOutput </span><span class="nc">{
        try await Subprocess.run(
            executable,
            arguments: arguments,
            environment: .inherit,
            workingDirectory: workingDirectory,
            platformOptions: PlatformOptions(),
            input: .none,
            output: .string(limit: 2048, encoding: UTF8.self),
            error: .string(limit: 2048, encoding: UTF8.self)
        )</span><span class="nc">
    }</span><span class="">

    func run(
        _ executable: Executable,
        arguments: Arguments
    ) async throws -&gt; ShellOutput </span><span class="nc">{
        try await run(executable, arguments: arguments, workingDirectory: nil)</span><span class="nc">
    }</span><span class="">
}

typealias ShellOutput = CollectedResult&lt;StringOutput&lt;Unicode.UTF8&gt;, StringOutput&lt;Unicode.UTF8&gt;&gt;

extension Executable {
    public static func path(_ path: String) -&gt; Self </span><span class="c">{
        Executable.path(FilePath(path))
    }</span><span class="">
}

</span></pre><pre id="f33" style="display: none"><span>// Generated by: scripts/simple-deploy/release.sh
struct Version {
    let current = </span><span class="c">"0.17.2"</span><span class="">
}

</span></pre><pre id="f34" style="display: none"><span>//
//  AuthenticateCommand.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 16/08/2022.
//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

import SotoSecretsManager

// MARK: - CLIAuthenticationDelegate

struct CLIAuthenticationDelegate: AuthenticationDelegate, Sendable {
    let deps: AppDependencies

    func requestCredentials() async throws -&gt; (username: String, password: String) </span><span class="c">{
        let creds = try await retrieveAppleCredentials()</span><span class="c">
        return (creds.username, creds.password)</span><span class="c">
    }</span><span class="">

    func requestMFACode(options: [MFAOption]) async throws -&gt; (option: MFAOption, code: String) </span><span class="c">{
        guard !options.isEmpty else </span><span class="nc">{
            throw CLIError.invalidInput
        }</span><span class="c">

        // Single option ‚Äî just prompt for the code
        if </span><span class="c">options.count == 1</span><span class="c"> </span><span class="c">{
            let option = options[0]
            let codeLength: Int
            let prompt: String

            switch </span><span class="c">option</span><span class="c"> {
            </span><span class="c">case .trustedDevice(let len):
                codeLength = len
                prompt = "Enter your \(codeLength)-digit 2FA code: "</span><span class="c">
            </span><span class="nc">case .sms(let phone, let len):
                codeLength = len
                let phoneDesc = phone.obfuscatedNumber ?? </span><span class="nc">"unknown"</span><span class="nc">
                prompt = "Enter the \(codeLength)-digit code sent to \(phoneDesc): "</span><span class="c">
            }</span><span class="c">

            guard let code = deps.readLine.readLine(prompt: prompt, silent: false) else </span><span class="nc">{
                throw CLIError.invalidInput
            }</span><span class="c">
            return (option, code)</span><span class="c">
        }</span><span class="nc">

        // Multiple options ‚Äî present a menu
        display("Choose verification method:", style: .security)
        for (i, option) in options.enumerated() </span><span class="nc">{
            switch </span><span class="nc">option</span><span class="nc"> {
            </span><span class="nc">case .trustedDevice:
                display("  \(i + 1). Trusted device")</span><span class="nc">
            </span><span class="nc">case .sms(let phone, _):
                let phoneDesc = phone.numberWithDialCode ?? </span><span class="nc">phone.obfuscatedNumber ?? </span><span class="nc">"unknown"</span><span class="nc">
                display("  \(i + 1). SMS to \(phoneDesc)")
            }</span><span class="nc">
        }</span><span class="nc">

        guard let choiceStr = deps.readLine.readLine(prompt: "Choice: ", silent: false),
              let choice = Int(choiceStr),
              choice &gt; 0,
              choice &lt;= options.count
        else </span><span class="nc">{
            throw CLIError.invalidInput
        }</span><span class="nc">

        let selected = options[choice - 1]

        switch </span><span class="nc">selected</span><span class="nc"> {
        </span><span class="nc">case .trustedDevice(let codeLength):
            let prompt = "Enter your \(codeLength)-digit 2FA code: "
            guard let code = deps.readLine.readLine(prompt: prompt, silent: false) else </span><span class="nc">{
                throw CLIError.invalidInput
            }</span><span class="nc">
            return (selected, code)</span><span class="nc">
        </span><span class="nc">case .sms:
            // Return empty code ‚Äî the authenticator will send the SMS
            // and call requestMFACode again with just this SMS option
            return (selected, "")</span><span class="nc">
        }
    }</span><span class="">

    // MARK: - Credential retrieval (moved from XCodeInstall)

    private func display(_ msg: String, terminator: String = "\n") </span><span class="c">{
        deps.display.display(msg, terminator: terminator)
    }</span><span class="">

    private func display(_ msg: String, style: DisplayStyle) </span><span class="c">{
        deps.display.display(msg, style: style)
    }</span><span class="">

    private func retrieveAppleCredentials() async throws -&gt; AppleCredentialsSecret </span><span class="c">{

        guard let secrets = deps.secrets else </span><span class="c">{
            // no secrets backend configured, prompt interactively
            return try promptForCredentials()
        }</span><span class="c">

        var appleCredentials: AppleCredentialsSecret
        do </span><span class="c">{
            // first try on AWS Secrets Manager
            display("Retrieving Apple Developer Portal credentials...")
            appleCredentials = try await secrets.retrieveAppleCredentials()</span><span class="c">

            // empty credentials means the secret exists but has no real values
            if </span><span class="c">appleCredentials.username.isEmpty || </span><span class="c">appleCredentials.password.isEmpty</span><span class="c"> </span><span class="nc">{
                display("Apple credentials secret exists but is empty.")
                appleCredentials = try promptForCredentials(storingToAWS: true)</span><span class="nc">
                try await secrets.storeAppleCredentials(appleCredentials)</span><span class="nc">
                display("Credentials stored in AWS Secrets Manager", style: .security)
            }</span><span class="c">

        }</span><span class="c"> catch SecretsStorageError.invalidOperation </span><span class="nc">{

            // we have a file secrets handler, prompt for credentials interactively
            appleCredentials = try promptForCredentials()</span><span class="nc">

        }</span><span class="c"> catch let error as SotoSecretsManager.SecretsManagerErrorType
            where error == .resourceNotFoundException
        </span><span class="nc">{
            // the apple credentials secret doesn't exist yet in AWS Secrets Manager
            // prompt the user and create it transparently
            display("Apple credentials not found in AWS Secrets Manager, capturing them now...")
            appleCredentials = try promptForCredentials(storingToAWS: true)</span><span class="nc">
            try await secrets.storeAppleCredentials(appleCredentials)</span><span class="nc">
            display("Credentials stored in AWS Secrets Manager", style: .security)

        }</span><span class="c"> catch </span><span class="nc">{

            // unexpected errors, do not handle here
            throw error
        }</span><span class="c">

        return appleCredentials</span><span class="c">
    }</span><span class="">

    private func promptForCredentials(storingToAWS: Bool = false) throws -&gt; AppleCredentialsSecret </span><span class="c">{
        if </span><span class="c">storingToAWS</span><span class="c"> </span><span class="nc">{
            display(
                """
                Your Apple ID credentials will be securely stored in AWS Secrets Manager
                for future authentication.
                """,
                style: .security
            )
        }</span><span class="c"> else </span><span class="c">{
            display(
                """
                We prompt you for your Apple ID username, password, and two factors authentication code.
                These values are not stored anywhere. They are used to get an Apple session ID.

                Alternatively, you may store your credentials on AWS Secrets Manager
                """,
                style: .security
            )
        }</span><span class="c">

        guard
            let username = deps.readLine.readLine(
                prompt: "Enter your Apple ID username: ",
                silent: false
            )
        else </span><span class="nc">{
            throw CLIError.invalidInput
        }</span><span class="c">

        guard
            let password = deps.readLine.readLine(
                prompt: "Enter your Apple ID password: ",
                silent: true
            )
        else </span><span class="nc">{
            throw CLIError.invalidInput
        }</span><span class="c">

        return AppleCredentialsSecret(username: username, password: password)</span><span class="c">
    }</span><span class="">
}

// MARK: - XCodeInstall authenticate command

extension XCodeInstall {

    func authenticate(with authenticationMethod: AuthenticationMethod) async throws </span><span class="c">{

        let auth = self.deps.authenticator
        let delegate = CLIAuthenticationDelegate(deps: self.deps)

        do </span><span class="c">{

            // delete previous session, if any
            try await self.deps.secrets?.clearSecrets()</span><span class="c">

            if </span><span class="c">authenticationMethod == .usernamePassword</span><span class="c"> </span><span class="c">{
                display("Authenticating with username and password (likely to fail) ...")
            }</span><span class="c"> else </span><span class="c">{
                display("Authenticating...")
            }</span><span class="c">
            try await auth.authenticate(with: authenticationMethod, delegate: delegate)</span><span class="c">
            display("Authenticated.", style: .success)

        }</span><span class="c"> catch AuthenticationError.invalidUsernamePassword </span><span class="c">{

            // handle invalid username or password
            display("Invalid username or password.", style: .error())
            throw AuthenticationError.invalidUsernamePassword

        }</span><span class="c"> catch AuthenticationError.requires2FATrustedPhoneNumber </span><span class="c">{

            display(
                """
                Two factors authentication is enabled but no verification methods are available.
                Please ensure you have trusted devices or phone numbers configured:
                https://support.apple.com/en-us/HT204915
                """,
                style: .security
            )
            throw AuthenticationError.requires2FATrustedPhoneNumber

        }</span><span class="c"> catch AuthenticationError.serviceUnavailable </span><span class="nc">{

            // service unavailable means that the authentication method requested is not available
            display("Requested authentication method is not available. Try with SRP.", style: .error())
            throw AuthenticationError.serviceUnavailable

        }</span><span class="c"> catch AuthenticationError.unableToRetrieveAppleServiceKey(let error) </span><span class="nc">{

            // handle connection errors
            display(
                "Can not connect to Apple Developer Portal.\nOriginal error : \(error?.localizedDescription ?? </span><span class="nc">"nil"</span><span class="nc">)",
                style: .error()
            )
            throw AuthenticationError.unableToRetrieveAppleServiceKey(error)

        }</span><span class="c"> catch AuthenticationError.notImplemented(let feature) </span><span class="nc">{

            // handle not yet implemented errors
            display(
                "\(feature) is not yet implemented. Try the next version of xcodeinstall when it will be available.",
                style: .error()
            )
            throw AuthenticationError.notImplemented(featureName: feature)

        }</span><span class="c"> catch let error as SecretsStorageAWSError </span><span class="nc">{
            display("AWS Error: \(error.localizedDescription)", style: .error())
            throw error

        }</span><span class="c"> catch </span><span class="nc">{
            display("Unexpected Error : \(error)", style: .error())
            throw error
        }</span><span class="c">
    }</span><span class="">

}

</span></pre><pre id="f35" style="display: none"><span>//
//  DownloadCommand.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 16/08/2022.
//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension XCodeInstall {

    // swiftlint:disable: function_parameter_count
    func download(
        fileName: String?,
        force: Bool,
        xCodeOnly: Bool,
        majorVersion: String,
        sortMostRecentFirst: Bool,
        datePublished: Bool
    ) async throws </span><span class="c">{

        let download = self.deps.downloader
        var fileToDownload: DownloadList.File
        do </span><span class="c">{

            // when filename was given by user
            if </span><span class="c">fileName != nil</span><span class="c"> </span><span class="c">{

                // search matching filename in the download list cache
                let (list, _) = try await download.list(force: force)</span><span class="c">
                if let result = list.find(fileName: fileName!) </span><span class="c">{
                    fileToDownload = result
                }</span><span class="c"> else </span><span class="c">{
                    throw DownloadError.unknownFile(file: fileName!)
                }</span><span class="c">

            }</span><span class="c"> else </span><span class="c">{

                // when no file was given, ask user
                fileToDownload = try await self.askFile(
                    force: force,
                    xCodeOnly: xCodeOnly,
                    majorVersion: majorVersion,
                    sortMostRecentFirst: sortMostRecentFirst,
                    datePublished: datePublished
                )</span><span class="c">
            }</span><span class="c">

            // now we have a filename, let's proceed with download
            let progressBar = self.deps.progressBar
            progressBar.define(
                animationType: .percentProgressAnimation,
                message: "Downloading \(fileToDownload.displayName ?? </span><span class="nc">fileToDownload.filename</span><span class="c">)"
            )

            for</span><span class="c"> try await progress in try await download.download(file: fileToDownload)</span><span class="c"> </span><span class="nc">{
                var text = "\(progress.bytesWritten/1024/1024) MB"
                text += String(format: " / %.2f MBs", progress.bandwidth)
                progressBar.update(
                    step: Int(progress.bytesWritten / 1024),
                    total: Int(progress.totalBytes / 1024),
                    text: text
                )
            }</span><span class="c">
            progressBar.complete(success: true)

            // check if the downloaded file is complete
            let fh = self.deps.fileHandler
            let file: URL = await fh.downloadFileURL(file: fileToDownload)
            let complete = try? self.deps.fileHandler.checkFileSize(
                file: file,
                fileSize: fileToDownload.fileSize
            )
            if </span><span class="c">!(complete ?? </span><span class="nc">false</span><span class="c">) </span><span class="nc">{
                display("Downloaded file has incorrect size, it might be incomplete or corrupted", style: .error())
            }</span><span class="c"> else </span><span class="c">{
                display("\(fileName ?? </span><span class="c">"file"</span><span class="c">) downloaded", style: .success)
            }
        }</span><span class="c"> catch DownloadError.authenticationRequired </span><span class="nc">{
            display(
                "Session expired, you need to re-authenticate.",
                style: .error(nextSteps: ["xcodeinstall authenticate"])
            )
            throw DownloadError.authenticationRequired
        }</span><span class="c"> catch CLIError.userCancelled </span><span class="nc">{
            return
        }</span><span class="c"> catch CLIError.invalidInput </span><span class="nc">{
            display("Invalid input", style: .error())
            throw CLIError.invalidInput
        }</span><span class="c"> catch DownloadError.unknownFile(let fileName) </span><span class="c">{
            display("Unknown file name : \(fileName)", style: .error())
            throw DownloadError.unknownFile(file: fileName)
        }</span><span class="c"> catch let error as SecretsStorageAWSError </span><span class="nc">{
            display("AWS Error: \(error.localizedDescription)", style: .error())
            throw error
        }</span><span class="c"> catch </span><span class="nc">{
            display("Unexpected error : \(error)", style: .error())
            throw error
        }</span><span class="c">
    }</span><span class="">

    func askFile(
        force: Bool,
        xCodeOnly: Bool,
        majorVersion: String,
        sortMostRecentFirst: Bool,
        datePublished: Bool
    ) async throws -&gt; DownloadList.File </span><span class="c">{

        let parsedList = try await self.list(
            force: force,
            xCodeOnly: xCodeOnly,
            majorVersion: majorVersion,
            sortMostRecentFirst: sortMostRecentFirst,
            datePublished: datePublished
        )</span><span class="c">

        // this is used when debugging
        //        return parsedList[31].files[1]

        let num = try askUser(prompt: "Which one do you want to download? ")</span><span class="c">

        guard num &gt;= 0, num &lt; parsedList.count else </span><span class="nc">{
            throw CLIError.invalidInput
        }</span><span class="c">

        if </span><span class="c">parsedList[num].files.count == 1</span><span class="c"> </span><span class="c">{
            return parsedList[num].files[0]
        }</span><span class="c"> else </span><span class="nc">{
            // there is more than one file for this download, ask the user which one to download
            var line = "\nThere is more than one file for this download:\n"

            parsedList[num].files.enumerated().forEach </span><span class="nc">{ index, file in
                line += "   |__ [\(String(format: "%02d", index))] \(file.filename) (\(file.fileSize/1024/1024) Mb)\n"
            }</span><span class="nc">
            line += "\n Which one do you want to download? "

            let fileNum = try askUser(prompt: line)</span><span class="nc">
            guard fileNum &gt;= 0, fileNum &lt; parsedList[num].files.count else </span><span class="nc">{
                throw CLIError.invalidInput
            }</span><span class="nc">
            return parsedList[num].files[fileNum]</span><span class="nc">
        }</span><span class="c">
    }</span><span class="">

    private func askUser(prompt: String) throws -&gt; Int </span><span class="c">{
        let response: String? = self.deps.readLine.readLine(
            prompt: prompt,
            silent: false
        )
        guard let number = response,
            let num = Int(number)
        else </span><span class="nc">{

            if </span><span class="nc">(response ?? </span><span class="nc">""</span><span class="nc">) == "" </span><span class="nc">{
                throw CLIError.userCancelled
            }</span><span class="nc">
            throw CLIError.invalidInput</span><span class="nc">
        }</span><span class="c">
        return num</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f36" style="display: none"><span>//
//  DownloadListParser.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 24/07/2022.
//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

struct DownloadListParser {

    let fileHandler: FileHandlerProtocol
    let xCodeOnly: Bool
    let majorVersion: String
    let sortMostRecentFirst: Bool

    init(fileHandler: FileHandlerProtocol, xCodeOnly: Bool = true, majorVersion: String = "13", sortMostRecentFirst: Bool = false) </span><span class="c">{
        self.fileHandler = fileHandler
        self.xCodeOnly = xCodeOnly
        self.majorVersion = majorVersion
        self.sortMostRecentFirst = sortMostRecentFirst
    }</span><span class="">

    func parse(list: DownloadList?) throws -&gt; [DownloadList.Download] </span><span class="c">{

        guard let list = list?.downloads else </span><span class="nc">{
            throw DownloadError.noDownloadsInDownloadList
        }</span><span class="c">

        // filter on items having Xcode in their name
        let listOfXcode = list.filter </span><span class="c">{ download in
            if </span><span class="c">xCodeOnly</span><span class="c"> </span><span class="c">{
                return download.name.starts(with: "Xcode \(majorVersion)")
            }</span><span class="c"> else </span><span class="c">{
                return download.name.contains("Xcode \(majorVersion)")
            }</span><span class="c">
        }</span><span class="c">

        // sort by date (most recent last)
        let sortedList = listOfXcode.sorted </span><span class="c">{ (downloadA, downloadB) in

            var dateA: String
            var dateB: String

            // select a non nil-date, either Published or Created.
            if let pubDateA = downloadA.datePublished,
                let pubDateB = downloadB.datePublished
            </span><span class="c">{
                dateA = pubDateA
                dateB = pubDateB
            }</span><span class="c"> else </span><span class="nc">{
                dateA = downloadA.dateCreated
                dateB = downloadB.dateCreated
            }</span><span class="c">

            // parse the string and return a date
            if let aAsDate = dateA.toDate(),
                let bAsDate = dateB.toDate()
            </span><span class="c">{
                return self.sortMostRecentFirst ? </span><span class="c">aAsDate &gt; bAsDate</span><span class="c"> : </span><span class="nc">aAsDate &lt; bAsDate</span><span class="c">
            } else </span><span class="nc">{
                // I don't know what to do when we can not parse the date
                return false
            }</span><span class="c">
        }</span><span class="c">

        return sortedList
    }</span><span class="">

    /// Enrich the list of available downloads.
    /// It adds a flag for each file in the list to indicate if the file is already downloaded and available in cache
    func enrich(list: [DownloadList.Download]) async -&gt; [DownloadList.Download] </span><span class="c">{

        await list.asyncMap </span><span class="c">{ download in
            let fh = self.fileHandler

            // swiftlint:disable identifier_name
            let file = download.files[0]

            let fileCopy = file
            let downloadFile: URL = await fh.downloadFileURL(file: fileCopy)
            let exists = await fh.fileExists(file: downloadFile, fileSize: file.fileSize)

            // create a copy of the file to be used in the list
            let newFile = await DownloadList.File.init(from: file, existInCache: exists)

            // create a copy of the download to be used in the list
            let newDownload = await DownloadList.Download(
                from: download,
                replaceWith: newFile
            )

            return newDownload

        }</span><span class="c">
    }</span><span class="">

    func prettyPrint(list: [DownloadList.Download], withDate: Bool = true) -&gt; String </span><span class="c">{

        // var result = ""

        // map returns a [String] each containing a line to display
        let result: String = list.enumerated().map </span><span class="c">{ (index, download) in
            var line: String = ""

            if </span><span class="c">download.files.count == 1</span><span class="c"> </span><span class="c">{
                let file = download.files[0]
                // swiftlint:disable line_length
                line +=
                    "[\(String(format: "%02d", index))] \(download.name) [\"\(file.filename)\" (\(file.fileSize/1024/1024) Mb)] \(file.existInCache ? </span><span class="c">"(*)"</span><span class="c"> : </span><span class="c">""</span><span class="c">)"

                if </span><span class="c">withDate</span><span class="c"> </span><span class="c">{
                    if let date = download.datePublished </span><span class="c">{
                        let das = date.toDate()
                        line += " (published on \(das?.formatted(date: .numeric, time: .omitted) ?? </span><span class="nc">""</span><span class="c">))"
                    } else </span><span class="nc">{
                        let das = download.dateCreated.toDate()
                        line += " (created on \(das?.formatted(date: .numeric, time: .omitted) ?? </span><span class="nc">""</span><span class="nc">))"
                    }</span><span class="c">
                }
            } else </span><span class="nc">{
                line += "[\(String(format: "%02d", index))] \(download.name)"

                download.files.forEach </span><span class="nc">{ file in
                    line +=
                        "\n     |__ \(file.filename) (\(file.fileSize/1024/1024) Mb) \(file.existInCache ? </span><span class="nc">"(*)"</span><span class="nc"> : </span><span class="nc">""</span><span class="nc">)"
                }

            }</span><span class="c">

            return line
        }</span><span class="c">
        // join all strings in [] with a \n
        .joined(separator: "\n")

        return result
    }</span><span class="">
}

// Thread-safe: isolated to @MainActor via defaultIsolation(MainActor.self) in Package.swift
private let appleDownloadDateFormatter: DateFormatter = </span><span class="c">{
    let f = DateFormatter()
    f.locale = Locale(identifier: "en_US_POSIX")
    f.dateFormat = "MM-dd-yy HH:mm"
    return f
}</span><span class="">()

extension String {

    func toDate() -&gt; Date? </span><span class="c">{
        return appleDownloadDateFormatter.date(from: self)
    }</span><span class="">
}

</span></pre><pre id="f37" style="display: none"><span>//
//  InstallCommand.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 22/08/2022.
//


#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension XCodeInstall {

    func install(file: String?) async throws </span><span class="c">{

        let installer = ShellInstaller(fileHandler: self.deps.fileHandler, progressBar: self.deps.progressBar, shellExecutor: self.deps.shell, log: self.log)

        // progress bar to report progress feedback
        let progressBar = self.deps.progressBar
        progressBar.define(
            animationType: .countingProgressAnimationMultiLine,
            message: "Installing..."
        )

        var fileToInstall: URL?
        do </span><span class="c">{
            // when no file is specified, prompt user to select one
            if </span><span class="c">nil == file</span><span class="c"> </span><span class="nc">{
                fileToInstall = try promptForFile()</span><span class="nc">
            }</span><span class="c"> else </span><span class="c">{
                fileToInstall = self.deps.fileHandler.downloadDirectory().appendingPathComponent(file!)
            }</span><span class="c">
            log.debug</span><span class="c">(</span><span class="c">"Going to attempt to install \(fileToInstall!.path)"</span><span class="c">)

            try await installer.install(file: fileToInstall!)</span><span class="nc">
            self.deps.progressBar.complete(success: true)
            display("\(fileToInstall!) installed", style: .success)
        }</span><span class="c"> catch CLIError.userCancelled </span><span class="nc">{
            return
        }</span><span class="c"> catch CLIError.invalidInput </span><span class="nc">{
            display("Invalid input", style: .error())
            self.deps.progressBar.complete(success: false)
            throw CLIError.invalidInput
        }</span><span class="c"> catch FileHandlerError.noDownloadedList </span><span class="nc">{
            display("There is no downloaded file to be installed", style: .warning)
            self.deps.progressBar.complete(success: false)
            throw FileHandlerError.noDownloadedList
        }</span><span class="c"> catch InstallerError.xCodeXIPInstallationError </span><span class="nc">{
            display("Can not expand XIP file. Is there enough space on / ? (16GiB required)", style: .error())
            self.deps.progressBar.complete(success: false)
            throw InstallerError.xCodeXIPInstallationError
        }</span><span class="c"> catch InstallerError.xCodeMoveInstallationError </span><span class="nc">{
            display("Can not move Xcode to /Applications", style: .error())
            self.deps.progressBar.complete(success: false)
            throw InstallerError.xCodeMoveInstallationError
        }</span><span class="c"> catch InstallerError.xCodePKGInstallationError </span><span class="nc">{
            display(
                "Can not install additional packages.",
                style: .error()
            )
            self.deps.progressBar.complete(success: false)
            throw InstallerError.xCodePKGInstallationError
        }</span><span class="c"> catch InstallerError.unsupportedInstallation </span><span class="c">{
            display(
                "Unsupported installation type. (We support Xcode XIP files and Command Line Tools PKG)",
                style: .error()
            )
            self.deps.progressBar.complete(success: false)
            throw InstallerError.unsupportedInstallation
        }</span><span class="c"> catch </span><span class="nc">{
            display("Error while installing \(String(describing: fileToInstall!))", style: .error())
            log.debug</span><span class="nc">(</span><span class="nc">"\(error)"</span><span class="nc">)
            self.deps.progressBar.complete(success: false)
            throw error
        }</span><span class="nc">
    }</span><span class="">

    func promptForFile() throws -&gt; URL </span><span class="c">{

        // list files ready to install
        let installableFiles = try self.deps.fileHandler.downloadedFiles()</span><span class="c">.filter(</span><span class="c">{ fileName in
            fileName.hasSuffix(".xip") || </span><span class="c">fileName.hasSuffix(".dmg")</span><span class="c">
        }</span><span class="c">)

        display("")
        display("Here is the list of available files to install:", style: .info)
        display("")
        let printableList = installableFiles.enumerated().map(</span><span class="c">{ (index, fileName) in
            "[\(String(format: "%02d", index))] \(fileName)"
        }</span><span class="c">).joined(separator: "\n")
        display(printableList)
        display("\(installableFiles.count) items")

        let response: String? = self.deps.readLine.readLine(
            prompt: "Which one do you want to install? ",
            silent: false
        )
        guard let number = response,
            let num = Int(number)
        else </span><span class="nc">{

            if </span><span class="nc">(response ?? </span><span class="nc">""</span><span class="nc">) == "" </span><span class="nc">{
                throw CLIError.userCancelled
            }</span><span class="nc">
            throw CLIError.invalidInput</span><span class="nc">
        }</span><span class="c">

        guard num &gt;= 0, num &lt; installableFiles.count else </span><span class="nc">{
            throw CLIError.invalidInput
        }</span><span class="c">

        return self.deps.fileHandler.downloadDirectory().appendingPathComponent(installableFiles[num])</span><span class="c">
    }</span><span class="">
}

</span></pre><pre id="f38" style="display: none"><span>//
//  ListCommand.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 16/08/2022.
//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension XCodeInstall {

    func list(
        force: Bool,
        xCodeOnly: Bool,
        majorVersion: String,
        sortMostRecentFirst: Bool,
        datePublished: Bool
    ) async throws -&gt; [DownloadList.Download] </span><span class="c">{

        let download = self.deps.downloader

        display("Loading list of available downloads...")

        do </span><span class="c">{
            let (list, source) = try await download.list(force: force)</span><span class="c">
            switch </span><span class="c">source</span><span class="c"> {
            </span><span class="c">case .cache:
                display("Fetched from cache in \(self.deps.fileHandler.baseFilePath())", style: .info)</span><span class="c">
            </span><span class="nc">case .network:
                if </span><span class="nc">!force</span><span class="nc"> </span><span class="nc">{
                    display("No cache found, downloaded from Apple Developer Portal", style: .info)
                }</span><span class="nc"> else </span><span class="nc">{
                    display("Forced download from Apple Developer Portal", style: .info)
                }</span><span class="c">
            }</span><span class="c">
            display("Done", style: .success)

            let parser = DownloadListParser(
                fileHandler: self.deps.fileHandler,
                xCodeOnly: xCodeOnly,
                majorVersion: majorVersion,
                sortMostRecentFirst: sortMostRecentFirst
            )
            let parsedList = try parser.parse(list: list)</span><span class="c">

            // enrich the list to flag files already downloaded
            let enrichedList = await parser.enrich(list: parsedList)

            display("")
            display("Here is the list of available downloads:", style: .info)
            display("  Files marked with (*) are already downloaded in \(self.deps.fileHandler.baseFilePath()) ")
            display("")
            let string = parser.prettyPrint(list: enrichedList, withDate: datePublished)
            display(string)
            display("\(enrichedList.count) items")

            return enrichedList</span><span class="c">

        } catch let error as DownloadError </span><span class="nc">{
            switch </span><span class="nc">error</span><span class="nc"> {
            </span><span class="nc">case .authenticationRequired:
                display(
                    "Session expired, you need to re-authenticate.",
                    style: .error(nextSteps: ["xcodeinstall authenticate"])
                )
                throw error</span><span class="nc">
            </span><span class="nc">case .accountNeedUpgrade(let code, let message):
                display("\(message) (Apple Portal error code : \(code))", style: .error())
                throw error</span><span class="nc">
            </span><span class="nc">case .needToAcceptTermsAndCondition:
                display(
                    """
                    This is a new Apple account, you need first to accept the developer terms of service.
                    Open a session at https://developer.apple.com/register/agree/
                    Read and accept the ToS and try again.
                    """,
                    style: .error()
                )
                throw error</span><span class="nc">
            </span><span class="nc">case .unknownError(let code, let message):
                display("\(message) (Unhandled download error : \(code))", style: .error())
                display(
                    "Please file an error report at https://github.com/sebsto/xcodeinstall/issues/new?assignees=&amp;labels=&amp;template=bug_report.md&amp;title="
                )
                throw error</span><span class="nc">
            </span><span class="nc">default:
                display("Unknown download error : \(error)", style: .error())
                display(
                    "Please file an error report at https://github.com/sebsto/xcodeinstall/issues/new?assignees=&amp;labels=&amp;template=bug_report.md&amp;title="
                )
                throw error</span><span class="nc">
            }
        }</span><span class="c"> catch let error as SecretsStorageAWSError </span><span class="nc">{
            display("AWS Error: \(error.localizedDescription)", style: .error())
            throw error
        }</span><span class="c"> catch </span><span class="nc">{
            display("Unexpected error : \(error)", style: .error())
            throw error
        }</span><span class="c">

    }</span><span class="">
}

</span></pre><pre id="f39" style="display: none"><span>//
//  SignOutCommand.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 16/08/2022.
//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension XCodeInstall {

    func signout() async throws </span><span class="c">{

        let auth = self.deps.authenticator

        do </span><span class="c">{
            display("Signing out...")
            try await auth.signout()</span><span class="c">
            display("Signed out.", style: .success)
        }</span><span class="c"> catch let error as SecretsStorageAWSError </span><span class="nc">{
            display("AWS Error: \(error.localizedDescription)", style: .error())
            throw error
        }</span><span class="c"> catch </span><span class="nc">{
            display("Unexpected error : \(error)", style: .error())
            throw error
        }</span><span class="c">

    }</span><span class="">
}

</span></pre><pre id="f40" style="display: none"><span>//
//  StoreSecretsCommand.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 05/09/2022.
//

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

extension XCodeInstall {

    func storeSecrets() async throws </span><span class="c">{

        guard let secretsHandler = self.deps.secrets else </span><span class="nc">{
            preconditionFailure(</span><span class="nc">"storeSecrets() called without a secrets backend ‚Äî this is a programming error"</span><span class="nc">)
        }</span><span class="c">
        do </span><span class="c">{
            // separate func for testability
            let credentials = try promptForCredentials()</span><span class="c">

            try await secretsHandler.storeAppleCredentials(credentials)</span><span class="c">
            display("Credentials are securely stored", style: .security)

        }</span><span class="c"> catch let error as SecretsStorageAWSError </span><span class="nc">{
            display("AWS Error: \(error.localizedDescription)", style: .error())
            throw error
        }</span><span class="c"> catch </span><span class="nc">{
            display("Unexpected error : \(error)", style: .error())
            throw error
        }</span><span class="c">

    }</span><span class="">

    func promptForCredentials() throws -&gt; AppleCredentialsSecret </span><span class="c">{
        display(
            """

            This command captures your Apple ID username and password and store them securely in AWS Secrets Manager.
            It allows this command to authenticate automatically, as long as no MFA is prompted.

            """,
            style: .security
        )

        guard
            let username = self.deps.readLine.readLine(
                prompt: "Enter your Apple ID username: ",
                silent: false
            )
        else </span><span class="nc">{
            throw CLIError.invalidInput
        }</span><span class="c">

        guard
            let password = self.deps.readLine.readLine(
                prompt: "Enter your Apple ID password: ",
                silent: true
            )
        else </span><span class="nc">{
            throw CLIError.invalidInput
        }</span><span class="c">

        return AppleCredentialsSecret(username: username, password: password)</span><span class="c">
    }</span><span class="">

}

</span></pre><pre id="f41" style="display: none"><span>//
//  XcodeInstallCommand.swift
//  xcodeinstall
//
//  Created by Stormacq, Sebastien on 16/08/2022.
//

import Logging

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif

final class XCodeInstall {

    let log: Logger
    var deps: AppDependencies

    public init(log: Logger, deps: AppDependencies) </span><span class="c">{
        self.log = log
        self.deps = deps
    }</span><span class="">

    // display a message to the user
    // avoid having to replicate the \n thorough the code
    func display(_ msg: String, terminator: String = "\n") </span><span class="c">{
        self.deps.display.display(msg, terminator: terminator)
    }</span><span class="">

    func display(_ msg: String, style: DisplayStyle) </span><span class="c">{
        self.deps.display.display(msg, style: style)
    }</span><span class="">

}

</span></pre><script>
  (function() {
    var filesEl = document.getElementById('files');
    var selectedEl;
    function select(fileID) {
      if (selectedEl != null) {
        selectedEl.style.display = 'none';
      }
      selectedEl = document.getElementById(fileID);
      if (selectedEl == null) {
        return;
      }
      filesEl.value = fileID;
      selectedEl.style.display = 'block';
      location.hash = fileID;
    }

    if (location.hash !== "") {
      select(location.hash.substr(1));
    }
    if (selectedEl == null) {
      select("f0");
    }

    filesEl.addEventListener('change', function() { 
      select(filesEl.value);
      window.scrollTo(0, 0);
    } , false);
  })();
</script>
</body></html>